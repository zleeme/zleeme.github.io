<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>4Ark × Blog</title>
  
  
  <link href="https://4ark.me/atom.xml" rel="self"/>
  
  <link href="https://4ark.me/"/>
  <updated>2022-05-17T05:28:58.963Z</updated>
  <id>https://4ark.me/</id>
  
  <author>
    <name>4Ark</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>周刊第12期：每周轮子计划、程序员应该如何写博客</title>
    <link href="https://4ark.me/post/weekly-12.html"/>
    <id>https://4ark.me/post/weekly-12.html</id>
    <published>2022-05-16T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本周轮子"><a href="#本周轮子" class="headerlink" title="本周轮子"></a>本周轮子</h2><p>以前看过一个小册子 <a href="https://github.yanhaixiang.com/make-wheels/">《一天学习一个 npm 轮子，十天后变成轮子哥 》</a>，觉得这种「首先实现一个最 Low 的解决方案，然后慢慢优化，进而推导出最终的源码」的学习思路非常不错，所以我也决定从现在开始，每周都学习造一个 npm 轮子。</p><p>当然前期只要专注于那些日常使用、相对简单的 npm 包，毕竟能力有限，太复杂的包就很难可以讲透。</p><p>这是本周的轮子：<a href="/post/weekly-npm-packages-01.html">《每周轮子之 only-allow：统一规范团队包管理器》</a>。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="程序员应该怎么写博客？"><a href="#程序员应该怎么写博客？" class="headerlink" title="程序员应该怎么写博客？"></a><a href="https://www.v2ex.com/t/851549">程序员应该怎么写博客？</a></h3><p>这是在 V2EX 上看到的一个帖子，OP 是之前周刊有提到过的 <a href="https://hutusi.com/">胡涂说</a> 的博主，在这个帖子中，我收获不少有用的建议，也意外地发现到几个不错的博客。我也想借此机会聊一聊关于这个话题的一些想法，也算是当作我个人写作的总结与反思。</p><p>回顾本站的第一篇文章<a href="/post/d69467be.html">《锐捷无线AP学习笔记 - 入门篇》</a>，写于 2018 年，到现在也就第 4 个年头，相比有些人动不动建站十几年，自然算得上年轻，但我认为我在写博客这件事上有过不少的挣扎与坚持，总结起来一共经历了以下几个阶段，但其实以下阶段并不是层层递进式的，它们有可能会同时进行：</p><ol><li><strong>记录学习笔记</strong>，这个阶段的产出主要是一些较为基础的学习笔记，原创度也较低，属于网上一搜一大把那种，对他人的帮助接近于无，还记得当时把一篇文章分享到技术社区上，被某些暴躁的老哥说我误人子弟，更有甚者直接开怼让我干脆把整本书都抄过来，当时有点气馁，但也承认自己的确是很菜，也曾自我怀疑过是否应该继续往中文社区「倒垃圾」，但最后还是坚持下来了。据我了解很多程序员刚开始写博客都是写这类学习笔记，也有很多人仅仅停留在这个阶段，甚至放弃，实在是太可惜了。</li><li><strong>资源分享类</strong>，写技术文章很难写，有深度的技术文更是难上加上，所以曾有一段时间我特别喜欢写「资源分享」类的文章，譬如<a href="/posts/share-site.html">《分享一些好用的网站》</a>、<a href="/post/549a6198.html">《分享一些好用的 Chrome 扩展》</a>，这类文章写起来压根不费多少时间和经历，你只需要把平时经常使用的网站、工具分享一一罗列出来，，就能在社区上收获不少的点赞收藏，这也是为什么 GitHub 上简体中文项目的 Markdown 项目如此之多的原因，但是我后来意识到，写这类文章对我个人能力的提升并没有多大帮助，如果你知道一些非常有用的工具，你确实应该将它分享出去给更多人，这是非常有价值的，但我的建议是千万不要满足于只写这类文章。</li><li><strong>较有深度的技术文章</strong>，随着工作时间的增长，在技术上有了一些的积累，我开始尝试写一些较有深度的技术文章，包括一些经典面试题讲解、源码阅读、某个知识点深入剖析、一些工具类库的踩坑记录等，写这类文章是最痛苦的，因为你会发现在写的过程突然在某个地方你自己也无法讲清楚，说明你并没有理解透彻，于是只能逼迫自己一边查阅文档、一边根据自己的理解用自己的话把它讲透，这过程中的收获自然也是非常大，对其他人的帮助也不小。</li><li><strong>与技术无关的</strong>，人都是有感情的动物，除了技术以来，总需要聊点其他的东西，有可能是生活上的一些感悟，也有可能是你针对某个事情的看法，这类文章，它既有可能会引起读者的共鸣，也有可能会因为与读者的看法不同而遭到反感，且很多时候，自己也不确定这些看法到底是不是正确的，所以会害怕被别人看到自己不成熟的一面，我也曾有过这方面的顾虑，不敢在博客上公开谈论太多与技术无关的事情，但后来发现是我多虑了，因为这类文章，往往最终的读者只有你自己，因为读者看你的文章，他也只会关心对他有帮助的地方，而且即便你当时所记录下来的自己可能是不成熟的，这也是你成长的印记，比如我常常会在迷茫的时候翻看起之前刚踏入职场时写下的<a href="/posts/why-i-became-a-programmer.html">《我为什么会成为一名程序员》</a>，告诉自己不要忘了为什么会走上技术这条路，所以不要害怕写技术以外的东西，这些稚嫩的文字很有可能会在多年以后一直激励着你。</li></ol><p>可能还有些同学会认为自己文笔不好、词穷，写不了这么多文字，其实也是多虑了，我坦白我的文笔其实很差，不能像别人那样出口成章、行云流水，但其实你只要把意思表达清楚、并且注入你的感情即可，总之多写、坚持写。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="QOTD-协议"><a href="#QOTD-协议" class="headerlink" title="QOTD 协议"></a><a href="https://en.wikipedia.org/wiki/QOTD">QOTD 协议</a></h3><p>QOTD 的全程是 <strong>Quote of the Day</strong>，翻译过来就是「每日报价」，在 <a href="https://datatracker.ietf.org/doc/html/rfc865">RFC 865</a> 中定义，监听的端口是 17，这是一个非常少用到的协议，目前仅剩的公共 QOTD 服务器只有几个：</p><table><thead><tr><th>服务器地址</th><th>TCP 端口</th><th>UDP 端口</th></tr></thead><tbody><tr><td>djxmmx.net</td><td>17</td><td>17</td></tr><tr><td>alpha.mike-r.com</td><td>17</td><td>17</td></tr><tr><td>cygnus-x.net</td><td>17</td><td>17</td></tr></tbody></table><p>可以用它做什么呢？</p><p>比如<a href="https://github.com/daya0576/daya0576">这里</a>就有一个在 GitHub Action 上利用该协议定时获取 djxmmx.net 服务器上的名人名言，将它更新到 Github Profile 中。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="Bash-Pitfalls-编程易犯的错误"><a href="#Bash-Pitfalls-编程易犯的错误" class="headerlink" title="Bash Pitfalls: 编程易犯的错误"></a><a href="https://kodango.com/bash-pitfalls-part-1">Bash Pitfalls: 编程易犯的错误</a></h3><p>本文是<a href="http://mywiki.wooledge.org/BashPitfalls">《Bash Pitfalls》</a>的中文翻译版，介绍了40多条日常 Bash 编程中，老手和新手都容易忽略的错误编程习惯。作者会在每条给出错误的范例上，详细分析与解释错误的原因，同时给出正确的改写建议。</p><h3 id="Docker-镜像构建的一些技巧"><a href="#Docker-镜像构建的一些技巧" class="headerlink" title="Docker 镜像构建的一些技巧"></a><a href="https://www.kawabangga.com/posts/4676">Docker 镜像构建的一些技巧</a></h3><p>本文分享几个 Docker 镜像构建的一些技巧，可以帮助你提高 Docker 镜像构建的效率，对于老手来说已经是非常基本的事情了，但是对于新手还是很有帮助的。</p><p>原文一共举例了 4 个技巧，在此我只详细讲解第一个技巧，其余的麻烦移步<a href="https://www.kawabangga.com/posts/4676">原文</a>查看。</p><ol><li>删除缓存</li></ol><p>使用 apt、pip 等包管理器下载包时一般都会产生缓存，以便后续下载时使用，但是在 Docker Image 中，我们不需要这些缓存，所以一般都会在下载后，手动清除缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN dnf install -y --setopt=tsflags=nodocs \</span><br><span class="line">    httpd vim &amp;&amp; \</span><br><span class="line">    systemctl enable httpd &amp;&amp; \</span><br><span class="line">    dnf clean all</span><br></pre></td></tr></table></figure><p>要切记千万不要像这样分开写，因为 Dockerfile 里面的每一个 <code>RUN</code> 都会创建一层新的 layer，这样其实是创建了 3 层 layer，前 2 层带来了缓存，第三层删除了缓存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM fedora</span><br><span class="line">RUN dnf install -y mariadb</span><br><span class="line">RUN dnf install -y wordpress</span><br><span class="line">RUN dnf clean all</span><br></pre></td></tr></table></figure><p>但其实 Docker 在 <a href="https://www.docker.com/blog/whats-new-in-docker-1-13/">v1.13</a> 中引入了 <em>–squash</em> 参数，可以在完成构建后将所有的 layers <strong>压缩成一个 layer</strong>，也就是说，最终构建出来的 Docker image 只有一层，所以，如上在多个 <code>RUN</code> 中写 clean 命令，其实也可以。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --squash</span><br></pre></td></tr></table></figure><ol start="2"><li>改动不频繁的内容往前放</li><li>构建和运行 Image 分离</li><li>检查构建产物</li></ol><h3 id="JavaScript-函数式组合：有什么大不了的？"><a href="#JavaScript-函数式组合：有什么大不了的？" class="headerlink" title="JavaScript 函数式组合：有什么大不了的？"></a><a href="https://jrsinclair.com/articles/2022/javascript-function-composition-whats-the-big-deal/">JavaScript 函数式组合：有什么大不了的？</a></h3><p>这是我看到过所有写 JavaScript 函数式组合里面最通俗易懂的一篇文章，作者从头开始一步步地实现 compose、pipe、flow 等方法，并且让对函数式组合了解不多的同学知道，函数式组合的好处在哪？</p><p>举个例子，假如我们使用 Array 的方法是这样写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comments = commentStrs</span><br><span class="line">    .filter(noNazi)</span><br><span class="line">    .slice(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">    .map(emphasize)</span><br><span class="line">    .map(itemize)</span><br><span class="line">    .join(<span class="string">&#x27;\n&#x27;</span>);</span><br></pre></td></tr></table></figure><p>而改用函数式组合的方式，则是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comments = pipe(commentStrs,</span><br><span class="line">    filter(noNazi),</span><br><span class="line">    take(<span class="number">10</span>),</span><br><span class="line">    map(emphasize),</span><br><span class="line">    map(itemize),</span><br><span class="line">    join(<span class="string">&#x27;\n&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>这样写的好处在哪呢？</p><p>首先，我们可以增加任何 Array 原型上没有的自定义方法：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const comments = pipe(commentStrs,</span><br><span class="line">    filter(noNazi),</span><br><span class="line">    take(10),</span><br><span class="line">    map(emphasize),</span><br><span class="line">    map(itemize),</span><br><span class="line">    join(&#x27;\n&#x27;),</span><br><span class="line"><span class="addition">+   chaoticListify,</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>另外，我们可以自由地实现像 map 这些方法，比如用生成器的方式改成它，而无需改变调用它们的方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="function"><span class="params">f</span> =&gt;</span> <span class="function"><span class="keyword">function</span>*(<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> iterable) <span class="keyword">yield</span> f(x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> join = <span class="function"><span class="params">s</span> =&gt;</span> <span class="function"><span class="params">iterable</span> =&gt;</span> [...iterable].join(s);</span><br></pre></td></tr></table></figure><p>综上所述，使用函数式组合的方式编写代码可以让我们写出更加简洁、优雅的代码，更重要的是它给我们提供了另一种思考的方式。</p><h3 id="中国黑客关系图"><a href="#中国黑客关系图" class="headerlink" title="中国黑客关系图"></a><a href="https://mp.weixin.qq.com/s/gowGNyJ_MaP6meQDQlSSZw">中国黑客关系图</a></h3><p>本文是新书《沸腾信安志》的一篇预热文章，主要讲述了中国上个世纪末到本世纪初的传奇黑客们的故事，想要了解有哪些著名的黑客，以及他们今何在的同学可以看看。</p><blockquote><p>网络安全行业和武侠江湖是很像的，有门派组织，有江湖名号，有武林大会，有绝计和宝物，而且都是大侠少而恶盗多，甚至连朝廷的管制方式都很相似。</p><p>这种氛围里，竟然出了这样一群奇人。</p><p>他们在最艰苦的岁月里，只要把道德底线稍微降低一点，就可以衣食无忧，然而他们没有；</p><p>他们掌握着最高超的技术，却拿着流量行业一半甚至更低的薪水，只要稍微做点灰产，就能摆脱困境，然而他们没有；</p><p>他们忍受着社会的质疑，承担着行业流氓带来的负面，却仍然坚持着自己热爱的技术创新。</p><p>直到现在，他们终于等到了自己的时代。</p></blockquote><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://github.com/zonemeen/musicn">zonemeen/musicn</a>：🎵 一个下载高质量音乐的命令行工具</li></ul><ul><li><a href="https://www.similarweb.com/zh/">Similarweb</a>：查看并分析任何网站流量，站长必备工具</li></ul><ul><li><a href="https://codeit.codes/">Codeit</a>：手机连接 Git 查看代码的神器 APP</li></ul><ul><li><a href="https://www.queue.so/">Queue</a>：使用 Notion 发布 Twitter 的工具</li></ul><ul><li><a href="https://coverview.vercel.app/">Coverview</a>：生成文章题图的工具</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本周轮子&quot;&gt;&lt;a href=&quot;#本周轮子&quot; class=&quot;headerlink&quot; title=&quot;本周轮子&quot;&gt;&lt;/a&gt;本周轮子&lt;/h2&gt;&lt;p&gt;以前看过一个小册子 &lt;a href=&quot;https://github.yanhaixiang.com/make-wheels/</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>每周轮子之 only-allow：统一规范团队包管理器</title>
    <link href="https://4ark.me/post/weekly-npm-packages-01.html"/>
    <id>https://4ark.me/post/weekly-npm-packages-01.html</id>
    <published>2022-05-16T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>首先我们来提一个团队开发中很常见的需求：一般来说每个团队都会统一规定项目内只使用同一个包管理器，譬如 npm、yarn、pnpm 等，如果成员使用了不同的包管理器，则可能会因为 <em>lock file</em> 失效而导致项目无法正常运行，虽然这种情况一般都可以通过项目的上手文档来形容共识，但有没有更好的解决方案，比如在项目安装依赖时检测如果使用了不同的包管理器就抛出错误信息？</p><p>当然是可以的，pnpm 就有一个包叫做 <a href="https://www.npmjs.com/package/only-allow">only-allow</a> ，连 <a href="https://github.com/vitejs/vite/blob/c7fc1d4a532eae7b519bd70c6eba701e23b0635a/package.json#L16">vite</a> 都在使用它，所以本周我们就从 0 到 1 实现这个工具，以此对它的工作原理一探究竟。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>说干就干，我们先在 <a href="https://docs.npmjs.com/cli/v8/using-npm/scripts#life-cycle-operation-order">npm 文档</a> 搜寻一番，发现有一个钩子叫做 <code>preinstall</code>：</p><blockquote><p>可以在运行 npm instal 之前执行某个命令，当 exit code 非 0 时终止运行</p></blockquote><p>所以第一步是在 <code>package.json</code> 中添加以下代码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;node check-npm.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的问题就是：我们如何知道用户使用了哪一个包管理器？</p><p>我们知道 <code>process.env</code> 会包含当前脚本的运行环境，首先我们将它打印看看</p><p>分别使用 <code>yarn</code> 和 <code>npm install</code> 后，发现了以下几个相关字段的区别：</p><p>使用 <code>yarn</code> 安装：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  npm_config_registry: &#x27;https:<span class="comment">//registry.yarnpkg.com&#x27;,</span></span><br><span class="line">  npm_execpath: &#x27;/usr/local/lib/node_modules/yarn/bin/yarn.js&#x27;,</span><br><span class="line">  npm_config_user_agent: &#x27;yarn/<span class="number">1.22</span><span class="number">.11</span> npm/? node/v16<span class="number">.13</span><span class="number">.2</span> darwin arm64&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>npm</code> 安装：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  npm_config_metrics_registry: &#x27;https:<span class="comment">//registry.npmjs.org/&#x27;,</span></span><br><span class="line">  npm_execpath: &#x27;/opt/homebrew/lib/node_modules/npm/bin/npm-cli.js&#x27;,</span><br><span class="line">  npm_config_user_agent: &#x27;npm/<span class="number">8.5</span><span class="number">.5</span> node/v16<span class="number">.13</span><span class="number">.2</span> darwin arm64 workspaces/<span class="literal">false</span>&#x27;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是三者的解释：</p><ol><li>npm_config_metrics_registry：npm 源，就是当我们安装 npm 包会从这个服务器上获取，可以通过 <code>npm config set registry</code> 或者     等工具进行配置。</li><li>npm_execpath：当前 npm 包管理器的执行目录，这个路径会根据你安装的方式而不同。</li><li>npm_config_user_agent：由包管理器设置的 UA，每个包管理器都不一样，比如 npm  <a href="https://github.com/npm/cli/blob/8a49e3ab6499c6196c5d7a0f6dad3b345944b992/lib/utils/config/definitions.js#L2190">lib/utils/config/definitions.js#L2190</a>，因此我们可以使用这个信息来判断客户端。</li></ol><p>因此我们可以通过 <code>process.env.npm_config_user_agent</code> 获取当前用户使用的包管理器，那么接下来的工作很简单了。</p><p>我们先写一个最 Low 的解决方案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wantedPM = <span class="string">&#x27;yarn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usedPM = process.env.npm_config_user_agent.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usedPM !== wantedPM) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`You are using <span class="subst">$&#123;usedPM&#125;</span> but wanted <span class="subst">$&#123;wantedPM&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们的核心功能就已经实现了，还不赶紧发到 GitHub 开源一波坐等 stars？</p><p>别急，我们来思考下这段代码存在哪些不足：</p><ol><li>应该由用户指定可以使用哪一个包管理器。</li><li>这段代码的健壮性如何？</li></ol><p>那我们再修改一波，首先是接收用户传递参数，指定使用的包管理器：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;preinstall&quot;</span>: <span class="string">&quot;node check-npm.js yarn&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后改为通过接收参数：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ const argv = process.argv.slice(2)</span></span><br><span class="line"></span><br><span class="line"><span class="addition">+ const wantedPM = argv[0]</span></span><br><span class="line"><span class="deletion">- const wantedPM = &#x27;yarn&#x27;</span></span><br><span class="line"></span><br><span class="line">const usedPM = process.env.npm_config_user_agent.split(&#x27;/&#x27;)[0]</span><br><span class="line"></span><br><span class="line">if (usedPM !== wantedPM) &#123;</span><br><span class="line">  console.error(`You are using $&#123;usedPM&#125; but wanted $&#123;wantedPM&#125;`)</span><br><span class="line"></span><br><span class="line">  process.exit(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有第二个问题，这段代码的健壮性如何？譬如以下情况：</p><ol><li>用户不传或乱传参数怎么办？</li><li>如果以后有新需求：除了要限制包管理器，还要限制到具体某个版本怎么办？</li></ol><p>所以，我们再调整一波代码，检测传入的参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PACKAGE_MANAGER_LIST = [<span class="string">&#x27;npm&#x27;</span>, <span class="string">&#x27;yarn&#x27;</span>, <span class="string">&#x27;pnpm&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argv = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argv.length === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Please specify the wanted package manager: only-allow &lt;<span class="subst">$&#123;name&#125;</span>&gt;`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wantedPM = argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PACKAGE_MANAGER_LIST.includes(wantedPM)) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`&quot;<span class="subst">$&#123;wantedPM&#125;</span>&quot; is not a valid package manager. Available package managers are: <span class="subst">$&#123;name&#125;</span>.`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们将获取 UA 的代码抽离出来，并使其可以获取版本，以便后续扩展：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPackageManagerByUserAgent</span>(<span class="params">userAgent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!userAgent) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`&#x27;userAgent&#x27; arguments required`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> spec = userAgent.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> [name, version] = spec.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    version</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PACKAGE_MANAGER_LIST = [<span class="string">&#x27;npm&#x27;</span>, <span class="string">&#x27;yarn&#x27;</span>, <span class="string">&#x27;pnpm&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argv = process.argv.slice(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argv.length === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Please specify the wanted package manager: only-allow &lt;<span class="subst">$&#123;name&#125;</span>&gt;`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wantedPM = argv[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!PACKAGE_MANAGER_LIST.includes(wantedPM)) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = PACKAGE_MANAGER_LIST.join(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`&quot;<span class="subst">$&#123;wantedPM&#125;</span>&quot; is not a valid package manager. Available package managers are: <span class="subst">$&#123;name&#125;</span>.`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> usedPM = getPackageManagerByUserAgent(</span><br><span class="line">  process.env.npm_config_user_agent</span><br><span class="line">).name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usedPM !== wantedPM) &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">`You are using <span class="subst">$&#123;usedPM&#125;</span> but wanted <span class="subst">$&#123;wantedPM&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  process.exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPackageManagerByUserAgent</span>(<span class="params">userAgent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!userAgent) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`&#x27;userAgent&#x27; arguments required`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> spec = userAgent.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [name, version] = spec.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    version</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>很好，现在我们已经将这个 npm 包的功能给实现了：<a href="https://www.npmjs.com/package/only-allow">only-allow</a>，可以看下它的源码：<a href="https://github.com/pnpm/only-allow/blob/master/bin.js">bin.js</a>。</p><p><strong>不过发现了一个问题：</strong>上面提到过 <code>preinstall</code>  钩子会在安装依赖时触发，但是经验证，npm 和 yarn 调用 <code>preinstall</code> 的时机不一样，npm 仅会在 <code>npm install</code> 时运行，而 <code>npm install &lt;pkg-name&gt;</code> 则不会，但 yarn 则会在 <code>yarn</code> 和 <code>yarn add &lt;pkg-name&gt;</code> 时都运行，所以如果想用这种方式限制 npm 使用者，可能无法达到预期，该问题在 2021 年<a href="https://github.com/npm/rfcs/issues/325">就有人提出</a>，但目前仍未有解决方案出现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;首先我们来提一个团队开发中很常见的需求：一般来说每个团队都会统一规定项目内只使用同一个包管理器，譬如 npm、yarn、pnpm 等，如果成</summary>
      
    
    
    
    
    <category term="每周轮子" scheme="https://4ark.me/tags/%E6%AF%8F%E5%91%A8%E8%BD%AE%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>周刊第11期：扩大你的运气表面积（Luck Surface Area）</title>
    <link href="https://4ark.me/post/weekly-11.html"/>
    <id>https://4ark.me/post/weekly-11.html</id>
    <published>2022-05-05T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扩大你的运气表面积"><a href="#扩大你的运气表面积" class="headerlink" title="扩大你的运气表面积"></a>扩大你的运气表面积</h2><p>想说两件事，第一件事，在上周的某天下午，我收到了一封邮件：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204282317575.png" alt="image-20220428231741858"></p><p>这是 V2EX 上的一位老哥发来的邮件，他也在写周刊<a href="http://weekly.codelc.com/">《野生架构师》</a>，估计不少人都听过，毕竟最近在 V2EX 上比较活跃，收到这封来信让我非常开心，毕竟自己的周刊内容得到了他人的认可。</p><p>同时也让我知道了一个新的概念：运气表面积（Luck Surface Area）。</p><p>这个概念该如何理解，根据<a href="https://www.codusoperandi.com/posts/increasing-your-luck-surface-area">《How to Increase Your Luck Surface Area》</a>的描述：</p><blockquote><p>在你的生活中发生意外的数量，就是你的运气表面积，它与你所热爱的事情、以及被有效沟通的人数是成正比的，换句话说，你的运气是你自己创造的。</p></blockquote><p>它的公式是：<strong>运气表面积 = 你采取的行动 [X] x 你沟通的人数 [X]</strong> 。</p><p>运气表面积的工作原理是这样的，当你投入精力去做某件事情，你分享出去，你就会产生价值，但很多时候，这个价值会被所影响的人放大，它有可能会以某种你未曾预料的方式回报你，比如招聘你、投资你，但无论以何种方式发生，它都是偶然的。</p><p>说回上面那封邮件，我之所以写周刊在<a href="https://4ark.me/post/weekly-idea.html">《我为什么要写周刊》</a> 中有提到，我希望我能够对我每周所阅读的文章做一份总结，以此巩固我自身的理解，并希望不时输出自己观点的同时也能够帮助到其他人。</p><p>正因为我写周刊，被这位老哥看到了，发来这么一封邮件，让我感受到了被认可的快乐，因此更加坚定了我继续写周刊的信心，这就是我的运气表面积在扩大，但这一切都是非常偶然的，我在做这件事情的时候，我没有预料到这一点，所以正是因为我做这件事情为我自己创造了运气。</p><p>另外一件让我感到运气表面积在扩大的事，在一直订阅的<a href="https://hutusi.com/">胡涂说</a>的周刊<a href="https://hutusi.com/articles/weekly-13">《No.13: 周刊的周刊》</a>发现了他推荐我的周刊，而他的原话是：</p><blockquote><p>看到很多博主在写周刊，我想还是把这一传统给拾起来。</p></blockquote><p>这让我想到了一件非常奇妙的事情，前段时间 V2EX 上有讨论 <a href="https://v2ex.com/t/842511">为什么忽然间大家都开始做周刊了</a>，但我坦承我不是在跟风，或许别人也是如此，那么有没有可能是因为某一个人持续地在做这件事，影响了很多人，然后大家又互相影响，无形中扩大了大家的运气表面积，如果真是这样，那我认为是阮一峰影响了我，而我也可能在影响其他人。</p><p>最后从<a href="https://dimzou.feat.com/zh-CN/draft/580665/585314">这里</a>摘录一下以下三者的不同：</p><ol><li><strong>幸运</strong>是发生在你身上的事情，生在好人家是福，被雷劈是祸。</li><li><strong>机会</strong>需要您采取行动。您需要抓住机会，例如购买彩票，或约某人出去约会，以从偶然事件中受益。</li><li><strong>运气</strong>是成功或失败<em>显然</em>是偶然造成的。看起来这是一个机会，因为我们很少看到在成功或失败之前发生的一切。运气是通过发现和创造机会来实现的。这是你行为的直接后果。</li></ol><p>所以，记住一件事情，<strong>你可以创造你的运气，只要你去做更多的事情影响别人</strong>。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="POSSE-和-Mastodon"><a href="#POSSE-和-Mastodon" class="headerlink" title="POSSE 和 Mastodon"></a>POSSE 和 Mastodon</h3><p>POSSE 的全称是 Publish (on your) Own Site, Syndicate Elsewhere，意为「在你自己的网站上发布，在其他地方联合」。</p><p>这是 2010 年首次在<a href="https://steveivy.gitlab.io/tantek-celik-diso-20-brass-tacks.html">《Tantek Celik Diso 20 Brass Tacks》</a> 提出的一种联合模型方案：</p><blockquote><p>在你自己的网站上发布，拥有自己的 URL 和永久链接，并通过其他社交媒体、社区中公布该链接。</p></blockquote><p>可以通过这段短片<a href="https://www.youtube.com/watch?v=X3SrZuH00GQ&t=835s">《Own your content on Social Media using the IndieWeb》</a>快速了解 POSSE。</p><p>采用该模型的好处是：如果我的 Twitter 帐户被删除（被官方或我自己删除），我不会丢失任何重要内容。</p><p>其实已经不少人采用这个方案，譬如就不少博主都会将文章链接发到 Twitter、Telegram 频道上，一方面是起到推广的作用，另一方面正是因为 POSSE。</p><p>你也可以通过这个链接<a href="https://indieweb.org/POSSE">《POSSE - IndieWeb》</a> 了解更多信息。</p><p>之所以越来越多人采用这个方案，都是因为对官方的不信任，所以希望把数据掌握在自己的手中，所以这里简单介绍一下 Mastodon：</p><blockquote><p>Mastodon 是互联网上最大的去中心化的社交网络，它由一个非营利组织基于开放网络标准建立。</p></blockquote><p>简单来说就是一个自托管的类 Twitter、微博的网站，你可以构建并部署自己的 Mastodon 实例，也可以加入他人的实例，顺便一提之前川普搞的社交媒体的 <a href="https://en.wikipedia.org/wiki/Truth_Social">Truth Social</a> 也是基于 Mastodon 的。</p><p>但 Mastodon 也有它的不足之处，譬如：</p><ol><li>稳定性，毕竟只有少部分人在维护实例。</li><li>还没有一个好的策略去防止虚假信息，仇恨言论，骚扰等。</li></ol><p>但也有不少人开始尝试从 Twitter 转向 Mastodon，比如 <a href="https://2ality.com/index.html">2ality</a> 的博主 <a href="https://fosstodon.org/@rauschma">Axel Rauschmayer</a>，有兴趣的同学可以从 <a href="https://fosstodon.org/explore">Explore Fosstodon</a>  开始探索。</p><h3 id="造谣的成本有多低？"><a href="#造谣的成本有多低？" class="headerlink" title="造谣的成本有多低？"></a>造谣的成本有多低？</h3><p>在如今的网络，造谣的成本非常低，比如我们就可以通过 <a href="https://fakedetail.com/">Fake Details</a> 这个网站去伪造各式各样的假信息，可以伪造下面这些社交媒体的假截图：</p><ul><li>Twitter 推文</li><li>Tiktok</li><li>Youtube</li><li>等等…</li></ul><p>甚至只需要在某个完全不相关的视频上面截个图，就可以张冠李戴地套在另外一件时事上面，而我们该如何去辨别这些假信息呢？</p><p>在<a href="https://4ark.me/post/weekly-04.html">《周刊第4期：独立思考》</a> 曾推荐过几个比较可靠的事实核查网站，这里再贴一下：</p><ul><li><a href="https://chinafactcheck.com/">有据</a></li><li><a href="https://tfc-taiwan.org.tw/">台湾事实核查中心</a></li><li><a href="https://www.politifact.com/">PolitiFact</a></li><li><a href="https://www.truthorfiction.com/">Truth or Fiction</a></li><li><a href="https://www.factcheck.org/">FactCheck.org</a></li><li><a href="https://factcheck.afp.com/">Fact Check</a></li></ul><p>除了看以上这些网站给出的结论，我们还可以通过这些网站提供的<a href="https://tfc-taiwan.org.tw/topic/4112">核查工具箱</a>，自己去学习如何做事实核查。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="Chrome-用户体验报告比较工具"><a href="#Chrome-用户体验报告比较工具" class="headerlink" title="Chrome 用户体验报告比较工具"></a><a href="https://crux.zaps.dev/">Chrome 用户体验报告比较工具</a></h3><p>你只需要在 Chrome UX Report Compare Tool 这个网站上输入一个或多个 URL，它将会列出它们的各项性能指标，如下图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202205052214723.png" alt="image-20220505221453130"></p><p>然而当我输入本 Blog 的域名时，它提示我：Chrome 用户体验报告中没有足够的数据，这是访问人数不够多的缘故。</p><p>如果想要了解背后的技术细节，可以看这篇文章<a href="https://web.dev/chrome-ux-report-api/">《使用 Chrome 用户体验报告 API》</a>。</p><h3 id="使用-Javascript-的可选操作符可能会破坏你的代码"><a href="#使用-Javascript-的可选操作符可能会破坏你的代码" class="headerlink" title="使用 Javascript 的可选操作符可能会破坏你的代码"></a><a href="https://p42.ai/blog/2022-05-04/javascript-refactoring-gotchas-5-ways-converting-to-optional-chaining-can-break-your-code">使用 Javascript 的可选操作符可能会破坏你的代码</a></h3><p>熟悉 JS 的同学都知道我们可以通过 <code>obj?.x</code> 这个语法来更安全地访问对象属性等，但是如果盲目地使用这个语法，可能会导致一些意想不到的事情发生，比如以下例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;value &amp;&amp; value.length&#125;</span>, <span class="subst">$&#123;value?.length&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="literal">undefined</span>);       <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="literal">null</span>);            <span class="comment">// null, undefined</span></span><br><span class="line">test(<span class="literal">true</span>);            <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="literal">false</span>);           <span class="comment">// false, undefined</span></span><br><span class="line">test(<span class="number">1</span>);               <span class="comment">// undefined, undefined</span></span><br><span class="line">test(<span class="number">0</span>);               <span class="comment">// 0, undefined</span></span><br><span class="line">test(&#123;&#125;);              <span class="comment">// undefined, undefined</span></span><br><span class="line">test([]);              <span class="comment">// 0, 0</span></span><br><span class="line">test(&#123; <span class="attr">length</span>: <span class="string">&quot;a&quot;</span> &#125;); <span class="comment">// a, a</span></span><br><span class="line">test(<span class="string">&#x27;&#x27;</span>);              <span class="comment">// , 0</span></span><br><span class="line">test(<span class="literal">NaN</span>);             <span class="comment">// NaN, undefined</span></span><br></pre></td></tr></table></figure><p>通过这个例子我们发现，仅当值为 undefined 的时候，Optional Chaining 才有可能按照预期运行，所以我们编写代码的时候一定要多加注意，什么时候应该用 &amp;&amp; 做短路判断，什么时候使用 Optional Chaining 语法。</p><h3 id="在-git-仓库中使用-find-exec-sed-是很危险的"><a href="#在-git-仓库中使用-find-exec-sed-是很危险的" class="headerlink" title="在 git 仓库中使用 find . -exec sed 是很危险的"></a><a href="https://cmdcolin.github.io/posts/2022-05-04-findseddangerous">在 git 仓库中使用 find . -exec sed 是很危险的</a></h3><p>如果你想在 git 存储库中全局替换某个字符，那么你很有可能会遇到这个问题：<a href="https://stackoverflow.com/questions/6758963/find-and-replace-with-sed-in-directory-and-sub-directories">Find and replace with sed in directory and sub directories</a>，这是因为 find 命令没有忽略 .git 目录，运行该命令可能会导致 .git 目录损坏，所以更好的方式是使用 git ls-files：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git ls-files | xargs sed -i -e <span class="string">&#x27;s/apple/orange/g&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="凯文-·-凯利-70-岁生日写的-103-条人生忠告"><a href="#凯文-·-凯利-70-岁生日写的-103-条人生忠告" class="headerlink" title="凯文 · 凯利 70 岁生日写的 103 条人生忠告"></a><a href="https://justinyan.me/post/4911">凯文 · 凯利 70 岁生日写的 103 条人生忠告</a></h3><p>2022年4月28日，凯文·凯利（Kevin Kelly）在他的网站上发布了 70 岁生日的文章：<a href="https://kk.org/thetechnium/103-bits-of-advice-i-wish-i-had-known/">103 Bits of Advice I Wish I Had Known</a>，意为：103 条我希望早点知道的人生忠告。</p><p>此为中译版，非常推荐阅读，在这里摘录我个人认为有启发的几句：</p><ol><li>99%的时间里，真正关键的时刻就是此刻。</li><li>除了你以外，没有人会真的记得你拥有什么东西。</li><li>“但是”之前的话都是废话。</li><li>当你原谅其他人的时候，他们不一定会知道这件事，但你自己却会被治愈。原谅不是我们给予他人的东西；而是我们给自己的礼物。</li><li>教育的一半作用是学习哪些东西可以被忽略。</li><li>不要相信你认为你相信的一切。</li><li>为了丰厚的回报，请对你完全不感兴趣的事物保持好奇。</li><li>重复别人是一个很好的开始。重复你自己则是一个令人失望的终点。</li><li>如果你对于一个主题的意见可以根据你另一个主题的意见预测得出，那你可能陷入了某种意识形态的掌控。如果你认真审视你自己的意识，你的结论其实是无法预测的。</li></ol><h3 id="质疑和信任"><a href="#质疑和信任" class="headerlink" title="质疑和信任"></a><a href="https://adactio.com/journal/19021">质疑和信任</a></h3><p>这是 Jeremy 两篇文章，主要讨论了本文作者发现的一个奇怪现象，Web 开发者普遍存在这样一种心态：他们会在项目中优先选择安装 npm 依赖，然后隐式地引入了更多的依赖，也就相当于完全地信任这些 npm 包以及它们的作者。</p><p>但作者认为更应该直接使用浏览器的原生特性，比如 HTML 元素、CSS 功能和 JavaScript API，虽然它们并不总是完美的，并且在开发过程中需要额外花费很多心思，但原生的特性更值得被信赖。</p><p>而关于这个话题的讨论将由此展开，有些人认为之所以普遍存在这样一种心态，是因为浏览器兼容性的缘故，譬如在 MDN 的 <a href="https://insights.developer.mozilla.org/reports/mdn-web-developer-needs-assessment-2019.html#needs-assessment-segmented-view-of-the-needs-ranking">Overall Needs Ranking</a> 中排名前 5 的需求有 4 个属于兼容性问题，以前的 jQuery 和 Bootstrap 就是在这样的需求下产生，而现在这种情况已经逐步得到改善，越来越多人开始倾向于使用浏览器原生特性，而不是借助第三方库，总得来说，Web 开发者对浏览器的信任正在恢复。</p><p>最后提出了一个设计原则：如果可用，请默认使用浏览器原生功能，而不是第三方库。</p><h3 id="使用-Rust-开发单页应用程序"><a href="#使用-Rust-开发单页应用程序" class="headerlink" title="使用 Rust 开发单页应用程序"></a><a href="https://www.sheshbabu.com/posts/rust-wasm-yew-single-page-application/">使用 Rust 开发单页应用程序</a></h3><p>这是一篇使用 Rust 和  <a href="https://yew.rs/">Yew</a>  从 0 到 1 开发单页应用的文章，对于想要学习 Rust 和 Wasm 的同学可以看看。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://exercism.org/">Exercism</a>：一个学习编程语言的网站，非常有用。</li></ul><ul><li><a href="https://kill-the-newsletter.com/">Kill the Newsletter</a>：可将通过邮件订阅的 newsletters 转换为 RSS 源。</li></ul><ul><li><a href="https://wantwords.net/">汉语反向词典</a>：输入描述或词语，找到更多相似词语，帮助词穷的人更好地写作。</li></ul><ul><li><a href="https://ludwig.guru/">Ludwig</a>：和上面的差不多，不过是针对英文的。</li></ul><ul><li><a href="https://www.youtube.com/watch?v=0eKVizvYSUQ">How Google Search Works</a>：一段介绍 Google 搜索如何工作的五分钟短片。</li></ul><ul><li><a href="https://notefolio.net/">notefolio</a>：一个韩国的 UI 设计网站。</li></ul><ul><li><a href="https://natto.dev/">natto</a>：一个在线画 2D canvas 的工具。</li></ul><ul><li><a href="https://jimmysong.io/eng-practices/">谷歌工程实践</a>：顾名思义，Google 的通用工程实践，几乎涵盖所有语言和项目，内含 Code Review 以及代码编写指南。</li></ul><ul><li><a href="https://workers.cloudflare.com/">Cloudflare Workers</a>：Cloudflare 的云函数产品。</li></ul><ul><li><a href="https://github.com/StepfenShawn/Cantonese">Cantonese</a>：一个高中生写的粤语编程语言。</li></ul><ul><li><a href="https://github.com/mattpocock/ts-error-translator">TypeScript Error Translator</a>：将 TypeScript 错误翻译成英语，提供 VSCode 扩展。</li></ul><ul><li><a href="https://github.com/adriancooney/puppeteer-heap-snapshot">puppeteer-heap-snapshot</a>：一个用来获取和查询 Chome DevTools 堆快照的 CLI 工具。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;扩大你的运气表面积&quot;&gt;&lt;a href=&quot;#扩大你的运气表面积&quot; class=&quot;headerlink&quot; title=&quot;扩大你的运气表面积&quot;&gt;&lt;/a&gt;扩大你的运气表面积&lt;/h2&gt;&lt;p&gt;想说两件事，第一件事，在上周的某天下午，我收到了一封邮件：&lt;/p&gt;
&lt;p&gt;&lt;img </summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>周刊第10期：你如何在网上找到可靠的信息？</title>
    <link href="https://4ark.me/post/weekly-10.html"/>
    <id>https://4ark.me/post/weekly-10.html</id>
    <published>2022-04-26T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="Git-2-36-亮点"><a href="#Git-2-36-亮点" class="headerlink" title="Git 2.36 亮点"></a><a href="https://github.blog/2022-04-18-highlights-from-git-2-36/">Git 2.36 亮点</a></h3><p>4 月 18 日，Git 正式发布 <a href="https://lore.kernel.org/git/xmqqh76qz791.fsf@gitster.g/T/#u">2.36 版本</a>，其中包含 96 个贡献者的改动，其中有 26 个新特性，在此罗列一些笔者比较感兴趣的新特性：</p><ol><li>git log –remerge-diff，更好地显示合并提交的差异，在此之前，如果我们查看一个具有合并冲突的提交差异时，输入的结果往往很难理解，而现在使用 <code>--remerge-diff</code> 则可以用 <a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt-mergeconflictStyle">mergeconflictStyle</a> 的样式显示差异。</li><li>更严格的存储库权限检查，在 2.35 版本时，出现了<a href="https://github.blog/2022-04-12-git-security-vulnerability-announced/">两个安全漏洞</a>，此漏洞会影响在多用户计算机上工作的用户，这可能会导致某个用户在其他用户的存储库上执行任意命令，在 Git <a href="https://lore.kernel.org/git/xmqqv8veb5i6.fsf@gitster.g/">2.35.2</a> 版本中发布了安全补丁，总得来说就是 Git 更改了默认行为，防止这种情况的发生，我们也可以通过最新的 <a href="https://git-scm.com/docs/git-config/#Documentation/git-config.txt-safedirectory">safe.directory</a> 配置来有意义地绕过这个行为。</li><li>我们都知道 git bisect 这个命令可以用于二分查找，快速定位引入 BUG 的提交，同时它也可以通过指定一个可执行脚本来自动化这个过程，<code>git bisect run test.sh</code>，但在此之前，Git 并没有检查指定的文件是否为可执行脚本，导致 bisect 运行出错，该问题现在得到修复。</li><li>还有很多，感兴趣自行了解。</li></ol><h3 id="问HN：你如何在网上找到可靠的信息？"><a href="#问HN：你如何在网上找到可靠的信息？" class="headerlink" title="问HN：你如何在网上找到可靠的信息？"></a><a href="https://news.ycombinator.com/item?id=31107699">问HN：你如何在网上找到可靠的信息？</a></h3><p>在 hacker news 上看到的一个帖子，在信息爆炸的时代，我们如何在网上找到可靠的信息？总结出了一些自认为有用的观点：</p><ol><li>在信息源寻找「信息」，而不是「观点」，我们根据这些「信息」，得到我们自己的「观点」，同时以开放的心态去验证自己的「观点」，留意那些与你不同观点的人。</li><li>永远不要相信单一的信息来源，譬如不要只看国内的媒体：）</li><li>摆脱信息茧房，学习使用 RSS 订阅你感兴趣的内容，但是如何寻找有用的信息源也是一大难题。</li><li>尝试使用英文搜索你的问题，如果 Google 不好用，可以试试 <a href="https://teclis.com/">Teclis</a>。</li></ol><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="JavaScript-根据背景色显示对应的文字颜色"><a href="#JavaScript-根据背景色显示对应的文字颜色" class="headerlink" title="JavaScript 根据背景色显示对应的文字颜色"></a>JavaScript 根据背景色显示对应的文字颜色</h3><p>在 2022 的今天，dark 模式已经成为任何一个关注用户体验的应用不可或缺的功能，其中有一个很常见的需求就是根据背景颜色决定对应的文字颜色，这里就简单讲述一下我的实现思考。</p><p>首先我们需要知道任何颜色都有对应的灰度值的，得到颜色对应的灰度以后，就能知道该颜色是属于偏亮还是偏暗。</p><p>而获取灰度值的公式为：(0.299 * <em>r</em> + 0.587 * <em>g</em> + 0.114 * <em>b</em>) / 255</p><p>下面我们简单测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从 rgb 获取灰度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGrayLevelFromRgb</span>(<span class="params">[r, g, b]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0.299</span> * r + <span class="number">0.587</span> * g + <span class="number">0.114</span> * b) / <span class="number">255</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>])) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>])) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>])) <span class="comment">// 0.299</span></span><br><span class="line"><span class="built_in">console</span>.log(getGrayLevelFromRgb([<span class="number">18</span>, <span class="number">18</span>, <span class="number">18</span>])) <span class="comment">// 0.07058823529411765</span></span><br></pre></td></tr></table></figure><p>而我们只需要设定一个阈值，大于这个阈值的就属于 light，否则为 dark 即可。</p><p>这里我设定的阈值是 0.85，这个阈值具体是多少根据实际情况而定。</p><h3 id="在-Vim-中保存只读文件"><a href="#在-Vim-中保存只读文件" class="headerlink" title="在 Vim 中保存只读文件"></a>在 Vim 中保存只读文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:w ! sudo tee % &gt; /dev/null</span><br></pre></td></tr></table></figure><h3 id="Mac-在-dock-隐藏特定应用"><a href="#Mac-在-dock-隐藏特定应用" class="headerlink" title="Mac 在 dock 隐藏特定应用"></a>Mac 在 dock 隐藏特定应用</h3><p>有时候我们想要在 Mac 的 dock 中隐藏特定应用，可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lsappinfo setinfo -app XXX ApplicationType=UIElement</span><br></pre></td></tr></table></figure><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="怎么花两年时间面试一个人"><a href="#怎么花两年时间面试一个人" class="headerlink" title="怎么花两年时间面试一个人"></a><a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎么花两年时间面试一个人</a></h3><p>这是一篇 11 年前的文章（2011），但在今天看来仍然非常有用，本文比较长，但我还是建议你阅读。</p><p>这里简单摘要一些本文内容，本文开宗明义地提出一个问题：<strong>招聘难，难于上青天</strong>。</p><p>这是因为：</p><ol><li>最好的人也许不投简历，就决定去哪里了。所以要在他们做决定前找到他们。</li><li>比较差的会投很多次简历，找不到工作的时间越多，投的简历越多，给整个 pool 带来很多噪音，top10% 的简历也许根本不算全部人的 top10%。</li></ol><p>公司招到靠谱的人非常重要，所以，<strong>招聘也许是一个公司决策当中最最重要的一个环节</strong>。</p><p>本文作者就根据他的一些经验，给出了一些关于如何做招聘的建议。</p><p>最后作者给出如何花两年时间面试一个人的方法，那就是看面试者平时的积累，推荐的方式是：书 + GitHub，这样足以相当两年左右的面试。</p><h3 id="你应该阅读学术计算机科学论文"><a href="#你应该阅读学术计算机科学论文" class="headerlink" title="你应该阅读学术计算机科学论文"></a><a href="https://stackoverflow.blog/2022/04/07/you-should-be-reading-academic-computer-science-papers/">你应该阅读学术计算机科学论文</a></h3><p>作为一名在职程序员，你需要不断地学习，你可以通过查看教程、文档、StackOverflow，以及你可以找到的任何帮助你更好地编写代码并保持最新技能的内容。但是，你试过深入研究计算机科学论文来提高你的编程能力吗？</p><p>虽然以上提到的教程可以帮助你立即编写代码，但阅读学术论文能够帮助你了解编程的来龙去脉，从空指针到对象，这些编程中大部分日常使用的功能都可以追溯到上世纪 60 年代，未来的创新一样建立在今天的研究之上。</p><p>所以，不妨试一下直接通过阅读论文去了解这些编程的知识，如果认为阅读论文还是太难，可以试一下观看这些演讲：<a href="https://www.youtube.com/c/PapersWeLove/videos">PapersWeLove - YouTube</a>。</p><h3 id="WebAssembly-使用JavaScript-垃圾回收器"><a href="#WebAssembly-使用JavaScript-垃圾回收器" class="headerlink" title="WebAssembly 使用JavaScript 垃圾回收器"></a><a href="https://jott.live/markdown/js_gc_in_wasm">WebAssembly 使用JavaScript 垃圾回收器</a></h3><p>我们知道，JavaScript 自带有垃圾回收机制，而 WebAssembly 却没有这个机制，因为它在比较底层的环境中运行，我们只能靠自己分配内存。</p><p>目前有一个关于 WebAssembly 的<a href="https://github.com/WebAssembly/gc/blob/main/proposals/gc/MVP.md">提案</a>，涉及实现一个垃圾回收机制，但可惜还处于 Stage 2，仍没有浏览器实现该功能。</p><p>而本文作者发现了一个取巧的方式可以实现这个需求，那就是使用 WeakRefs，总的来说就是通过 WeakRefs 特性，自行实现一个永久循环的函数，去做垃圾回收的事情。</p><p>感兴趣可以阅读相关<a href="https://github.com/bwasti/web_assembly_experiments/tree/main/memory_management">实现代码</a>。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://it-tools.tech/">IT Tools</a>：一个开发者工具，包含日常使用的功能，如 Base64 转换、QR Code 生成，URL 解析等，使用体验极佳。</li></ul><ul><li><a href="https://www.joshwcomeau.com/operator-lookup/">Operator Lookup</a>：输入一个 JavaScript 的操作符（e.g. +、=&gt;），将会解释该操作符的作用，对初学者非常有用。</li></ul><ul><li><a href="https://gitexplorer.com/">Git Explorer</a>：通过的问答选择的方式寻找你想要的 Git 命令，从此使用 Git 命令不再求人。</li></ul><ul><li><a href="https://sourabhbajaj.com/mac-setup">macOS Setup Guide</a>：本指南介绍了在新 Mac 上设置开发环境的基础知识。旨在供所有人用作设置环境或安装语言/库的指南。</li></ul><ul><li><a href="https://tiny-helpers.dev/">Tiny Helpers</a>：Web 开发者的工具集合。</li></ul><ul><li><a href="https://iep.utm.edu/">Internet Encyclopedia of Philosophy</a>：互联网哲学百科全书，有很多关于形而上的哲学论文。</li></ul><ul><li><a href="https://stage.so/">Stage</a>：一个设计工具。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本周见闻&quot;&gt;&lt;a href=&quot;#本周见闻&quot; class=&quot;headerlink&quot; title=&quot;本周见闻&quot;&gt;&lt;/a&gt;本周见闻&lt;/h2&gt;&lt;h3 id=&quot;Git-2-36-亮点&quot;&gt;&lt;a href=&quot;#Git-2-36-亮点&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>周刊第9期：Web 发展中的 100 个重大事件</title>
    <link href="https://4ark.me/post/weekly-09.html"/>
    <id>https://4ark.me/post/weekly-09.html</id>
    <published>2022-04-17T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="Web-发展中的-100-个重大事件"><a href="#Web-发展中的-100-个重大事件" class="headerlink" title="Web 发展中的 100 个重大事件"></a><a href="https://developer.chrome.com/100/">Web 发展中的 100 个重大事件</a></h3><p>自 2008 年 Chrome 浏览器正式发布以来，到现在 Chrome 已经发展到第 100 个版本了，为此还开发了一个网站，该网站展示了从 2008 年 Chrome 浏览器发布以来的 100 个对于 Web 发展的重大里程碑事件，譬如 GitHub 一周年、Node.js 发布、Flexbox 提案等，有兴趣可以看看。</p><h3 id="我们如何失去-54K-的-GitHub-stars"><a href="#我们如何失去-54K-的-GitHub-stars" class="headerlink" title="我们如何失去 54K 的 GitHub stars"></a><a href="https://httpie.io/blog/stardust">我们如何失去 54K 的 GitHub stars</a></h3><p>相信大家都知道 <a href="https://github.com/httpie/httpie">httpie</a> 这个命令行工具，近日，由于维护者误操作将仓库设置为私有仓库，导致 54K 的 stars 被清零，经与 GitHub 官方沟通后，被告知无法恢复，截止今日（2022-04-17）已经重新涨回 12.7K。</p><p>httpie 在吐槽之余，还顺便教了一下 GitHub 做产品：</p><ol><li>UI/UX 设计，在设置为私有仓库时，告知用户会损失哪些数据。</li><li>数据库的软删除设计。</li></ol><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="Chromium-的-DNS-缓存时间"><a href="#Chromium-的-DNS-缓存时间" class="headerlink" title="Chromium 的 DNS 缓存时间"></a><a href="https://textslashplain.com/2022/03/31/chromiums-dns-cache/">Chromium 的 DNS 缓存时间</a></h3><p>Chromium 的 DNS 缓存时间大概在一分钟左右：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Default TTL for successful resolutions with ProcTask.</span></span><br><span class="line"><span class="keyword">const</span> unsigned kCacheEntryTTLSeconds = <span class="number">60</span>;</span><br></pre></td></tr></table></figure><p>DNS 的解析过程比较复杂，有兴趣可以看这个：<a href="https://source.chromium.org/chromium/chromium/src/+/main:net/dns/README.md;drc=761feeebc0214d55f2cff89f5904f5521ab02610">Chrome Host Resolution</a>，或者简单看下这两张图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/20190822181732.png" alt="img"></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/1604181361-5a1397cca5644_articlex.png" alt="img"></p><p>上图源自笔者一篇旧文：<a href="https://4ark.me/post/b6c7c0a2.html">在浏览器输入 URL 回车之后发生了什么（超详细版）</a></p><p>如果想要查看浏览器 DNS 配置的详细信息，可以按照以下流程：</p><ol><li>打开：chrome://net-export，开始记录，打开任意一个网站发起请求，导出 JSON 文件。</li><li>在 <a href="https://netlog-viewer.appspot.com/#import">NetLog Viewer</a> 导入查看，DNS 栏目。</li></ol><h3 id="ECMAScript-提案-通过复制改变数组"><a href="#ECMAScript-提案-通过复制改变数组" class="headerlink" title="ECMAScript 提案 - 通过复制改变数组"></a><a href="https://2ality.com/2022/04/change-array-by-copy.html">ECMAScript 提案 - 通过复制改变数组</a></h3><p>这篇博客文章描述了 Robin Ricard 和 Ashley Claymore 提出的 ECMAScript 提案 <a href="https://github.com/tc39/proposal-change-array-by-copy">“Change Array by copy”</a>。它为 Array 和 TypedArray 提出了四种新方法：</p><ul><li><code>.toReversed()</code></li><li><code>.toSorted()</code></li><li><code>.toSpliced()</code></li><li><code>.with()</code></li></ul><p>大多数 Array 方法是无副作用的 – 它们不会更改调用它们的数组，例如：<code>filter</code>、<code>map</code> 等。</p><p>但也有副作用的方法，例如：<code>reverse</code>、<code>sort</code>、<code>splice</code>。</p><p>因此新加入的三个方法为上述三种方法提供了无副作用版本，除此之外还引入了一个新方法：<code>with。</code></p><p>它是下面这段代码的无副作用版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr[index] = value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无副作用</span></span><br><span class="line">arr.with(index, value) <span class="comment">// 返回一个新的 array</span></span><br></pre></td></tr></table></figure><h3 id="CSS-父选择器-has"><a href="#CSS-父选择器-has" class="headerlink" title="CSS 父选择器 - :has()"></a><a href="https://ishadeed.com/article/css-has-parent-selector/">CSS 父选择器 - :has()</a></h3><p>在以前， 我们无法根据父元素是否包含某个子元素时决定父元素的样式。</p><p>譬如，我们希望在 <code>.card</code> 有子元素 <code>img</code> 时设置特定样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;a.jpg&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>card text<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以使用 <code>:has()</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span><span class="selector-pseudo">:has</span>(<span class="selector-tag">img</span>) &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实 <code>:has()</code> 不止可以用于检查父元素是否包含某个子元素，还可以检查后面的元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 检查 <span class="selector-tag">h2</span> 后面跟着 <span class="selector-tag">p</span></span><br><span class="line"><span class="selector-class">.card</span> <span class="selector-tag">h2</span><span class="selector-pseudo">:has</span>(+ <span class="selector-tag">p</span>) &#123; &#125;</span><br></pre></td></tr></table></figure><p>但遗憾的是，截止目前（2022-04-18）只有 Safari 15.4和 Chrome Canary 支持该特性，详见 <a href="https://caniuse.com/css-has">caniuse</a>。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="React-18-允许组件渲染-Undefined"><a href="#React-18-允许组件渲染-Undefined" class="headerlink" title="React 18 允许组件渲染 Undefined"></a><a href="https://blog.saeloun.com/2022/04/14/react-18-allows-components-to-render-undfined.html">React 18 允许组件渲染 Undefined</a></h3><p>在 React 18 之前，如果我们这样渲染了一个组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Circle <span class="keyword">from</span> <span class="string">&#x27;./Circle&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Square <span class="keyword">from</span> <span class="string">&#x27;./Square&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params">&#123;type&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;circle&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Circle</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(type === <span class="string">&#x27;square&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Shape;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.jsx</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) : <span class="title">ComponentType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>(<span class="xml"><span class="tag">&lt;<span class="name">Shape</span> <span class="attr">type</span>=<span class="string">&quot;rectangle&quot;</span>/&gt;</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Shape 组件返回 Undefined，我们将得到以下报错信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Shape(...): Nothing was returned from render. This usually means a <span class="built_in">return</span> statement is missing. Or, to render nothing, <span class="built_in">return</span> null.</span><br></pre></td></tr></table></figure><p>为了修复报错，我们必须显式返回 <code>null</code>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import Circle from &#x27;./Circle&#x27;;</span><br><span class="line">import Square from &#x27;./Square&#x27;;</span><br><span class="line"></span><br><span class="line">function Shape(&#123;type&#125;) &#123;</span><br><span class="line">  if(type <span class="comment">=== &#x27;circle&#x27;) &#123;</span></span><br><span class="line">    return &lt;Circle /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  if(type <span class="comment">=== &#x27;square&#x27;) &#123;</span></span><br><span class="line">    return &lt;Square /&gt;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+ return null;</span></span><br><span class="line">&#125;</span><br><span class="line">export default Shape;</span><br></pre></td></tr></table></figure><p>但随着 React 18 的发布，即便组件未返回任何内容，也不会引发运行时错误。</p><p>基于以下三点原因，使 React 18 作出此改动：</p><ol><li><p>与其抛出错误，不如使用 Lint 工具</p><ul><li>渲染 Undefined 报错这个机制是在 2017 年加入的，当时类型系统和 Lint 工具还没开始流行，但现在我们完全可以使用 ESLint 等工具帮我们处理这些类型的错误。</li></ul></li><li><p>很难创建正确的类型，考虑以下代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape.jsx </span></span><br><span class="line"><span class="keyword">const</span> Shape = (&#123; children &#125;: ComponentType): <span class="function"><span class="params">ComponentType</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//App.jsx</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>): <span class="title">ComponentType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">Shape</span> /&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们必须在 <code>ComponentType</code> 类型将 Undefined 排除在外，但更好的解决方法就是允许渲染 Undefined。</p></li><li><p>保持一致的行为</p><ul><li>因为最近 Suspense 的 fallbacks <a href="https://github.com/reactwg/react-18/discussions/72">允许渲染 Undefined</a>，所以保持一致。</li></ul></li></ol><h3 id="JavaScript-中-RegExp-与-String-replace-的神奇特性"><a href="#JavaScript-中-RegExp-与-String-replace-的神奇特性" class="headerlink" title="JavaScript 中 RegExp 与 String.replace 的神奇特性"></a><a href="https://blog.huli.tw/2022/04/14/javascript-string-regexp-magic/">JavaScript 中 RegExp 与 String.replace 的神奇特性</a></h3><p>下面这段代码的执行结果是什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/huli/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;blog.huli.tw&#x27;</span></span><br><span class="line"><span class="keyword">var</span> str2 = <span class="string">&#x27;example.huli.tw&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// ???</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str2)) <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><p>相信很多人都会认为两个都是 true，但答案是 true 和 false，即便你写成这样，第二个输出结果也是 false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/huli/g</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;blog.huli.tw&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.test(str)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这是因为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test#%E5%BD%93%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E6%A0%87%E5%BF%97%E7%9A%84%E6%AD%A3%E5%88%99%E4%BD%BF%E7%94%A8test">RegExp 是有副作用的</a>，以下为 MDN 原话：</p><blockquote><p>如果正则表达式设置了全局标志，<code>test() </code>的执行会改变正则表达式  <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>lastIndex</code></a> 属性。连续地执行<code>test()</code>方法，后续的执行将会从 lastIndex 处开始匹配字符串，(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec()</code></a> 同样改变正则本身的 <code>lastIndex 属性值</code>).</p></blockquote><p>以下代码证明了这点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/foo/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// regex.lastIndex is at 0</span></span><br><span class="line">regex.test(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// regex.lastIndex is now at 3</span></span><br><span class="line">regex.test(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>再来看另外一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;4ark&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = <span class="regexp">/\w+/</span>.test(str)</span><br><span class="line"></span><br><span class="line">str = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们还能拿得到 str 之前的值吗？</span></span><br></pre></td></tr></table></figure><p>答案是可以的，因为 RegExp 上有一个神奇的属性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/input#%E8%AF%AD%E6%B3%95">RegExp.input</a>。</p><p>除此之外，还有这些：</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastMatch">RegExp.lastMatch</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastParen">RegExp.lastParen</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/leftContext">RegExp.leftContext</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/rightContext">RegExp.rightContext</a></li></ol><p>但是需要注意，这些特性是非标准的，请尽量不要在生产环境中使用它！</p><p>另外原文还有关于 String.replace 的神奇特性：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0">使用字符串作为参数</a>，简单来说就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;123&#123;n&#125;456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 123A456</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&#x27;A&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123123A456，原本 &#123;n&#125; 的地方变成 123A</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&quot;$`A&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123456A456，原本 &#123;n&#125; 的地方变成 456A</span></span><br><span class="line"><span class="built_in">console</span>.log(str.replace(<span class="string">&#x27;&#123;n&#125;&#x27;</span>, <span class="string">&quot;$&#x27;A&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="在用户离开页面时可靠地发送-HTTP-请求"><a href="#在用户离开页面时可靠地发送-HTTP-请求" class="headerlink" title="在用户离开页面时可靠地发送 HTTP 请求"></a><a href="https://css-tricks.com/send-an-http-request-on-page-exit/">在用户离开页面时可靠地发送 HTTP 请求</a></h3><p>我们希望在用户离开当前页面时发送一个 HTTP 请求，这是一个非常常见的需求，譬如页面埋点等。</p><p>但根据 <a href="https://developer.chrome.com/blog/page-lifecycle-api/">Chrome 页面的生命周期</a>显示，在页面终止运行时，无法保证进程内的请求会成功，因此，在离开页面时发送请求可能并不可靠，如果我们依赖这个行为，则会出现潜在的重大问题。</p><p>通过下图可看出在页面离开时，请求会被取消掉：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204181217957.gif" alt="在“网络”选项卡中查看 HTTP 请求失败"></p><p>为什么请求会被取消呢？下面是 Chrome 对于页面终止生命周期（Terminated）的描述：</p><blockquote><p>A page is in the <em>terminated</em> state once it has started being unloaded and cleared from memory by the browser. No <a href="https://html.spec.whatwg.org/multipage/webappapis.html#queue-a-task">new tasks</a> can start in this state, and in-progress tasks may be killed if they run too long.</p><p><strong>Possible previous states:</strong><br><a href="https://developer.chrome.com/blog/page-lifecycle-api/#state-hidden">hidden</a> <em>(via the <a href="https://developer.chrome.com/blog/page-lifecycle-api/#event-pagehide"><code>pagehide</code></a> event)</em></p><p><strong>Possible next states:</strong><br>NONE</p></blockquote><p>简单来说就是一个页面被卸载并从内存清除时，它就处于终止状态，在这种状态下，没有新的任务可以启动，正在运行的任务如果运行时间过长，则有可能会被 killed 掉。</p><p>那我们应该如何解决这个问题呢？有下面几种方案：</p><ol><li>阻塞页面跳转，直到请求被响应：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">async</span> (e) =&gt; &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Wait for response to come back...</span></span><br><span class="line">  <span class="keyword">await</span> fetch(<span class="string">&quot;/log&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      <span class="attr">some</span>: <span class="string">&#x27;data&#x27;</span></span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...and THEN navigate away.</span></span><br><span class="line">   <span class="built_in">window</span>.location = e.target.href;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但这样也有很明显的缺点，1）损害用户体验；2）没有包含所有页面离开行为，例如关闭浏览器 tab。</p><ol start="2"><li>使用 Fetch 的 <a href="https://fetch.spec.whatwg.org/#request-keepalive-flag">keepalive</a> 选项，使请求继续保留，即便页面已终止。</li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;/some-other-page&quot; id=&quot;link&quot;&gt;Go to Page&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  document.getElementById(&#x27;link&#x27;).addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;</span><br><span class="line">    fetch(&quot;/log&quot;, &#123;</span><br><span class="line">      method: &quot;POST&quot;,</span><br><span class="line">      headers: &#123;</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application/json&quot;</span><br><span class="line">      &#125;, </span><br><span class="line">      body: JSON.stringify(&#123;</span><br><span class="line">        some: &quot;data&quot;</span><br><span class="line">      &#125;), </span><br><span class="line"><span class="addition">+     keepalive: true</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <a href="https://w3c.github.io/beacon/#sendbeacon-method">Navigator.sendBeacon()</a> 方法</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/some-other-page&quot;</span> <span class="attr">id</span>=<span class="string">&quot;link&quot;</span>&gt;</span>Go to Page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;link&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">some</span>: <span class="string">&quot;data&quot;</span> &#125;)], &#123; <span class="attr">type</span>: <span class="string">&#x27;application/json; charset=UTF-8&#x27;</span> &#125;);</span></span><br><span class="line"><span class="javascript">    navigator.sendBeacon(<span class="string">&#x27;/log&#x27;</span>, blob));</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>使用 a 标签的 <a href="https://css-tricks.com/the-ping-attribute-on-anchor-links/">ping 属性</a></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:3000/other&quot;</span> <span class="attr">ping</span>=<span class="string">&quot;http://localhost:3000/log&quot;</span>&gt;</span></span><br><span class="line">  Go to Other Page</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击该链接后，它会自动发出一个 POST 请求，并将 href 属性放在请求头中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">headers: &#123;</span><br><span class="line">  &#x27;ping-from&#x27;: &#x27;http:<span class="comment">//localhost:3000/&#x27;,</span></span><br><span class="line">  &#x27;ping-to&#x27;: &#x27;http:<span class="comment">//localhost:3000/other&#x27;</span></span><br><span class="line">  &#x27;content-type&#x27;: &#x27;text/ping&#x27;</span><br><span class="line">  <span class="comment">// ...other headers</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>但有如下限制：</p><ol><li>只能在 a 标签上使用</li><li>浏览器支持很好，但 Firefox 除外 :(</li><li>无法自定义发送的数据…</li></ol><p>如果选择使用哪个方法呢？文中还给出了一个很好的提示：</p><ul><li>以下情况，推荐使用 fetch + keepalive<ul><li>需要自定义 header 和请求内容</li><li>希望发出 GET，而不只是 POST</li><li>需要支持较旧的浏览器，并且已有 fetch 的 polyfill。</li></ul></li><li>以下情况，推荐使用 <code>sendBeacon()</code><ul><li>只是简单的请求，不需要太多的自定义内容</li><li>喜欢更干净、更优雅的 API。</li><li>您希望保证您的请求不会与应用程序中发送的其它高优先级的请求竞争。</li></ul></li></ul><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://github.com/Troland/how-javascript-works">Troland/how-javascript-works</a>：本文是翻译介绍 JavaScript 的工作原理的，该系列原文还在更新中，原文见<a href="https://blog.sessionstack.com/tagged/tutorial">这里</a>。此为<a href="https://xcoder.in/">死月</a>翻译的中文版。</li></ul><ul><li><a href="https://webaim.org/projects/million/">The WebAIM Million</a> ：2022年关于前 100 万个主页的可访问性报告。</li></ul><ul><li><a href="https://turborepo.org/">Turborepo</a>：Turborepo 是一个针对 JavaScript 和 TypeScript 代码库的高性能构建系统。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本周见闻&quot;&gt;&lt;a href=&quot;#本周见闻&quot; class=&quot;headerlink&quot; title=&quot;本周见闻&quot;&gt;&lt;/a&gt;本周见闻&lt;/h2&gt;&lt;h3 id=&quot;Web-发展中的-100-个重大事件&quot;&gt;&lt;a href=&quot;#Web-发展中的-100-个重大事件&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>周刊第8期：阅读 ECMAScript 规范</title>
    <link href="https://4ark.me/post/weekly-08.html"/>
    <id>https://4ark.me/post/weekly-08.html</id>
    <published>2022-04-11T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阅读-ECMAScript-规范"><a href="#阅读-ECMAScript-规范" class="headerlink" title="阅读 ECMAScript 规范"></a>阅读 ECMAScript 规范</h2><p>有必要先向部分初学者解释一下 JavaScript 和 ECMAScript 的区别，最开始 ECMA 仅是 European Computer Manufacturers Association （欧洲计算机制造商协会）的首字母缩写，不过随着计算机的国际化，组织的标准牵涉到很多其他国家，因此这个组织已经改名为 Ecma 国际，所以现在的 Ecma 本身就是一个名字，不再是首字母缩写。</p><p>ECMAScript 与 JavaScript 其实就是同一个东西，只是因为 JavaScript 这个名称已经被 Sun 公司注册了商标，并且不开放给 Ecma 协会使用，所以 JavaScript 的标准只能叫做 ECMAScript，而 JavaScript 可以看做是 ECMAScript 规范的一种实现。</p><p>我们为什么要学习阅读 ECMAScript 规范呢？如果你只是一名 JavaScript 的初学者，你确实没有太大的必要去阅读 ECMAScript 规范，只需要通过阅读 MDN 文档就能学习如何编写 JavaScript，但随着 JavaScript 水平的提升，我们会越来越不满足于使用，我们会想要知道更多内部的细节，然而并不是所有的 JavaScript 细节都会在 MDN 文档上说明。</p><p>下面我就举个在工作中真实遇到的场景，以此阐述我们为什么需要阅读 ECMAScript 规范。</p><p>考虑以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">300</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="number">100</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="number">200</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="number">50.5</span>: <span class="number">50.5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你觉得这段代码的输出顺序是什么呢？答案是：<code>100,200,300,50.5</code>。</p><p>这是为什么呢？</p><p>从 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in">for…in</a> 的 MDN 文档中，无法得到我们想要的答案，这时候就只能通过阅读 ECMAScript 规范：</p><p> <img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204080105185.png" alt="image-20220408010524823"></p><p>通过以上信息我们得知，JavaScript 在遍历一个对象的时候，它将按照如下规则执行：</p><ol><li>创建一个空的列表用于存放 keys</li><li>将所有<strong>合法的数组索引</strong>按升序的顺序存入</li><li>将所有<strong>字符串类型索引</strong>按属性创建时间以升序的顺序存入</li><li>将所有 <strong><code>Symbol</code> 类型索引</strong>按属性创建时间以升序的顺序存入</li><li>返回 keys</li></ol><p>PS：当然 for…in 是不会返回 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol">Symbol</a> 类型的属性的，需要使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols()</a>。</p><p>以上源自笔者遇到的一个真实案例，详见<a href="https://4ark.me/post/how-object-keys-work.html">《一行 Object.keys() 引发的血案》</a>。</p><p>相信大家都已经非常清楚学习阅读 ECMAScript 规范的重要性，可 ECMAScript 规范也不是这么容易阅读的，所以这里提供了一些文章，帮助你快速学习阅读 ECMAScript 规范：</p><ul><li><a href="https://timothygu.me/es-howto/#example-string-prototype-substring">How to Read the ECMAScript Specification</a></li><li><a href="https://v8.dev/blog/tags/understanding-ecmascript">Understanding the ECMAScript spec</a></li><li><a href="https://blog.huli.tw/2022/01/30/how-to-validate-javascript-knowledge/">你知道的 JavaScript 知識都有可能是錯的</a></li></ul><p>总之，与本文一样带着问题去阅读，往往能够事半功倍。</p><h2 id="《编程语言的设计与实现》——-松本行弘"><a href="#《编程语言的设计与实现》——-松本行弘" class="headerlink" title="《编程语言的设计与实现》—— 松本行弘"></a>《编程语言的设计与实现》—— 松本行弘</h2><p>此书是 Ruby 语言的创造者 —— 松本行宏在《日经Linux》杂志上的连载整合而成，主要介绍了新语言 Streem 的设计与实现过程。作者从设计 Streem 这门新语言的动机开始讲起，由浅入深，详细介绍了新语言开发中的各个环节，以及语言设计上的纠结与取舍，其中也不乏对其他编程语言的调查与思考，向读者展示了创建编程语言的乐趣。</p><p>笔者现在刚看完第二章，不过也可以谈谈我的阅读感悟：作为一名野生前端，我对编译原理可谓是一窍不通，顶多也就写个 Babel 小玩具的水平，像《编译原理》这种专业书，我是连前十页都啃不下去，好在日系书籍有一个很大的特点就是：<strong>浅显易懂</strong>，此书也不例外，在前两章就带领读者如何通过 lex 进行词法解析，然后通过 yacc 进行语法解析，这过程还会将编译原理中的一些知识带出来，譬如 BNF（巴科斯范式）、窥孔优化等。</p><p>除了编译原理以外，我们还可以通过本书学习如何站在语言设计者的角度去思考语言的特性，为什么要这么设计，从而使我们的视野更加开阔，所以建议每一位开发者都阅读本书（对我这种野生程序员尤为重要）。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="CSS-属性使用次数排行榜"><a href="#CSS-属性使用次数排行榜" class="headerlink" title="CSS 属性使用次数排行榜"></a><a href="https://chromestatus.com/metrics/css/popularity">CSS 属性使用次数排行榜</a></h3><p>Chrome 使用<a href="https://source.chromium.org/chromium/chromium/src/+/main:tools/metrics/histograms/enums.xml">匿名使用统计数据</a>计算每个在 Chrome 浏览器加载的页面中 CSS 属性出现的次数，数据的实时性大概在 24 小时之内。</p><p>以下截取部分排名靠前的 CSS 属性：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204080001598.png" alt="image-20220408000057438"></p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="为什么-HTTP-301-后会把-POST-转为-GET？"><a href="#为什么-HTTP-301-后会把-POST-转为-GET？" class="headerlink" title="为什么 HTTP 301 后会把 POST 转为 GET？"></a><a href="https://zh.wikipedia.org/wiki/HTTP_301">为什么 HTTP 301 后会把 POST 转为 GET？</a></h3><p>根据 <a href="https://datatracker.ietf.org/doc/html/rfc7231#section-6.4.2">RFC 7231, section 6.4.2: 301 永久重定向</a> 指出：</p><blockquote><p>Note: For historical reasons, a user agent MAY change the request<br> method from POST to GET for the subsequent request.  If this<br> behavior is undesired, the 307 (Temporary Redirect) status code<br> can be used instead.</p></blockquote><p>简而言之就是因为历史原因，当某些 HTTP/1.0 客户端收到该状态码时，可能会将 POST 方法改为 GET 方法，继续向新地址发出请求，这是错误的实现——故而后续标准引入了 <a href="https://zh.wikipedia.org/wiki/HTTP_307">HTTP 307</a>。</p><p>所以最好只在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET"><code>GET</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD"><code>HEAD</code></a> 方法时使用 301，其他情况使用 307 或者 308 来替代 301。</p><h3 id="JavaScript-的数字安全范围"><a href="#JavaScript-的数字安全范围" class="headerlink" title="JavaScript 的数字安全范围"></a><a href="https://blog.huli.tw/2022/03/14/javascript-number/">JavaScript 的数字安全范围</a></h3><p>你会如何解释这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740992</span> === <span class="number">9007199254740993</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>我们知道 JavaScript 的数字是用 64 bit 來存，而且遵循的规格是 IEEE 754-2019，既然用 64 bit 来存，那可以表示的数字自然是有限的。</p><p>我们可以用 <code>Number.MAX_SAFE_INTEGER</code> 表示 JavaScript 最大正整数的安全范围，也就是 <code>2^53 - 1</code> = <code>9007199254740991</code>。</p><p>这里所说的安全指的是：<strong>能够准确区分两个不相同的值</strong>，例如 <code>Number.MAX_SAFE_INTEGER + 1 === Number.MAX_SAFE_INTEGER + 2</code> 这在 JavaScript 上是成立的，但它在数学上是错误的，我们可以使用 <code>Number.isSafeInteger()</code> 来判断一个数字是否是一个「安全整数」。</p><p>需要注意的是，最大的安全范围不代表 JavaScript 只能存储 <code>Number.MAX_SAFE_INTEGER</code> 这么大的数字，其实我们最大可以存储 <code>Number.MAX_VALUE</code> 也就是 1.7976931348623157e+308 ，只是它不在安全范围之内罢了。</p><p>总之，对于一些比较大的数字（譬如 uuid 这类），优先考虑是否使用 String 类型，如果一定要数字类型，可以了解下 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/BigInt">BigInt</a>。</p><h3 id="为什么「Enter键」要被翻译为「回车键」？"><a href="#为什么「Enter键」要被翻译为「回车键」？" class="headerlink" title="为什么「Enter键」要被翻译为「回车键」？"></a><a href="https://haohailong.net/2012/why-enter-key-is-huiche-in-chinese">为什么「Enter键」要被翻译为「回车键」？</a></h3><p>其实「回车」并不是 “Enter” 的翻译，而是 “return” 的翻译。这个 return 其实指的是 “↵+Enter” 中箭头的意思，换言之，Enter 并不是“↵”的一个解释，严格讲 “Enter” 和“↵”是这个键的两种不同的名称，也即两个不同的用途。</p><p>之所以会被翻译成「回车」，是因为现代电脑键盘是从过去的打字机上继承过来的，在过去的机械打字机上有个部件叫「字车」，每打一个字符，字车前进一格，打完一行后，我们需要让字车回到起始位置，而 “Return” 键最早就是这个作用，因此被翻译为「回车」。</p><p>有兴趣可以看看这个视频：</p><iframe src="//player.bilibili.com/player.html?aid=591562931&bvid=BV1uq4y1k7EM&cid=440002269&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="DeepL-Api-设计中的欺骗战术"><a href="#DeepL-Api-设计中的欺骗战术" class="headerlink" title="DeepL Api 设计中的欺骗战术"></a><a href="https://zu1k.com/posts/thinking/deception-tactics-in-deepl-api-design/">DeepL Api 设计中的欺骗战术</a></h3><p>本文作者通过逆向 DeepL 的 Windows 客户端（C#），破解了 DeepL 如何实现接口防滥用。</p><p>直接说结论，其实 DeepL 并没有使用一些常规的方法（譬如 token、签名等）去实现接口防滥用，而是通过两个非常取巧的方法去把开发者绕晕：</p><ol><li>timestamp 参数并不是一个真实的时间戳，而是通过时间戳和源文本的长度进行伪造的，公式是：<code>ts - ts % i_count + i_count</code>，由于与真实的时间戳仅有毫秒部分的差别，一般人无法直接看出端倪。</li><li>id 参数就是一个随机数，只不过后续的请求会在此基础上 + 1，并且这个 id 会决定文本中一个小小的、微不足道的空格。但由于我们通过拿到结果后都会先对 JSON 进行一下格式化，所以很容易忽略这种细节。</li></ol><p>如果不是逆向源代码，相信一般人很难发现这两点细节，不得不感叹 DeepL 工程师的脑洞。</p><h3 id="Cloudflare-如何将网站加载时间缩短-30"><a href="#Cloudflare-如何将网站加载时间缩短-30" class="headerlink" title="Cloudflare 如何将网站加载时间缩短 30%"></a><a href="https://blog.cloudflare.com/early-hints/">Cloudflare 如何将网站加载时间缩短 30%</a></h3><p>本文介绍 Cloudflare 在 2021 年发布的一个新特性：Early Hints，准确来说它是一个 <a href="https://httpwg.org/specs/rfc8297.html">Web 标准</a>，它定义了一个新的状态码 103。</p><p>其最核心的功能是：在服务器响应 200 时，先向客户端响应 103，其响应内容包含这个网页所需呈现内容的资源提示，客户端可利用此提示加载页面速度，如下图：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204111949351.png" alt="img"></p><p>在上面提到的 <a href="https://httpwg.org/specs/rfc8297.html">RFC</a> 中可看到 HTTP 103 的响应大概长这样（其中可能会有多个 103 响应）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Client request:</span><br><span class="line"></span><br><span class="line">  GET / HTTP/1.1</span><br><span class="line">  Host: example.com</span><br><span class="line"></span><br><span class="line">Server response:</span><br><span class="line"></span><br><span class="line">  HTTP/1.1 103 Early Hints</span><br><span class="line">  Link: &lt;/style.css&gt;; rel=preload; as=style</span><br><span class="line">  Link: &lt;/script.js&gt;; rel=preload; as=script</span><br><span class="line"></span><br><span class="line">  HTTP/1.1 200 OK</span><br><span class="line">  Date: Fri, 26 May 2017 10:02:11 GMT</span><br><span class="line">  Content-Length: 1234</span><br><span class="line">  Content-Type: text/html; charset=utf-8</span><br><span class="line">  Link: &lt;/style.css&gt;; rel=preload; as=style</span><br><span class="line">  Link: &lt;/script.js&gt;; rel=preload; as=script</span><br><span class="line"></span><br><span class="line">  &lt;!doctype html&gt;</span><br><span class="line">  [... rest of the response body is omitted from the example ...]</span><br></pre></td></tr></table></figure><p>我们可以在 Chrome 94 及更新版本使用该特性，关于更多内容可见：<a href="https://blog.cloudflare.com/early-hints/">early-hints</a>。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://cn.history.js.org/index.html">JavaScript 二十年</a>：这本书纪录了从 1995 年到 2015 年这二十年的 JavaScript 历史，看完它会对 JavaScript 有不同的体会（还会知道很多冷知识），此为中译版，原版地址：<a href="http://wirfs-brock.com/allen/posts/866">JavaScript: The First 20 Years</a>。</li></ul><ul><li><a href="https://github.com/mozilla-spidermonkey/jsparagus/blob/master/js-quirks.md#readme">js-quirks</a>：关于 JavaScript 的一些怪癖语法说明，对于想要实现 JavaScript 解析器的同学很有帮助和启发。</li></ul><ul><li><a href="https://moonvy.com/">Moonvy 月维</a>：探索「设计生产力」之道，与你一起， 创造设计师与开发者的必备工具。</li></ul><ul><li><a href="https://quokkajs.com/">QUOKKA</a>：<em>Quokka</em> 是一个调试工具，可以为您正在编写的代码提供实时反馈（可惜大部分功能都要收费。</li></ul><ul><li><a href="https://www.iconfinder.com/p/free-ukraine-icons">Free Ukraine icons</a>：一些与乌克兰战争有关的免费 icon 图标。</li></ul><ul><li><a href="https://express.adobe.com/zh-Hans-CN/sp/">Adobe Creative Cloud Express</a>：Adobe 新推出的一个设计工具，可提供快速「去除背景」、「转换为 GIF」、「合并 PDF」以及更多高级操作。</li></ul><ul><li><a href="https://uxtools.co/challenges">UX Design Challenges | UX Tools</a>：一些 UX 的挑战，帮助你学习如何提高产品的用户体验。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;阅读-ECMAScript-规范&quot;&gt;&lt;a href=&quot;#阅读-ECMAScript-规范&quot; class=&quot;headerlink&quot; title=&quot;阅读 ECMAScript 规范&quot;&gt;&lt;/a&gt;阅读 ECMAScript 规范&lt;/h2&gt;&lt;p&gt;有必要先向部分初学者解释一下</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>周刊第7期：使用新的周刊模板</title>
    <link href="https://4ark.me/post/weekly-07.html"/>
    <id>https://4ark.me/post/weekly-07.html</id>
    <published>2022-04-04T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用新的周刊模板"><a href="#使用新的周刊模板" class="headerlink" title="使用新的周刊模板"></a>使用新的周刊模板</h2><p>在本期开始采用新的周刊模板，新增了两个模块：</p><ul><li>本周见闻：一些有趣的事情、观点，与「分享文章」最大的区别在于它们通常是一些比较简短的信息。</li><li>tips：一些有用的技巧，可以帮助你提高工作效率。</li></ul><p>如此，周刊内容就显得更加丰富，可以分享更多元的信息了。</p><h2 id="本周见闻"><a href="#本周见闻" class="headerlink" title="本周见闻"></a>本周见闻</h2><h3 id="React-v18-正式发布"><a href="#React-v18-正式发布" class="headerlink" title="React v18 正式发布"></a><a href="https://reactjs.org/blog/2022/03/29/react-v18.html">React v18 正式发布</a></h3><ol><li><p><strong>自动批处理</strong></p><p>批处理是指 React 将多个状态更新合并到单个 re-render 中以获得更好的性能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在之前: 只有 React 事件是批处理的。</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  setFlag(<span class="function"><span class="params">f</span> =&gt;</span> !f);</span><br><span class="line">  <span class="comment">// React 将渲染两次，每次状态更新一次（没有批处理的情况）</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在之后: setTimeout、Promise、原生事件这类异步操作都将合并到一次 re-render 中。</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  setCount(<span class="function"><span class="params">c</span> =&gt;</span> c + <span class="number">1</span>);</span><br><span class="line">  setFlag(<span class="function"><span class="params">f</span> =&gt;</span> !f);</span><br><span class="line">  <span class="comment">// React 只会在最后重新渲染一次（这就是批处理！）</span></span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>了解更多：<a href="https://github.com/reactwg/react-18/discussions/21">https://github.com/reactwg/react-18/discussions/21</a></p></li><li><p><strong>Transitions</strong></p><p>这是 React 中的一个新概念，用于区分紧急和非紧急更新（过渡更新）。</p><ul><li><strong>紧急更新</strong>：反映了直接交互，如输入、单击、按下等。</li><li><strong>过渡更新</strong>：将 UI 从一个视图转换为另一个视图。</li></ul><p>通常，为了获得最佳用户体验，单个用户输入应同时导致紧急更新和非紧急更新。您可以在输入事件中使用 startTransition API 来通知 React 哪些更新是紧急的，哪些是过渡的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;startTransition&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 紧急，显示输入的内容</span></span><br><span class="line">setInputValue(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将内部的任何状态更新标记为转换</span></span><br><span class="line">startTransition(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 过渡：显示结果</span></span><br><span class="line">  setSearchQuery(input);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>startTransition 中包含的更新操作都将作为过渡更新进行处理，如果出现更紧急的更新，则会打断之前的过渡更新，只渲染最新的。</p><p>了解更多：<a href="https://reactjs.org/docs/react-api.html#transitions">https://reactjs.org/docs/react-api.html#transitions</a></p></li></ol><ol start="4"><li><p><strong>Hooks</strong></p><ol><li><a href="https://reactjs.org/docs/hooks-reference.html#useid">useId</a>：用于在客户端和服务器上生成唯一 ID</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usetransition">useTransition</a>：标记为过渡性更新。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usedeferredvalue">useDeferredValue</a>：允许您延迟重新渲染树的非紧急部分，类似于防抖。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#usesyncexternalstore">useSyncExternalStore</a>：允许外部存储通过强制对存储的更新为同步来支持并发读取。</li><li><a href="https://reactjs.org/docs/hooks-reference.html#useinsertioneffect">useInsertionEffect</a>：允许 CSS-in-JS 库解决在渲染中注入样式的性能问题。</li></ol></li></ol><p>关于 React v18 更多新功能请查看：<a href="https://reactjs.org/blog/2022/03/29/react-v18.html">React v18.0 – React Blog </a></p><h3 id="CSS-新提案-共享元素转场效果"><a href="#CSS-新提案-共享元素转场效果" class="headerlink" title="CSS 新提案 - 共享元素转场效果"></a><a href="https://github.com/WICG/shared-element-transitions/blob/main/explainer.md">CSS 新提案 - 共享元素转场效果</a></h3><p>CSS 的一个新提案，为切换页面提供平滑加载动画，无论是 SPA 还是 MPA 都适用，效果如下：</p><p><video src="https://user-images.githubusercontent.com/93594/141100217-ba1fa157-cd79-4a9d-b3b4-67484d3c7dbf.mp4" controls auto-play="true" ></video></p><p>关于更多可了解：<a href="https://github.com/WICG/shared-element-transitions/blob/main/explainer.md">shared-element-transitions/explainer.md</a></p><h3 id="尊重用户的默认字体大小"><a href="#尊重用户的默认字体大小" class="headerlink" title="尊重用户的默认字体大小"></a><a href="https://www.huy.rocks/everyday/03-27-2022-typography-respect-user-s-default-font-size">尊重用户的默认字体大小</a></h3><p>在处理文本和 CSS 时，我们通常都会默认设置一个固定的字体大小：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这在大部分 WEB 网站都没有问题，但是对于内容网站（如新闻网站、论坛、博客等），这可能会导致可用性问题，因为每个人设置的默认字体大小有可能不一样，比如在 Chrome 就可以通过 chrome://settings/fonts 更改字体大小，所以更好的做法是：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在内部元素采用 <code>em</code> 和 <code>rem</code>。</p><h3 id="TypeScript-的-Web-API-类型声明是怎么来的？"><a href="#TypeScript-的-Web-API-类型声明是怎么来的？" class="headerlink" title="TypeScript 的 Web API 类型声明是怎么来的？"></a><a href="https://www.huy.rocks/everyday/03-29-2022-typescript-a-note-about-lib-dom-d-ts">TypeScript 的 Web API 类型声明是怎么来的？</a></h3><p>在 TypeScript 中，所有的 Web API 类型声明都在 <a href="https://github.com/microsoft/TypeScript/blob/main/lib/lib.dom.d.ts">lib.dom.d.ts</a> 中实现，一共多达 18877 行，它当然不是手动编写的，而是利用 <a href="https://github.com/w3c/webref">webref</a> 进行生成机器可读的 Web 标准，每 6 小时自动生成一次，然后利用 <a href="https://github.com/microsoft/TypeScript-DOM-lib-generator/">TypeScript-DOM-lib-generator</a> 自动生成 lib.dom.d.ts。</p><h2 id="一些-tips"><a href="#一些-tips" class="headerlink" title="一些 tips"></a>一些 tips</h2><h3 id="使用-Lighthouse-展示网站的-JavaScript-依赖关系"><a href="#使用-Lighthouse-展示网站的-JavaScript-依赖关系" class="headerlink" title="使用 Lighthouse 展示网站的 JavaScript 依赖关系"></a><a href="https://sia.codes/posts/lighthouse-treemap/">使用 Lighthouse 展示网站的 JavaScript 依赖关系</a></h3><p>熟悉 Webpack 的前端同学应该知道有一个插件叫做 <a href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack-bundle-analyzer</a>，它用于展示每个 npm 包的体积。</p><p>现在我们也可以通过 Lighthouse Treemap 查看网站的 JavaScript 依赖关系和文件体积，效果如下：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204041746785.jpg"></p><p>使用方法：在 Chrome 使用 Lighthouse 检查，然后在结果页中点击「View Treemap」即可。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><h3 id="我讨厌的5个编码面试问题"><a href="#我讨厌的5个编码面试问题" class="headerlink" title="我讨厌的5个编码面试问题"></a><a href="https://thoughtspile.github.io/2022/03/21/bad-tech-interview/">我讨厌的5个编码面试问题</a></h3><p>本文列举几个作者最不喜欢的五类面试题目：</p><ol><li><p><strong>一些不重要的琐事</strong></p><p>这一类面试题通常是一些实际工作中很少遇到的场景，比如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> y = &#123;&#125;;</span><br><span class="line">x.__proto__ = y;</span><br><span class="line">y.__proto__ = x;</span><br><span class="line"><span class="built_in">console</span>.log(x.field);</span><br></pre></td></tr></table></figure><p>首先 <code>__proto__</code> 并不是一个标准的属性，实际工作中也应该避免使用它来修改原型链，能够正确回答它并不能真正显示候选人的 JavaScript 水平，只能体现他看过多少面试题。</p><p>这些题目通常关注于一些 JavaScript ES5 之前的糟粕，但现在已经是 2022 年了，我们没有必要再问这类问题。</p></li><li><p><strong>具体的细节</strong></p><p>这类问题通常过于关注细节，比如：</p><ul><li>迁移到 Webpack 6 会遇到什么问题？</li><li>如何检查浏览器对服务器发送事件的支持？</li></ul><p>这些问题，即便候选人真的在工作中解决过，除非事先准备好，否则也很难完整地回答出来，但我们都擅长通过搜索引擎解决这类问题。</p><p>这些题目极有可能是面试官最近解决过的一些棘手问题，他对此记忆犹新，但是根据这些问题来判断候选人的能力是不公平的，因为即便候选人回答不出来，也不代表他无法解决此类问题，这只是双方信息不对称所导致的。</p><p>所以面试官更应该着重关注于候选人最近解决过什么棘手问题，以此判断候选人解决问题的能力。</p></li><li><p><strong>混淆问题</strong></p><p>这些问题通常具有一个标准的答案，比如：</p><ol><li>Number 和 Object 之间有什么区别？</li></ol><p>这个题目的答案仅仅是：Number 是不可变的。</p><p>但候选人可能会认为这是一个开放式的题目，因此会从各方面对它们进行对比，这严重浪费时间。</p><p>同样的，这些问题也体现出候选人的面试经验，只有他被问过几次同样的题目，才熟练地知道它具有一个标准的答案。</p><p>所以面试官应该更直接地问：哪些 JavaScript 类型是不可变的。</p></li><li><p><strong>实现问题</strong></p><p>这类问题通常与浏览器实现细节相关，但它们不在规范里面：</p><ul><li><code>console.log(Object.keys(&#123; x: 0, y: 0 &#125;).join())</code> 问 x 和 y 哪个在前面？</li></ul><p>大多数人都知道正确的答案：根据添加顺序进行排序。</p><p>但此类特性依赖于 JS 引擎的实现，在 ECMAScript 规范中并没有明确定义。</p><p>所以面试官在问这类题目的时候，不应该持有标准化答案的心态，它更应该是一个开放式的题目。</p><p>PS：笔者曾写过一篇文章深入剖析 <code>Object.keys</code> 的规范：《<a href="https://4ark.me/post/how-object-keys-work.html">一行 Object.keys() 引发的血案</a>》。</p></li><li><p><strong>缺少上下文</strong></p><p>开放式问题是你在面试中可以问的最好的问题之一，因为它们具有挑战性，并能够真正体现候选人解决问题的能力，然而这些问题取决于面试官个人观点，否则容易引起反作用。</p><p>例如，这个函数有什么问题：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">arr, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    arr[i] = fn(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题对于不同的人具有不同的观点，有些人觉得这段代码问题一大堆，比如：</p><ol><li>为什么使用 <code>var</code> 而不是 <code>let</code> ？</li><li>为什么不使用 <code>for...of</code> ?</li><li>它具有副作用，不应该直接修改 <code>arr</code></li><li>为什么不直接使用 <code>.map()</code> ?</li></ol><p>但也有人觉得它没有任何问题，既然它能够正常工作，我们为什么需要重构它？仅仅是为了让它看上去更好吗？我们的目标是什么？没有明确目标的重构就是浪费时间！</p><p>所以，双方都没有错，因为它完全取决于上下文。</p><p>所以，当你提出一个开放式问题时，要么放下你预期的答案，专注于解决问题的过程，要么引入缺失的要求来指导你想要的解决方案。</p><p>最后，作者给出了一个如何改进面试题目的建议：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204041732556.png" alt="img"></p></li></ol><h3 id="不良面试官的七个习惯"><a href="#不良面试官的七个习惯" class="headerlink" title="不良面试官的七个习惯"></a><a href="https://blog.thoughtspile.tech/2022/03/28/interview-bad-habits/">不良面试官的七个习惯</a></h3><p>此文接着上一篇《我讨厌的5个编码面试问题》，列举几个面试官不好的习惯：</p><ol><li><p><strong>骄傲的自负</strong></p><p>有些面试官通常抱有一种「<strong>既然是我在面试你，那么我的能力自然比你强</strong>」的心态，他们往往摆出一副居高临下的样子，但你要清楚，你掌握所有面试问题的答案，这本就是一种信息不对称，所以你不应该抱有这种想法。</p></li><li><p><strong>专注于答案</strong></p><p>就像考试一样，面试官列出所有的面试题目，照本宣科地问问题，这类问题通常具有标准答案，但真正的工作中很少是考试一样解决问题的，并且这类问题都可以通过搜索引擎解决。</p><p>我们更应该倾向于开放式的题目，专注于候选人解决问题的过程，比如问「如何设计一个 Swiper」会比「具有哪些触摸事件」更合适。</p><p>此类问题其实还蕴含了一个顾虑：不信任候选人，认为他们缺乏这些基础知识。</p></li><li><p><strong>不给出任何提示</strong></p><p>试问当你身边的同事在某个问题卡住的时候，你会选择帮助他还是立即解雇他？所以我们应该引导候选人，而不是让他一个人苦苦挣扎。</p></li><li><p><strong>规划不善</strong></p><p>面试前没有提前规划好面试流程、或者是面试流程安排得太紧凑都会导致面试效果不佳。</p><p>假设你们明显有可能在某个问题上进行深入地探讨，千万不要仅仅因为你需要问更多初级的问题而打断候选人展示自己的机会。又或者你招聘的是高级开发人员，而候选者碰巧是一位非常不错的初级开发人员，你也不要轻易地错过。</p></li><li><p><strong>忽略简历</strong></p><p>不要浪费候选人的宝贵时间，假设候选人是一位顶尖大学毕业、甚至有一个技术博客和开源项目，这都可以体现出候选人的专业技能，而面试官仍要花费近 30 分钟去问一些基础问题，这会让候选人觉得是在浪费自己的时间。</p><p>诚然简历是可以造假，但仍不应该花费过多的时间去印证候选人是否具备这些基础知识，把时间花在更有价值的问题上。</p></li><li><p><strong>过渡延长</strong></p><p>不要让面试时间过长，除非你有自信保证候选人愿意花费这么多时间。</p></li><li><p><strong>避免群体面试的不良反应</strong></p><p>多个面试官时千万不要你一句我一句的，也不要显得某个面试官在场是完全没必要的，更好的做法是其中一位面试官负责主要的问题，其他面试官负责观察。</p></li></ol><h3 id="如何看待-ECMAScript-新提案-Type-Annotations"><a href="#如何看待-ECMAScript-新提案-Type-Annotations" class="headerlink" title="如何看待 ECMAScript 新提案 - Type Annotations"></a><a href="https://2ality.com/2022/03/type-annotations-first-look.html">如何看待 ECMAScript 新提案 - Type Annotations</a></h3><p>这个月有一个 ECMAScript 的新提案，可以在 JavaScript 中使用 TypeScript 部分类型声明，参见：<a href="https://github.com/tc39/proposal-type-annotations">tc39/proposal-type-annotations</a>。</p><p>此提案一经提出，在中英文社区都引起了不少的轰动，而《<a href="https://exploringjs.com/impatient-js/">JavaScript for impatient programmers</a>》的作者 Dr. Axel Rauschmayer 在这篇文章中提出了一些他的看法。</p><p>先展示一下这个提案的一些使用示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很标准的 TypeScript 语法，而 JavaScript 将这样处理这些类型声明：</p><ol><li>在运行时，JavaScript 引擎完全忽略它们 - 就好像它们是注释一样。</li><li>在开发时，类型检查器可以静态分析注释并警告开发人员有关潜在问题。</li></ol><p>下面是本文作者的一些看法：</p><ul><li>优点：<ul><li>为类型声明标准化是很好的，并且将使该领域的工具和实验更容易。</li><li>可以在不编译源代码的情况下使用 TypeScript 进行编程（例如）。在开发时只会进行类型检查。这将大大改善静态类型 JavaScript 的开发体验：<ul><li>执行时不需要中间文件。<ul><li>这在 Node 上特别有用 .js 您可以直接运行 TypeScript 文件。</li></ul></li><li>调试时，不需要源映射即可查看原始源代码。</li><li><code>.d.ts</code>文件通常也不需要。</li></ul></li></ul></li><li>缺点：<ul><li>像 TypeScript 这样的静态类型系统是完全可选的 JavaScript 之上的层，不会给 JavaScript 增加任何复杂性。</li><li>该提案为该语言添加了许多新的语法。即使引擎忽略它，它们仍然必须能够解析它。升级  JavaScript 工具需要时间和精力。</li><li>如果在将库部署到 npm 之前没有将 TypeScript（等）编译为 JavaScript，那么对于不喜欢 TypeScript 的人来说，浏览 TypeScript 开发人员编写的源代码将变得不那么愉快。<ul><li>为了帮助解决这个问题，从文件中删除所有类型批注可能成为文本编辑器支持的操作。</li></ul></li></ul></li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>我个人非常喜欢这个提案，也很希望这个提案能够最终进入到 ECMAScript 的标准中。但这背后仍会有无数的坑，比如 <code> add&lt;number&gt;(4,5)</code> 它也是合法的 JavaScript 代码，至于如何解决这类与现有代码冲突的问题，就让我们拭目以待吧。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://www.patterns.dev/">改进构建 Web 应用程序的方式</a>：一本关于设计模式和组件模式的免费书籍，用于使用原生 JavaScript 和 React 构建强大的 Web 应用程序。</li></ul><ul><li><p><a href="https://github.com/k88hudson/git-flight-rules/blob/master/README_zh-CN.md">Git 飞行规则(Flight Rules)</a>：这是一篇给宇航员（这里就是指使用 Git 的程序员们）的指南，用来指导问题出现后的应对之法。</p></li><li><p><a href="https://devhints.io/">里科的备忘单</a>：一些语言、框架、工具的 TL;DR，帮助你快速了解某一门技术。</p></li></ul><ul><li><a href="https://refactoringguru.cn/design-patterns">常用的设计模式有哪些？</a>：图文并茂地列出了几乎所有的设计模式，帮助你理解设计模式。</li></ul><ul><li><a href="https://developer-advocacy.com/">开发人员的宣传手册</a>：本手册引导你成为任何产品或公司的布道者。</li></ul><ul><li><a href="https://www.accessguide.io/">访问指南</a>：这是对可访问性的友好介绍！列出了很多有用的知识帮助你提高网站的可访问性。</li></ul><ul><li><a href="https://tldp.org/LDP/abs/html/index.html">高级 Bash 脚本编写指南</a>：帮助你学习 Bash 脚本，而且它没有任何版权，可用于课堂、知识分享会。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用新的周刊模板&quot;&gt;&lt;a href=&quot;#使用新的周刊模板&quot; class=&quot;headerlink&quot; title=&quot;使用新的周刊模板&quot;&gt;&lt;/a&gt;使用新的周刊模板&lt;/h2&gt;&lt;p&gt;在本期开始采用新的周刊模板，新增了两个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本周见闻：一些有趣的</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>周刊第6期：网络没有版本号</title>
    <link href="https://4ark.me/post/weekly-06.html"/>
    <id>https://4ark.me/post/weekly-06.html</id>
    <published>2022-03-28T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="网络没有版本号"><a href="#网络没有版本号" class="headerlink" title="网络没有版本号"></a><a href="https://hiddedevries.nl/en/blog/2022-01-03-the-web-doesnt-have-version-numbers">网络没有版本号</a></h3><p>在过去一年时间里，我们经常听到 WEB3 ，以及相关的术语：如区块链、加密、NTF 等，让不少 WEB 开发者认为这项技术是未来的趋势，于是每个开发者都跃跃欲试，但本文作者认为我们应该对这个充满误导性的术语 「WEB3」持谨慎态度，因为网络并没有版本号，更没有某个权威的机构会定期更新网络的版本。</p><p>希望 WEB3 及其相关术语不会成为 WEB 开发者的简历上必备的流行词，对于大部分 WEB 开发者而言，该领域的专业知识是不必要的。</p><h3 id="您在软件开发方面的经验水平将使您产生截然不同的观点和意见"><a href="#您在软件开发方面的经验水平将使您产生截然不同的观点和意见" class="headerlink" title="您在软件开发方面的经验水平将使您产生截然不同的观点和意见"></a><a href="https://www.kevinhooke.com/2022/03/22/your-experience-level-in-software-development-will-lead-you-to-wildly-different-points-of-view-and-opinions/">您在软件开发方面的经验水平将使您产生截然不同的观点和意见</a></h3><p>假设你是一个初级开发者，你为了实现某个功能，而刚好有一个库/框架能够满足你的需求，所以你希望能够把这个库/框架加入到项目中，但比你更有经验的同事拒绝了这个建议，他认为没必要仅仅为了实现一个功能而添加一个库/框架。</p><p>你可能会认为这是一个短视的看法，他们不应该被困在什么都自己重新造轮子的旧观念上。</p><p>但也许他是这样思考问题的：</p><ol><li>添加一个库，意味着增加系统的复杂度、意味着更多的风险。</li><li>需要及时跟踪这个库的安全漏洞、并在 breaking change 时更新现有的代码。</li><li>这个库的安全性如何？是否会有意外的情况发生？</li><li>添加这个库的成本和风险？成本是否会比自己开发更低？</li></ol><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>对于任何一个商业项目而言，不应该也不可能完全脱离开源社区的框架、类库，我们确实不可能所有事情都重新造轮子，开源类库的健壮性肯定比自己实现要强，但这也不意味着我们可以盲目地使用开源类库，即便要使用类库，也可能会面临多个不同选择，我们应该从生态社区、维护积极性、安全性等多方面进行考察和对比，最终选择出适合的方案。</p><h3 id="当你在构建产品时，你应该听取谁的意见？"><a href="#当你在构建产品时，你应该听取谁的意见？" class="headerlink" title="当你在构建产品时，你应该听取谁的意见？"></a><a href="https://justinjackson.ca/opinion">当你在构建产品时，你应该听取谁的意见？</a></h3><aside>💬 "在我使用苹果产品的这么多年里，我从来没有退过一个产品。直到现在。上个月我购买了带 Touch Bar 的新 MacBook Pro。真让人失望。这是第一个让我的工作效率下降的苹果设备。该公司已经与史蒂夫-乔布斯关于简单、优雅机器的愿景脱节。- 迈克尔-凯特</aside><p>人们根据自己的背景来重视不同的东西。就比如对于笔记本电脑，不同的群体需要不同的功能：</p><ul><li><strong>学生们</strong>想要一台价格实惠且重量轻的笔记本电脑（因为他们会把它带到课堂上）。</li><li><strong>程序员</strong>想要一台具有高分辨率屏幕，大量内存和全尺寸键盘的笔记本电脑。</li><li><strong>游戏玩家</strong>想要一个具有超强 CPU和 GPU 的电脑，他们也不介意笔记本电脑是否笨重。</li></ul><p>本文作者提出我们在构建产品时，最应该听从谁的意见，以及如何听从：</p><ul><li><strong>只接受为您的产品付费的人的产品反馈</strong>，很多人可能不同意这个观点，但是请看看 Feedbook 和谷歌，我们中的许多人都在每天使用它，但是 Facebook 和谷歌似乎不太关心我们的隐私，并在未经我们同意的情况下分享我们的信息。为什么？<strong>因为他们效忠的是广告商</strong>。</li></ul><h3 id="在浏览器-devtools-中打印图片"><a href="#在浏览器-devtools-中打印图片" class="headerlink" title="在浏览器 devtools 中打印图片"></a><a href="https://www.bram.us/2022/02/13/log-images-to-the-devtools-console-with-console-image/">在浏览器 devtools 中打印图片</a></h3><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203282335113.png" alt="Untitled"></p><p>我们使用以下代码在 devtools 中利用 <code>console.log</code> 输出图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBox</span>(<span class="params">width, height</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">string</span>: <span class="string">&quot;+&quot;</span>,</span><br><span class="line">        <span class="attr">style</span>: <span class="string">&quot;font-size: 1px; padding: &quot;</span> + <span class="built_in">Math</span>.floor(height/<span class="number">2</span>) + <span class="string">&quot;px &quot;</span> + <span class="built_in">Math</span>.floor(width/<span class="number">2</span>) + <span class="string">&quot;px; line-height: &quot;</span> + height + <span class="string">&quot;px;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.image = <span class="function"><span class="keyword">function</span>(<span class="params">url, scale</span>) </span>&#123;</span><br><span class="line">    scale = scale || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"></span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> dim = getBox(<span class="built_in">this</span>.width * scale, <span class="built_in">this</span>.height * scale);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;%c&quot;</span> + dim.string, dim.style + <span class="string">&quot;background: url(&quot;</span> + url + <span class="string">&quot;); background-size: &quot;</span> + (<span class="built_in">this</span>.width * scale) + <span class="string">&quot;px &quot;</span> + (<span class="built_in">this</span>.height * scale) + <span class="string">&quot;px; color: transparent;&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    img.src = url;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者直接使用这个库：<a href="https://github.com/adriancooney/console.image">https://github.com/adriancooney/console.image</a></p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://myxml.in/cors-tester.html">CORS Tester</a>：跨域对于前后端来说都是一个不可逾越的知识点，在实际项目开发中也必然会遇到各种各样的跨域问题，可以使用这个网站在线体验跨域的请求。</p></li><li><p><a href="https://effective-shell.com/">Effective Shell</a>：一本学习 Shell 的在线书籍，适合任何一个想要入门 Shell 的同学。</p></li><li><p><a href="https://curlconverter.com/">Convert curl commands to code</a>：将 CURL 转换到各编程语言的实例中，当然我们平常都会使用 Postman、PAW 等工具进行转换，不过也总有需要在线转换的时候把？</p></li><li><p><a href="https://exploringjs.com/impatient-js/index.html">JavaScript for impatient programmers (ES2022 edition)</a>：在 JavaScript 世界中有很多非常经典的书籍，如 《JavaScript 权威指南》、《JavaScript 高级程序设计》、《你不知道的 JavaScript》 等，但我推荐这本更加现代化的书，包含了最新的 ES2022 新特性。</p></li><li><p><a href="https://charm.sh/">Charm</a>：在 CLI 构建你的图形界面，真的很漂亮！</p></li><li><p><a href="https://jless.io/">jless</a>：一个更好地显示 JSON 的 CLI 工具，推荐使用！</p></li><li><p><a href="https://devtoys.app/">DevToys</a>：堪称开发者的瑞士军刀，提供了比如文件转换（JSON &lt;&gt; YAML ）、编码解码、格式化（支持 JSON、SQL、XML）、哈希生成、UUID 生成、图片压缩多种功能。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;分享文章&quot;&gt;&lt;a href=&quot;#分享文章&quot; class=&quot;headerlink&quot; title=&quot;分享文章&quot;&gt;&lt;/a&gt;分享文章&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>周刊第5期：拖延症</title>
    <link href="https://4ark.me/post/weekly-05.html"/>
    <id>https://4ark.me/post/weekly-05.html</id>
    <published>2022-03-23T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="拖延症"><a href="#拖延症" class="headerlink" title="拖延症"></a>拖延症</h2><p>本期周刊延迟了两天，今晚抽空补上，内容会相对比较少。</p><p>反思一下，一个原因是这周比较忙，但主要还是因为自己的拖延症，希望以后能够克服这个问题。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="Exhausting-Exhaustive-Testing"><a href="#Exhausting-Exhaustive-Testing" class="headerlink" title="Exhausting Exhaustive Testing"></a><a href="https://www.openmymind.net/Exhausting-Exhaustive-Testing/">Exhausting Exhaustive Testing</a></h3><p><em>原文地址：<a href="https://www.openmymind.net/Exhausting-Exhaustive-Testing/">《Exhausting Exhaustive Testing》 | openmymind</a></em></p><p>非常短的一篇文章，但作者的观点让我醒醐灌顶：编写有效的测试具有挑战性，每个测试用例都需要考虑最大化其价值。</p><p>举一个例子，比如我们有这么一个软删除用户的函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func deleteUser(id) (bool, error) &#123;</span><br><span class="line">  tag, <span class="attr">err</span> := conn.Exec(<span class="string">`</span></span><br><span class="line"><span class="string">    update users</span></span><br><span class="line"><span class="string">    set status = &#x27;deleted&#x27;</span></span><br><span class="line"><span class="string">    where id = $1</span></span><br><span class="line"><span class="string">  `</span>, id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tag.RowsAffected() == <span class="number">1</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常我们会如何测试这个函数？是不是这样：</p><ol><li>插入一个新的用户</li><li>调用这个函数</li><li>判断这个新用户是否被删除</li></ol><p>这样测试没有错，但是我们忽略了一点：如果这个函数把所有用户都删除了呢？是不是也能通过测试？</p><p>所以正确的测试方式是：插入两个用户，删除第一个用户，确保第二个用户没有被删除。</p><p>还有另外一个例子，假如我们要获取用户列表，SQL 是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, name</span><br><span class="line"><span class="keyword">from</span> users</span><br><span class="line"><span class="keyword">where</span> status <span class="operator">=</span> <span class="string">&#x27;normal&#x27;</span></span><br><span class="line">  <span class="keyword">and</span> customer_id <span class="operator">=</span> $<span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name</span><br></pre></td></tr></table></figure><p>通常我们可能是这样测试的：</p><ol><li>插入一个新用户，设置 customer_id</li><li>调用函数</li><li>判断是否返回这个新用户</li></ol><p>但作者认为至少需要插入四个新用户才能进行这个测试：</p><ol><li>四个用户，其中一个被删除的 A、一个 customer_id 不符合的 B，剩余两个才符合条件</li><li>确保没有返回 A 和 B</li></ol><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>诚然我们都认同测试的重要性，但是如何编写测试是一门非常高深的学问，只是编写测试用例的时候只是流于表面的，那么其价值是非常低的，甚至是浪费时间的。</p><h3 id="百度腾讯阿里真的是高科技企业吗？"><a href="#百度腾讯阿里真的是高科技企业吗？" class="headerlink" title="百度腾讯阿里真的是高科技企业吗？"></a><a href="https://mp.weixin.qq.com/s/JseMDsqTDKfIepmFj3u55w">百度腾讯阿里真的是高科技企业吗？</a></h3><p><em>原文地址：<a href="https://mp.weixin.qq.com/s/JseMDsqTDKfIepmFj3u55w">《百度腾讯阿里真的是高科技企业吗？》 | 马工</a></em></p><p>那么，这些潜力人才去了BAT，在干什么呢？腾讯的公众号文章《搞了运维开发这么多年，原来 Ping 还能这么玩儿！》揭示了部分真相：一个北大本科毕业生在腾讯研究一个1981年的协议ICMP，而这个协议因为不安全已经被大多数美国同行比如AWS给默认禁掉了。说句不客气的话，ICMP协议就是IT行业的回字的四种写法，让北大毕业生去研究ICMP协议，就是把他们变成孔乙己。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://oktools.net/aes">AES加密/解密</a>：一个在线 AES 加密/解密的工具。</p></li><li><p><a href="https://plantuml-editor.kkeisuke.dev/">PlantUML Editor</a>：一个在线画 PlantUML 的工具。</p></li><li><p><a href="https://getoss.art/">OssArt</a>：一个非常有意思的开源项目，它可以帮你打印出最早从 2010 年开始的 GitHub Activity 贡献图，让你的成就感满满。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;拖延症&quot;&gt;&lt;a href=&quot;#拖延症&quot; class=&quot;headerlink&quot; title=&quot;拖延症&quot;&gt;&lt;/a&gt;拖延症&lt;/h2&gt;&lt;p&gt;本期周刊延迟了两天，今晚抽空补上，内容会相对比较少。&lt;/p&gt;
&lt;p&gt;反思一下，一个原因是这周比较忙，但主要还是因为自己的拖延症，希望</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>Hg hooks 实践历程</title>
    <link href="https://4ark.me/post/hg-hooks.html"/>
    <id>https://4ark.me/post/hg-hooks.html</id>
    <published>2022-03-17T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故事的开始"><a href="#故事的开始" class="headerlink" title="故事的开始"></a>故事的开始</h2><blockquote><aside> 💬 提交代码前记得 lint</aside><aside> 💬 又有人没跑测试就提交代码</aside><aside> 💬 project-config 有改动，麻烦 yarn setup 一下</aside></blockquote><p>相信使用 Hg 的同学们已经非常熟悉上面这几句话了，我们每次在提交或者拉取代码时总需要手动执行某些命令，实在繁琐。</p><p>但现在已经 2022 年了，难道就没有更好的解决方法吗？</p><p>有的，我们知道，在 Git 有个东西叫做 hooks（钩子），可以在特定事件发生之前或之后执行特定动作。</p><p>同样的，Hg 也有 <a href="https://www.mercurial-scm.org/wiki/hook">hooks</a>，不过并不像 Git 一样生态蓬勃发展，也没有太多现有的开源工具可供大家使用。</p><p>本文就来介绍一下我们从 0 到 1 的 Hg hooks 实践过程，同时也希望能够起到抛砖引玉的作用。</p><h2 id="石器时代"><a href="#石器时代" class="headerlink" title="石器时代"></a>石器时代</h2><p>在没有引入 Hg hooks 之前，我们常常会面对几种情况：</p><ol><li>有同学在提交代码时忘记执行 <code>yarn lint</code>、<code>yarn test</code></li><li>修改了 <code>project-config</code> 的常量，却忘记通知大家，或者有人错过了这条信息。</li></ol><p>这都有可能会导致其他小伙伴拉取代码后，发现页面上的某个功能突然异常，花费一段时间排查才发现原来是没有执行 <code>yarn setup</code>。</p><p>可能有部分同学会想到，那我自定义一个命令在提交或者拉取代码时自动做这件事不就好了吗？</p><p>比如这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; yarn lint &amp;&amp; hg commit -m <span class="string">&quot;xxx&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; hg pull --update &amp;&amp; yarn setup</span><br></pre></td></tr></table></figure><p>这样也不是不行，但是会存在一些问题：</p><ol><li>由于每个人的拉取代码的命令不一样，如果项目开发流程发生变化，则每个人都需要同步修改</li><li>有些同学习惯使用图形化界面，比如 SourceTree、vscode-hg 等，则无法自定义操作命令</li></ol><p>因此，我们另辟蹊径，寻找更好的解决方案。</p><h2 id="青铜时代"><a href="#青铜时代" class="headerlink" title="青铜时代"></a>青铜时代</h2><p>我们最主要想解决的问题就是：</p><ol><li>在提交代码前自动执行 <code>yarn lint</code>、<code>yarn test</code>，不通过则直接终止提交。</li><li>在拉取代码后，检测到如果 project-config 目录发生改动，则自动执行 <code>yarn setup</code>。</li><li>还有更多：<ol><li>检查 commit message 规范</li><li>统一代码的格式化风格</li></ol></li></ol><p>这些都可以通过 Hg hooks 解决，所以开始之前，我们先对 Hg hooks 做一个简单的认识。</p><h3 id="Hg-hooks-介绍"><a href="#Hg-hooks-介绍" class="headerlink" title="Hg hooks 介绍"></a>Hg hooks 介绍</h3><p>Hg hooks 能做什么，这次再介绍一遍：<strong>它可以在特定事件发生之前或之后执行特定动作。</strong></p><p>特定事件，指的就是我们在对 Hg 仓库进行操作时的一些钩子，比如提交前（precommit）、提交后（commit），可以在这里查看全部 hooks 列表：<a href="https://www.mercurial-scm.org/repo/hg/help/hgrc">hooks</a>。</p><p>下面介绍一下如何使用 hook，我们可以通过以下两个文件进行配置：</p><ol><li><code>~/.hgrc</code>：全局的，将对所有 hg 仓库起作用。</li><li> 项目根目录的 <code>.hg/hgrc</code> ：仅对当前仓库起作用。</li></ol><p>比如我们想要实现一个简单的需求：在提交代码前进行 <code>yarn lint</code>。</p><p>首先编辑 <code>.hg/hgrc</code>文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">hooks</span>]</span><br><span class="line"><span class="string">precommit</span> <span class="string">=</span> <span class="string">./bin/hooks/precommit.sh</span> <span class="comment"># 这个路径是相对于项目根目录的</span></span><br></pre></td></tr></table></figure><p>然后编写脚本 <code>bin/hooks/precommit.sh</code>（也可以使用 python）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">yarn lint</span><br><span class="line"></span><br><span class="line"><span class="comment"># lint 没有通过直接退出</span></span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这里需要特别指出，之所以需要重新声明 <code>PATH</code> 变量：</p><ol><li>hooks 脚本的运行环境取决于同学提交代码的地方，比如通过 SourceTree 提交，由于环境不一样，就可能会出现 <code>yarn: command not found</code> 的报错，参见：<a href="https://stackoverflow.com/questions/22883197/git-command-not-found-in-the-custom-action-for-sourcetree">‘Git Command Not found’ in the custom action for SourceTree - Stack Overflow</a>。</li><li>每个同学安装 hg 的方式可能不一样，有通过 brew、pip、甚至自己手动编译的，它们的可执行文件路径不一样。<ul><li>可以通过 <code>which hg</code> 查看这个命令的可执行文件路径。</li></ul></li></ol><p>这样，一个简单的 hook 就配置完成了，这时候提交代码就会触发 <code>precommit.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg commit -m <span class="string">&quot;ci: precommit hooks&quot;</span></span><br><span class="line"></span><br><span class="line">$ eslint <span class="string">&#x27;**/*.js&#x27;</span> --cache --fix</span><br></pre></td></tr></table></figure><p>当 hook 脚本的 exit code 不为 0 的时候，则会终止当前的 Hg 操作，对于某些具有事务性的 hook（e.g. pretxncommit），还会自动进行回滚。</p><p>可以通过以下链接对 Hg hooks 进行更深入地学习：</p><ul><li><a href="https://www.mercurial-scm.org/wiki/hookExamples">hookExamples</a></li><li><a href="https://www.mercurial-scm.org/wiki/Usefulhooks">Usefulhooks</a></li><li><a href="http://hgbook.red-bean.com/read/handling-repository-events-with-hooks.html">Chapter 10. Handling repository events with hooks (red-bean.com)</a></li></ul><h3 id="Hg-hooks-实践"><a href="#Hg-hooks-实践" class="headerlink" title="Hg hooks 实践"></a>Hg hooks 实践</h3><h4 id="提交代码前（precommit）"><a href="#提交代码前（precommit）" class="headerlink" title="提交代码前（precommit）"></a>提交代码前（precommit）</h4><p>这里需要用到的 hook 是 precommit，它的运行时机在提交之前，exit code 非 0 时将终止提交。</p><p> <code>precommit.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SKIP_LINT</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要 lint 的项目</span></span><br><span class="line">apps=(</span><br><span class="line">    <span class="string">&#x27;miniprogram&#x27;</span></span><br><span class="line">    <span class="string">&#x27;dashboard&#x27;</span></span><br><span class="line">    <span class="string">&#x27;core&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;apps[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 判断是否修改该项目，无则跳过 lint</span></span><br><span class="line">    has_change=$(hg status | grep <span class="string">&quot;<span class="variable">$&#123;app&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">continue</span>; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$app</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line">    yarn &amp;&amp; yarn lint</span><br><span class="line"></span><br><span class="line">    <span class="comment"># lint 是否报错，是则直接退出脚本</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对当前修改或新增的文件批量进行 prettier 格式化</span></span><br><span class="line">hg status | grep -E <span class="string">&quot;^(M|A).*.(js|json|wxss)$&quot;</span> | sed <span class="string">&#x27;s|^M||g; s|^A||g&#x27;</span> | xargs ./node_modules/.bin/prettier --write &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>比较浅显易懂，由于是 Monorepo 架构，所以仅针对当前改动的子项目执行 <code>yarn lint</code> ，当 lint 不通过时终止提交；然后仅对当前变更的文件做 prettier 格式化，并且忽略这行命令的输出和错误。</p><p>ps：其实这里的 prettier 机制有点问题，原本的目的是仅格式化当前提交的文件，但 Hg 没有 staging area 的概念，故只能粗暴处理，如果有更好的解决方法欢迎指教。</p><ul><li>hg commit 可以只提交指定的部分文件，所以是有 changed files 和 commited files 两个概念，但是没有找到办法获取 commited files，参见：<a href="https://stackoverflow.com/questions/24565802/mercurial-pre-commit-hook-how-to-tell-apart-changed-and-committed-files">Mercurial pre-commit hook: How to tell apart changed and committed files - Stack Overflow</a></li><li>另一种思路：使用 pretxncommit 钩子，就可通过 $Hg_NODE 变量拿到当前 commit 的信息，但缺点是 pretxncommit 阶段将不能再对文件进行改动，则格式化后需要重新提交一遍。</li></ul><p>随着版本迭代，在 precommit 钩子中增加了检测 utils、test 目录改动则自动执行单元测试 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改以下文件需要执行单元测试</span></span><br><span class="line">apps=(</span><br><span class="line">    <span class="string">&#x27;miniprogram/utils miniprogram/test&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;apps[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    dir=(<span class="variable">$app</span>)</span><br><span class="line">    pass=0</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> d <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;dir[@]&#125;</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">        <span class="comment"># 判断是否修改工具方法、测试用例，无则跳过</span></span><br><span class="line">        has_change=$(hg status | grep <span class="string">&quot;<span class="variable">$&#123;d&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">continue</span>; <span class="keyword">fi</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 同一个项目只执行一次</span></span><br><span class="line">        [ <span class="variable">$pass</span> -eq 1 ] &amp;&amp; <span class="built_in">break</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$d</span>&quot;</span> || <span class="built_in">exit</span> 1</span><br><span class="line">        yarn &amp;&amp; yarn <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># test 是否报错，是则直接退出脚本</span></span><br><span class="line">        <span class="keyword">if</span> [ $? -ne 0 ]; <span class="keyword">then</span> <span class="built_in">exit</span> 1; <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        pass=1</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cd</span> -</span><br><span class="line">    <span class="keyword">done</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="拉取代码后（changegroup）"><a href="#拉取代码后（changegroup）" class="headerlink" title="拉取代码后（changegroup）"></a>拉取代码后（changegroup）</h4><p>主要想解决的问题是：当拉取代码后，检测到 project-config 目录发生变更，则执行 <code>yarn setup</code>。</p><p>首先要解决第一点，如何获取从远端拉取代码所改动的文件？有下面几种方法：</p><ol><li><p><a href="https://backend.bolt80.com/hgdoc/hg-incoming.html">hg incoming</a>：显示远端中的新 commit</p><ul><li>缺点：该方法只是显示新的 commit，后面仍需要再进行一次 pull 才能将新 commit 拉取下来，导致拉取代码时间翻倍。</li></ul></li><li><p><a href="https://backend.bolt80.com/hgdoc/hg-pull.html">hg pull</a>：在拉取代码之后、进行 update 或 rebase 之前，通过 <code>hg log</code> 对比本地 head 和 远端拉取下来的 head。</p></li><li><p>hooks：</p><ol><li>update：工作目录发生改变时，所以只要进行提交、储藏、切换分支都会触发，<strong>不考虑</strong>。</li><li>incoming：每一个新的 commit 被传入时都会触发一次，过于频繁，<strong>不考虑</strong>。</li><li>changegroup：在 push、pull、unbundle 时都会触发，但多个 commit 被传入也只会触发一次，<strong>可考虑</strong>。</li><li>还有一些不太满足的 hooks 不一一介绍了。</li></ol></li></ol><p>在一开始，我们曾尝试使用第二种方法解决该问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">    no_shelve=$(hg shelve | grep <span class="string">&quot;nothing changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hg pull</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 改动文件</span></span><br><span class="line">    regex=<span class="string">&#x27;\bproject-config&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取本次 pull 变更集的改动文件列表，判断是否有改动相关文件</span></span><br><span class="line">    <span class="comment"># @link：https://stackoverflow.com/questions/3277334/what-files-will-be-changed-vs-added-when-i-do-an-hg-pull-and-hg-update</span></span><br><span class="line">    has_change=$(hg <span class="built_in">log</span> --verbose -r .:tip | grep <span class="string">&quot;files:&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$regex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 参考 hg update --rebase 的实现，先尝试 rebase，如果不需要 rebase，则直接 update</span></span><br><span class="line">    <span class="comment"># @link：https://stackoverflow.com/questions/35327163/what-is-the-rebase-command-used-in-hg-pull-rebase</span></span><br><span class="line">    <span class="comment"># @link：https://www.mercurial-scm.org/repo/hg/file/tip/hgext/rebase.py#l2172</span></span><br><span class="line">    has_rebase=$(hg rebase -b . -d <span class="string">&#x27;last(branch(.))&#x27;</span> | grep <span class="string">&quot;nothing to rebase&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_rebase</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg update</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 有改动相关文件，需要执行 yarn setup</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        yarn setup</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果之前有 shelve，需要恢复 shelve</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$no_shelve</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg unshelve</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法可以很好地工作，它可以满足：</p><ul><li>拉取代码时自动储藏、恢复本地改动</li><li>当两端都同时修改 project-config 时，可以 update 或者 rebase 后再统一 <code>yarn setup</code></li></ul><p>后来发现使用 changegroup  hook 配合 <code>hg log</code> 一样可以解决问题，于是就有了 <code>changegroup.sh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改动文件</span></span><br><span class="line">regex=<span class="string">&#x27;\bproject-config&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取本次变更集的改动文件列表，判断是否有改动相关文件</span></span><br><span class="line"><span class="comment"># @see：https://stackoverflow.com/questions/3277334/what-files-will-be-changed-vs-added-when-i-do-an-hg-pull-and-hg-update</span></span><br><span class="line">has_change=$(hg <span class="built_in">log</span> -v -r <span class="variable">$Hg_NODE</span>: | grep <span class="string">&quot;files:&quot;</span> | grep -E <span class="string">&quot;<span class="variable">$regex</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有改动相关文件，需要执行 yarn setup</span></span><br><span class="line"><span class="keyword">if</span> [ ! -z <span class="string">&quot;<span class="variable">$has_change</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">cd</span> $(hg root) || <span class="built_in">exit</span> 1</span><br><span class="line">    yarn setup</span><br><span class="line">    <span class="built_in">cd</span> -</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p> 因此 <code>hgpl</code> 可以精简成这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">    has_shelve=$(hg shelve | grep <span class="string">&quot;nothing changed&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hg pull --rebase</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果之前有 shelve，需要恢复 shelve</span></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$has_shelve</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        hg unshelve</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commit-message-检查（pretxncommit）"><a href="#commit-message-检查（pretxncommit）" class="headerlink" title="commit message 检查（pretxncommit）"></a>commit message 检查（pretxncommit）</h4><p>使用 pretxncommit 钩子可对当前提交信息进行检查，如检查 commit message：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/bin:/opt/homebrew/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$SKIP_LINT</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">shelve_user=<span class="string">&quot;shelve@localhost&quot;</span></span><br><span class="line"></span><br><span class="line">commit_user=$(hg tip --template &#123;user&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为 hg shelve 也会触发 pretxncommit 钩子，所以要进行忽略</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$commit_user</span>&quot;</span> == <span class="string">&quot;<span class="variable">$shelve_user</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">commit_message=$(hg tip --template &#123;desc&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[msg] <span class="variable">$commit_message</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$commit_message</span>&quot;</span> | ./node_modules/.bin/commitlint</span><br></pre></td></tr></table></figure><h2 id="铁器时代？"><a href="#铁器时代？" class="headerlink" title="铁器时代？"></a>铁器时代？</h2><p>这个标题之所以打上一个问号，是因为该方案仍在 POC 阶段，尚未落地实施，但也可作为一个对未来的展望。</p><p>迄今为止，我们的 Hg hooks 已经能够满足大部分场景了，那还存在些什么问题呢？</p><p>相信不少同学已经发现这样操作会存在有一个很明显的问题，那就是：hooks 配置如何同步？</p><p>我们知道 <code>.hg</code> 目录是不会加入版本控制的，这是非常合理且必要的，因为 hooks 本身是一些权限极高的可执行脚本，所以出于安全考虑（你也不想你 clone 一个仓库后，它会自动执行某些你不想执行的命令），<strong>因此是不会有任何一个 VSC 会将 hooks 加入版本控制的。</strong></p><p>可是这就会导致：</p><ol><li>假如项目新增了一个 hook，需要通知项目成员同步修改本地的 hooks 配置。</li><li>新成员加入项目，需要手动配置 hooks。</li></ol><p>如果这个问题不能得到解决，那归根到底还是无法绕过通知项目成员手动操作的过程。</p><p>所幸，以上问题在 Git 中同样存在，并且已经有很多非常成熟的方案，如： <a href="https://github.com/typicode/husky">huksy</a>、<a href="https://pre-commit.com/">pre-commit</a> 。</p><p>那有没有人在 Hg 生态上解决这个问题呢？粗略找到了两个：</p><ol><li><a href="https://github.com/TobiasTimm/husky-hg">husky-hg</a></li><li><a href="https://github.com/theylom/tdog-husky-hg">tdog-husky-hg</a>（前者的 fork</li></ol><p>都是基于 husky <a href="https://github.com/tobiastimm/husky-hg/commit/fcd100f4f1a7bdf04c05f51ddd80af9f87687ddc#diff-7ae45ad102eab3b6d7e7896acd08c427a9b25b346470d7bc6507b6481575d519R2">v0.14.3</a> 改造的，最后提交时间都在三年前（2019），然而 husky 现在已经迭代到 <a href="https://github.com/typicode/husky/releases/tag/v7.0.4">v7</a> 版本了，这 3 年间经过无数迭代，使用方式和实现原理都发生翻天覆地的变化，于是我们决定基于 husky v7 自行改造。</p><p>但是在此之前，我们先了解一下 Git 如何配置 hooks：</p><ol><li>在以前的 Git 版本中，如果要配置一个 hooks 则需要在 <code>.git/hooks</code> 目录新增一个 hook 同名的可执行文件，并且出于前面说的安全考虑， <code>.git</code>  目录是不会被加入版本控制的，<strong>因此也存在上面所说的问题</strong>。</li><li>在 Git v2.9 以后，支持通过配置 core.hooksPath 自定义项目的 hooks 的存放路径，也即意味着可将 hooks 加入版本控制，项目成员只需要在第一次配置 core.hooksPath 即可，后续增删 hooks 都可直接使用。</li></ol><p>因为 Git 支持 core.hooksPath ，所以 husky 直接采用了新的实现原理重构：</p><ol><li><p>在 huksy v4 的时候，由于 Git hooks 目录无法被加入版本控制，它们是这样解决这个问题的：</p><ol><li>在初始化的时候就在 <code>.git/hooks</code> 目录预先创建所有的 hooks 可执行文件，然后在 hooks 文件中执行定义在 <code>package.json</code> 中的 hooks 命令。</li><li> 这样很显然可以解决 hooks 无法同步的问题，但是这个实现原理也被不少人诟病，见 <a href="https://github.com/typicode/husky/issues/260">#260</a> 。</li></ol></li><li><p>由于 Git v2.9 的升级，在 husky v7 中使用了新的实现方式：</p><ol><li>将 hooks 可执行文件存放在一个可以被进行版本控制的目录（默认是 <code>.husky</code>），然后初始化的时候只需要配置  core.hooksPath 即可。</li></ol></li></ol><p>显然，v7 的实现方式更加方便快捷了，除此之外，它们的使用方式也有很大的不同：</p><ol><li>在 v4 中，通过在 <code>package.json</code>  中配置 <code>husky</code> 字段来定义 hooks。</li><li>在 v7 中，<strong>它不再仅限于 Node.js 项目</strong>，可以直接通过 CLI 的方式进行配置，参见：<a href="https://blog.typicode.com/husky-git-hooks-javascript-config/">Why husky has dropped conventional JS config</a>。</li></ol><p>在深入了解背后的实现原理后，我们得出了结论：</p><ol><li>v4 版本的代码<strong>有较多历史包袱，不利于改造，故基于 v7 版本修改</strong>。</li><li>但 v7 版本的实现方式对 Hg 并不完全适用，所以需要继续沿用 v4 的部分实现方式，所以这样设计：<ol><li>将 hooks 脚本存放在可被版本控制的 <code>.husky</code> 目录</li><li>但不通过预注册所有的 hooks 的方式，而是采用按需配置，初始化时根据 <code>.husky</code> 的 hooks 可执行文件列表注入 hooks 配置。<ol><li>比如在 Node.js 项目中可以通过 npm 的 <a href="https://docs.npmjs.com/cli/v8/using-npm/scripts#prepare-and-prepublish">prepare</a> 钩子来自动初始化。</li></ol></li></ol></li><li>因此，使用方式与 husky <a href="https://typicode.github.io/husky/">文档</a> 中基本一致。<ol><li><code>husky install</code>、<code>husky add .husky/pre-commit</code></li></ol></li></ol><p>以上的心路历程、改造进展可以通过这个 <a href="https://github.com/gd4Ark/husky/pull/1">PR</a> 查看，感兴趣的同学可自行尝试：</p><ol><li>clone 项目，安装依赖，执行 npm link。</li><li>参考  husky <a href="https://typicode.github.io/husky/">文档</a> 进行使用。</li></ol><h2 id="背后的一些二三事"><a href="#背后的一些二三事" class="headerlink" title="背后的一些二三事"></a>背后的一些二三事</h2><p>最后分享一些我们在实践 Hg hooks 时的小插曲。</p><h3 id="一个隐藏字符引发的前端事故"><a href="#一个隐藏字符引发的前端事故" class="headerlink" title="一个隐藏字符引发的前端事故"></a>一个隐藏字符引发的前端事故</h3><p>有一天下午，在群里收到这么一个反馈：</p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203191549957.jpg"  alt="2471647676117_.pic" style="margin-left: 0;" /><p>点开大图一看，好家伙！赫然一个「口」字就这么明目张胆地贴在页面的左下角，看它「浓眉大眼」的。</p><p>到底是哪里出了问题呢？</p><p>仔细看清楚，才发现它其实不是一个「口」字，而是「□」，学名叫做 <a href="https://zh.wikipedia.org/zh-hans/%E8%99%9A%E7%BC%BA%E5%8F%B7">虚缺号</a>，通俗地讲就是一个特殊字符。</p><p>于是打开对应的代码文件，果然一个红底白色 BS 字符引入眼帘：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202204042021847.png"></p><h4 id="这是-VSCode-的锅？"><a href="#这是-VSCode-的锅？" class="headerlink" title="这是 VSCode 的锅？"></a>这是 VSCode 的锅？</h4><p>在网上有一番搜寻后，发现早就已经有不少人遇到过这个问题：</p><ul><li><a href="https://github.com/wangduanduan/wangduanduan.github.io/issues/158">vscode控制字符引起的问题以及解决思路</a></li><li><a href="https://jiangxiaokun.com/css/2018/11/15/ghost_chars/">隐藏字符引发的血案</a></li></ul><p>看下他们提供的复现过程：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203191703719.gif" alt="hmmm"></p><p>直接说下这个 Bug 的结论：</p><ol><li>VSCode 开启 webview 的情况下，使用中文输入法时按下退格键，就会导致出现退格符。</li><li>VSCode 底层是 Electron，Electron 底层用的 chromium，这个 BUG 是 chromium 的。</li><li>该 BUG 已经在 VSCode v1.4.0 得到修复，参见这个 <a href="https://github.com/microsoft/vscode/issues/37114#issuecomment-544236959">issue</a>。</li></ol><p>但既然该问题在 2019 年已经修复，那为什么在 2022 年的今天还会出现这个退格符呢？</p><p>由于已经复现不了，根源追求也就只能不了了之，但影响又如此之大，所以我们应该怎么去规避它呢？</p><h4 id="规避方案"><a href="#规避方案" class="headerlink" title="规避方案"></a>规避方案</h4><h5 id="利用-VSCode-扩展自动删除"><a href="#利用-VSCode-扩展自动删除" class="headerlink" title="利用 VSCode 扩展自动删除"></a>利用 VSCode 扩展自动删除</h5><p>有一个 VSCode 扩展 <a href="https://github.com/satokaz/vscode-bs-ctrlchar-remover">Remove backspace control character</a> 专门用于解决此类问题，安装后我们只需要在 setting.json 添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;[wxml]&quot;</span>: &#123;</span><br><span class="line">  <span class="attr">&quot;editor.formatOnSave&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;editor.defaultFormatter&quot;</span>: <span class="string">&quot;satokaz.vscode-bs-ctrlchar-remover&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可在保存代码的时候自动移除这些特殊的隐藏字符。</p><p>实现方式主要是通过正则去匹配这类隐藏字符：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/[\u0000]|[\u0001]|[\u0002]|[\u0003]|[\u0004]|[\u0005]|[\u0006]|[\u0007]|[\u0008]|[\u000b]|[\u000c]|[\u000d]|[\u000e]|[\u000f]|[\u0010]|[\u0011]|[\u0012]|[\u0013]|[\u0014]|[\u0015]|[\u0016]|[\u0017]|[\u0018]|[\u0019]|[\u001a]|[\u001b]|[\u001c]|[\u001d]|[\u001e]|[\u001f]|[\u001c]|[\u007f]/gm</span><br></pre></td></tr></table></figure><p>在这里查看所有字符的介绍：<a href="https://www.techonthenet.com/unicode/chart.php">Unicode</a>，本文所出现的 BS 正是 [\u0008]，也就是退格符。</p><h5 id="提交代码前自动删除"><a href="#提交代码前自动删除" class="headerlink" title="提交代码前自动删除"></a>提交代码前自动删除</h5><p>更好的方式是：我们可以在 precommit 钩子自动做这件事：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find . -name <span class="string">&quot;*.wxml&quot;</span> -<span class="built_in">exec</span> perl -i -p -e <span class="string">&quot;s/[\x08]//g&quot;</span> &#123;&#125; +</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这行命令的 time total</span></span><br><span class="line">0.10s user 0.80s system 93% cpu 0.953 total</span><br></pre></td></tr></table></figure><h3 id="让-vscode-hg-提交代码时显示-ESLint-报错的规则"><a href="#让-vscode-hg-提交代码时显示-ESLint-报错的规则" class="headerlink" title="让 vscode-hg 提交代码时显示 ESLint 报错的规则"></a>让 vscode-hg 提交代码时显示 ESLint 报错的规则</h3><p>起因是某位同学反映在 vscode-hg 提交代码的时候，无法显示 ESLint 校验不通过的规则提示：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203201415448.png" alt="image-20220320141520784"></p><p>通常我们提交代码时，如果 yarn lint 不通过，会输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ eslint <span class="string">&#x27;**/*.js&#x27;</span> --cache --fix</span><br><span class="line"></span><br><span class="line">/Users/4ark/project/helper/404.js</span><br><span class="line">  9:7  error  <span class="string">&#x27;a&#x27;</span> is assigned a value but never used  no-unused-vars</span><br><span class="line"></span><br><span class="line">✖ 1 problem (1 error, 0 warnings)</span><br><span class="line"></span><br><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br><span class="line">info Visit https://yarnpkg.com/en/docs/cli/run <span class="keyword">for</span> documentation about this <span class="built_in">command</span>.</span><br><span class="line">abort: pre-commit hook exited with status 1</span><br></pre></td></tr></table></figure><p>而 vscode-hg 只输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error Command failed with <span class="built_in">exit</span> code 1.</span><br><span class="line">abort: pre-commit hook exited with status 1</span><br></pre></td></tr></table></figure><p>不过经测试在 VSCode 中进行 Git 代码提交时并不存在该问题，所以猜测是 vscode-hg 这个扩展的原因。</p><p>于是抱着怀疑的态度看一下源码，发现果然如此：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/hg.ts#L620</span></span><br><span class="line"><span class="keyword">if</span> (options.logErrors !== <span class="literal">false</span> &amp;&amp; result.stderr) &#123;</span><br><span class="line">    <span class="built_in">this</span>.log(<span class="string">`<span class="subst">$&#123;result.stderr&#125;</span>\n`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只输出了 stderr，但是 ESLint 的规则输出是 stdout。</p><p>于是我们为了更好地使用 Hg hooks，让它支持了输出 ESLint 规则，见 <a href="https://github.com/mrcrowl/vscode-hg/issues/185">#185</a>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上就是我们在实践 Hg hooks 过程的一些经历和心得，未必是最佳解决方案，正如文本开头所说，撰写本文的目的是希望能起到抛砖引玉的作用，与大家一起进一步的深入探讨。</p><p>对于本文的实践思路、代码实现有任何的意见和建议，都请不吝指教。</p><p>最后感谢大家的阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;故事的开始&quot;&gt;&lt;a href=&quot;#故事的开始&quot; class=&quot;headerlink&quot; title=&quot;故事的开始&quot;&gt;&lt;/a&gt;故事的开始&lt;/h2&gt;&lt;blockquote&gt;
&lt;aside&gt; 💬 提交代码前记得 lint&lt;/aside&gt;
&lt;aside&gt; 💬 又有人没跑</summary>
      
    
    
    
    
    <category term="vcs" scheme="https://4ark.me/tags/vcs/"/>
    
    <category term="hg" scheme="https://4ark.me/tags/hg/"/>
    
  </entry>
  
  <entry>
    <title>周刊第4期：独立思考</title>
    <link href="https://4ark.me/post/weekly-04.html"/>
    <id>https://4ark.me/post/weekly-04.html</id>
    <published>2022-03-12T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本周做了啥"><a href="#本周做了啥" class="headerlink" title="本周做了啥"></a>本周做了啥</h2><p>给日常使用的 <a href="https://github.com/mrcrowl/vscode-hg">vscode-hg</a> 扩展提了两个没什么技术含量的 PR，顺便蹭了一个 contributor：</p><ul><li><a href="https://github.com/mrcrowl/vscode-hg/pull/184">docs: typo lineAnnotationEnabled option</a></li><li><a href="https://github.com/mrcrowl/vscode-hg/pull/185">feat: output stdout</a></li></ul><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="useMemo-和-useCallback-之间的深入比较"><a href="#useMemo-和-useCallback-之间的深入比较" class="headerlink" title="useMemo 和 useCallback 之间的深入比较"></a><a href="https://www.chakshunyu.com/blog/a-deep-dive-comparison-between-usememo-and-usecallback/">useMemo 和 useCallback 之间的深入比较</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/a-deep-dive-comparison-between-usememo-and-usecallback/">《A Deep Dive Comparison Between useMemo And useCallback》 | Technical Blog</a></em></p><ul><li>它们的目的：都是通过缓存提高性能，避免组件重复渲染</li><li>相似之处：<ul><li>用法一致：与所有 hooks 一样，只能在组件的顶层调用</li><li>接收的参数一致：第一个为函数，第二个为依赖项</li><li>功能一致：返回缓存过的值，检测到依赖性发生时重新计算并缓存</li></ul></li><li>区别：<ul><li>它们表面上没有真正的区别</li><li>它们的内部实现也基本一致</li><li>使用场景的区别：<code>useCallback</code> 缓存函数，而 <code>useMemo</code> 缓存其它类型</li><li>实现原理的区别：<code>useCallback</code> 是缓存函数本身，而 <code>useMemo</code> 是缓存函数的返回值。</li></ul></li></ul><p>以下是它们的实现方式：</p><ul><li>useCallback</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>useMemo</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateCallback</span>&lt;<span class="title">T</span>&gt;(<span class="params">callback: T, deps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="keyword">void</span> | <span class="literal">null</span></span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hook = updateWorkInProgressHook();</span><br><span class="line">  <span class="keyword">const</span> nextDeps = deps === <span class="literal">undefined</span> ? <span class="literal">null</span> : deps;</span><br><span class="line">  <span class="keyword">const</span> prevState = hook.memoizedState;</span><br><span class="line">  <span class="keyword">if</span> (prevState !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextDeps !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevDeps: <span class="built_in">Array</span>&lt;mixed&gt; | <span class="literal">null</span> = prevState[<span class="number">1</span>];</span><br><span class="line">      <span class="keyword">if</span> (areHookInputsEqual(nextDeps, prevDeps)) &#123;</span><br><span class="line">        <span class="keyword">return</span> prevState[<span class="number">0</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hook.memoizedState = [callback, nextDeps];</span><br><span class="line">  <span class="keyword">return</span> callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="初级开发人员如何为新团队提供价值"><a href="#初级开发人员如何为新团队提供价值" class="headerlink" title="初级开发人员如何为新团队提供价值"></a><a href="https://www.chakshunyu.com/blog/how-you-as-a-junior-developer-can-immediately-provide-value-when-joining-a-team/">初级开发人员如何为新团队提供价值</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/how-you-as-a-junior-developer-can-immediately-provide-value-when-joining-a-team/">《How You As a Junior Developer Can Immediately Provide Value When Joining a Team》 | Technical Blog</a></em></p><ul><li><strong>初级开发人员并不意味着不能提供价值：</strong>相反，初级开发人员可以给团队带来很多东西。</li><li><strong>质疑现状：</strong>如果一个团队长期合作，人们会开始接受彼此的缺点，习惯于某种风格和工作方式，也就会陷入舒适区，这可能会使团队停滞不前。所以你需要保持批判性，寻找团队懒惰、坏习惯、效率低下或者可以改进的地方，并且付诸行动去改变现状。</li><li><strong>新鲜血液：</strong>任何一个项目组都不可能每时每刻使用最新的技术、工具，可能会使得团队成员没有动力跟上最先进的技术，陷入一种恶性循环之中。你作为一个团队的新成员，可能你反而会在当前领域了解更多最先进的技术和工具，从而打破团队的恶性循环。</li><li><strong>意识到团队沟通的问题：</strong>长期合作的团队可能面临习惯现有的沟通方式，会自动忽略对方的缺陷，导致缺乏真正的沟通。而你能够意识到这些问题，并帮助团队提高这方面的效率。</li><li><strong>挑战团队现有的知识</strong>：每个团队内部都有一些的解决方案或流程，并且习惯于此，而你可以提出更多潜在的替代方案，帮助团队寻找更优的解决方案。</li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>作为一名初级开发人员可能认为自己只能负责最简单的一部分业务，并没有意识到自己能给团队带来这么多价值，但其实你可以通过你作为一个新成员的位置，去发现你刚加入的团队一些不好的习惯，通过正确的心态和行动去改变现状。</p><h3 id="你的代码不必完美无缺"><a href="#你的代码不必完美无缺" class="headerlink" title="你的代码不必完美无缺"></a><a href="https://www.chakshunyu.com/blog/your-code-doesnt-have-to-be-perfect/">你的代码不必完美无缺</a></h3><p><em>原文地址：<a href="https://www.chakshunyu.com/blog/your-code-doesnt-have-to-be-perfect/">《Your Code Doesn’t Have to Be Perfect》 | Technical Blog</a></em></p><p>作者通过一段经历，讲述他在实现某个功能时，由于想要实现最佳的解决方案，一开始就花费了大量的时间去进行完美的设计、抽象和封装，结果一个星期的时间没有任何真正的业务产出。</p><p>以下是作者一些教训：</p><ul><li><strong>不要从开始就重构：</strong>不需要刚开始就寻找最优的实现方式，这会让你过早地陷入到某个细节当中，把大量的时间花费在无意义的抽象中。</li><li><strong>复制粘贴还不错：</strong>我们应该坚持 DRY（不要重复你自己），但这不应该是起点，而是最终目标。可以在刚开始时通过复制粘贴实现功能，但这不意味着它就是最终上线的代码，而是在这个功能工作之后，再通过重构来提高代码质量。</li><li><strong>真正的重构需要适当的知识：</strong>通过改进现有的代码会使你的重构过程更加高效，因为这时候你已经掌握了更多的信息，可以更好地了解哪些代码是有意义的抽象。</li></ul><h4 id="个人思考-1"><a href="#个人思考-1" class="headerlink" title="个人思考"></a>个人思考</h4><p>每个开发者都经历过这个阶段，想要一开始就设计好所有的细节、编写最完美的代码，但这是不可能的，所有代码都是经过不断地重构。你的代码不必在一开始就完美无缺，在生产项目中更是如此，毕竟不存在没有 deadline 的项目，只要懂得这个道理，你的工作效率会大大提高。</p><h3 id="关于编写可读代码的最重要的事情"><a href="#关于编写可读代码的最重要的事情" class="headerlink" title="关于编写可读代码的最重要的事情"></a><a href="https://www.chakshunyu.com/blog/the-most-important-thing-i-learned-about-writing-readable-code/">关于编写可读代码的最重要的事情</a></h3><p>原文地址：<a href="https://www.chakshunyu.com/blog/the-most-important-thing-i-learned-about-writing-readable-code/">《The Most Important Thing I Learned About Writing Readable Code》</a></p><p>编写代码时最重要的是可读性，一段难以理解的代码，即使你已经知道它的目的，你也很难理解它。所以编写具有可读性的代码是非常必要的。</p><p>已经有非常多的经典书籍在探讨这个话题，例如：</p><ul><li>《代码大全》</li><li>《重构》</li><li>《代码整洁之道》</li></ul><p>本文作者之前也写过几篇关于代码可读性的文章，不过我认为大部分已经是老生常谈了：</p><ul><li><a href="https://blog.logrocket.com/write-more-readable-react-code/">《如何编写更具可读性的 React 代码》</a><ul><li><strong>代码长度：</strong>更短的代码通常更容易阅读，但有时候并非如此。所以要根据场景，代码并不是越短越好。</li><li><strong>代码分组：</strong>将特定上下文的代码组合在一起，使得阅读性更高。React 的自定义组件、Hook 就是做这件事情。</li><li><strong>复杂的 JavaScript 结构：</strong>不是所有人都完全熟悉 JavaScript 的语言特性，如果依赖某些特性的固定或隐式行为，会使某些对 JavaScript 不太熟悉的开发人员难以理解这些代码。作者还特地拿 <code>Array.reduce</code> 来举了个例子，认为使用 <code>Array.reduce</code> 虽然可以让代码更加紧凑，但内部需要跟踪太多细节，如果直接使用 <code>for-loop</code> 会使代码更具有可读性。</li><li><strong>条件运算符 &amp;&amp;：</strong>这种短路的隐式行为没有 if-else 的可读性高。</li><li><strong>一次处理多种情况：</strong>例如在同一个 <code>useEffect</code> 处理多个 deps，会使代码更加混乱。</li><li><strong>变量命名：</strong>计算机两大难题之一，这个命题有点大。</li></ul></li></ul><ul><li><a href="https://www.chakshunyu.com/blog/6-concrete-tips-that-will-make-your-react-pull-requests-easier-to-review/">《6 个技巧使你的 PR 更容易被 Review》</a><ul><li><strong>PR 的用途</strong>：Why、How</li><li><strong>分享视觉变化的屏幕截图</strong>：根据代码变更很难想象视觉的变化，所以展示一个截图可以帮助 Reviewer 更快地知道界面变化。</li><li><strong>列出功能要求</strong>：列出你想要实现的功能预期，否则很难通过代码上下文去预测你的实现是否正确、或者还有更优的解决方案。</li><li><strong>列出新的依赖</strong>：如果新增了依赖，你是如何决定采用哪一个库的。</li><li><strong>避免复杂的代码实现</strong></li><li><strong>提供有关如何 Review 的其他说明</strong>：告诉 Reviewer 从哪里开始 Review。</li></ul></li></ul><ul><li><a href="https://www.chakshunyu.com/blog/this-is-my-10-questions-react-code-reviewing-routine/">《帮助你对 React 代码进行 Review 的 10 个问题》</a><ul><li>代码是否正常工作？</li><li>我明白了发生了什么吗？</li><li>代码是否可读？</li><li>组件或 Hook 是否做得太多？</li><li>这必须是组件或者 Hook 吗？</li><li>这个 API 设计可以简化吗？</li><li>有测试吗？</li><li>测试有意义吗？</li><li>这个功能的辅助功能方面如何？</li><li>是否更新了相应的文档？</li></ul></li></ul><p>但作者认为有一件更重要的事情被忽略了，那就是：<strong>沟通。</strong></p><p>每个人对于「代码是否具有可读性」的理解都不一样，所以日常中经常会出现下面这种对话：</p><ul><li>“你觉得这段代码非常难以阅读，但我认为它很容易。”</li><li>“我不同意，我经常使用这种实现方式，但理解它并没有难度。”</li><li>“使用这种方式实现，而不是你提供的那种方式实现，意味着我们不需要担心 xxx，可以使代码更短。”</li></ul><p>这种回答并非完全没有道理的，但它们都有共同点：<strong>他们之所以不同意使用这种实现会使代码可读性更差，是因为他们觉得自己能够理解这样的代码。</strong></p><p>的确，他们确实非常熟悉这段代码是如何工作的，但他们搞错了一件事：<strong>他们认为我是因为理解不了这段代码，才觉得这段代码难以阅读。</strong></p><p>然而事实并非如此，因为问题的根本在于：<strong>代码的可读性与你无关，而是与其他人有关，准确地说，是与未来接手这段代码的人有关，甚至这个人很可能就是六个月后的自己。</strong></p><p>所以，你要为他们编写具有可读性的代码。</p><h4 id="个人思考-2"><a href="#个人思考-2" class="headerlink" title="个人思考"></a>个人思考</h4><p>首先我需要说明，我并不认同作者提到的「 <code>for-loop</code> 可读性比 <code>Array.reduce</code> 好」这个结论，我认为 <code>Array.reduce</code> 与 <code>forEach</code>、<code>map</code> 这些标准方法并无不同，不是 JavaScript 的糟粕，甚至是精华部分；另外 <code>Array.reduce</code>  真正需要考虑的细节也不多，只要熟悉递归思想，它其实很好理解。</p><p>除此之外的大部分观点我都是非常认同的，特别是本文讲到的「沟通」二字。我曾待过一个团队，当时合并代码前是需要两人交叉 Review 的，也遇到过几次关于「这样实现的可读性好不好」的问题展开讨论，基本都是各执一词，往往这种时候都需要一个第三者来进行判断，由这个人决定采用哪一种实现。</p><p>还记得有一次更离谱，某位同学酷爱使用位运算符，他对此给出的理由是：这样实现会使代码更快。</p><p>首先我并不认同这种说法，因为他没有给出专业的对比分析，即便这是真的，但在我们负责的这种 Web 项目中，这种速度的提升简直是可以忽略不计的，所以我就「可读性」本身这件事与他讨论，结果他开始和我解释这个位运算符是如何工作的，这位同学就犯了上面提到的问题，其实我不是不理解位运算符如何工作，我还曾写过一篇《<a href="https://4ark.me/post/learn-bitwise-operators.html">深入理解按位操作符</a>》的文章，我只是单纯认为不应该在项目中使用位运算符罢了。</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://www.aisixiang.com/">爱思想</a>：华语圈内最具原创性和思想性的公益纯学术网站，有人文社科各领域、人品和作品均有一定高度的学者的大量访谈记录、论文等，可帮助你提高独立思考的能力。</li></ul><ul><li><a href="https://www.allhistory.com/">全历史</a>：在全历史 App 或网站里，你可以按照时间轴、关系图谱、时间地图查看各国，各个历史时期的历史相关内容。</li></ul><ul><li>在信息爆炸的今天，充斥着大量的虚假信息，这里推荐一些事实核查网站帮助你快速辨别信息真伪：<ul><li><a href="https://chinafactcheck.com/">有据</a></li><li><a href="https://tfc-taiwan.org.tw/">台湾事实核查中心</a></li><li><a href="https://www.politifact.com/">PolitiFact</a></li><li><a href="https://www.truthorfiction.com/">Truth or Fiction</a></li><li><a href="https://www.factcheck.org/">FactCheck.org</a></li><li><a href="https://factcheck.afp.com/">Fact Check</a></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;本周做了啥&quot;&gt;&lt;a href=&quot;#本周做了啥&quot; class=&quot;headerlink&quot; title=&quot;本周做了啥&quot;&gt;&lt;/a&gt;本周做了啥&lt;/h2&gt;&lt;p&gt;给日常使用的 &lt;a href=&quot;https://github.com/mrcrowl/vscode-hg&quot;&gt;vsco</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>周刊第3期：持续折腾</title>
    <link href="https://4ark.me/post/weekly-03.html"/>
    <id>https://4ark.me/post/weekly-03.html</id>
    <published>2022-03-06T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新文章"><a href="#新文章" class="headerlink" title="新文章"></a>新文章</h2><p>之前一直都有在写小抄的习惯，于是抽空整理了一下发到 Blog 上，希望能够帮助通过搜索引擎进来的同学们。</p><ul><li>《<a href="https://4ark.me/post/git-tips.html">Git tips</a>》</li><li>《<a href="https://4ark.me/post/hg-tips.html">Hg tips</a>》</li></ul><h2 id="折腾-iTerm2-tmux"><a href="#折腾-iTerm2-tmux" class="headerlink" title="折腾 iTerm2 + tmux"></a>折腾 iTerm2 + tmux</h2><p>很早之前就安装了 tmux，但是苦于一直记不住命令，也就没有坚持用。</p><p>不过其实 iTerm2 已经整合了 tmux，可以将 tmux 的各种命令操作映射到 iTerm2 本身的快捷键操作中，这可以大大降低 tmux 的学习成本，于是花了点时间折腾、以及 iTerm2 的外观调整，整体效果是这样的：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202203050038886.png?imageMogr2/format/webp"></p><p>主要参考以下这两篇文章：</p><ul><li><a href="https://toutiao.io/posts/q86tnu/preview">iTerm2 整合 Tmux 利器</a></li><li><a href="https://haidong.dev/iTerm2%20%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/">iTerm2 设置详解</a></li></ul><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="解剖-Netflix"><a href="#解剖-Netflix" class="headerlink" title="解剖 Netflix"></a><a href="https://lanzhiheng.com/posts/no-rule-in-netflix">解剖 Netflix</a></h3><p><em>原文地址：<a href="https://lanzhiheng.com/posts/no-rule-in-netflix">《解剖 Netflix - 全美员工满意度最高的企业》 | Step By Step</a></em></p><p>这是本文作者从一本叫做《零规则》的书的笔记，主要讲述一家名为 Netflix 的科技公司的经营传奇。</p><p>这家公司是全美员工满意度最高的公司，而「零规则」这几个字，也正是 Netflix 的核心文化之一。</p><p>下面就来讲讲 Netflix 的不同之处：</p><ul><li><p>「零规则」并不是完全没有规则：「零规则」不代表 Netflix 是一家毫无规则的公司，它也有解雇员工的准则，而且可能比其他公司都要狠，甚至连 CEO 都能被解雇；它的零规则指的是它不会花时间制定考勤、打卡、费用报销、上班时长等细则，因为 Netflix 相信自己招聘的肯定是最出色的员工，否则，他们也无法在如此严苛的岗位筛选中存活下来。</p></li><li><p>行业的最高薪资：只招揽最优秀的人才，并且没有固定的涨薪幅度，而是鼓励员工出去面试，根据拿到的 offer 给予对应的涨幅。</p></li><li><p>同事不是家人：许多企业会宣称我们是一个大家庭、同事们都是家人。而 Netflix 认为同事是合作伙伴，而不是家人，因为如果在公司里大家都以家人相称反而会导致不能作出正确的决策。</p></li><li><p>以 Netflix 最大利益为考量：Netflix 采用树形的决策模式，底层员工不需要凡事去请示上司，因为自己才是决定这件事的最佳人选，Netflix 认为员工不会因为这个决定让自己蒙羞。</p></li><li><p>无休假规定也没有固定的工作时长：如果一个人用工作时长的一半就完成了他的工作，剩下的时间他选择阳光海滩。而另一个人每天加班加点，超时工作才能把事情做完，果断给第一个人加工资。</p></li><li><p>信息透明：没有「报喜不报忧」的潜规则，Netflix 认为自家员工都是成年人，有能力辨别什么能说什么不能说。</p></li></ul><h3 id="在生产环境中使你的-npm-i-速度提升-50"><a href="#在生产环境中使你的-npm-i-速度提升-50" class="headerlink" title="在生产环境中使你的 npm i 速度提升 50%"></a><a href="https://shanyue.tech/frontend-engineering/npm-install.html">在生产环境中使你的 npm i 速度提升 50%</a></h3><p><em>原文地址：<a href="https://shanyue.tech/frontend-engineering/npm-install.html">《在生产环境中使你的 npm i 速度提升 50%》 | 山月行</a></em></p><ul><li>选择时延低的 <code>registry</code>，需要企业技术基础建设支持</li><li><code>NODE_ENV=production</code>，只安装生产环境必要的包(如果 dep 与 devDep 没有仔细分割开来，工作量很大，可以放弃)</li><li><code>CI=true</code>，npm 会在此环境变量下自动优化</li><li>结合 CI 的缓存功能，充分利用 <code>npm cache</code></li><li>使用 <code>npm ci</code> 代替 <code>npm i</code>，既提升速度又保障应用安全性</li></ul><h3 id="浅析-Web-录屏技术方案与实现"><a href="#浅析-Web-录屏技术方案与实现" class="headerlink" title="浅析 Web 录屏技术方案与实现"></a><a href="https://www.zoo.team/article/webrtc-screen">浅析 Web 录屏技术方案与实现</a></h3><p><em>原文地址：<a href="https://www.zoo.team/article/webrtc-screen">《浅析 Web 录屏技术方案与实现》 | zoo</a></em></p><ul><li><p>有感录屏：</p><ul><li><p>有感录屏一般指通过获得用户的授权或者通知用户接下来的操作将会被录制成视频，并且在录制过程中，用户有权关闭中断录屏。即无论在录屏前还是录屏的过程中，用户都始终能够决定录屏能否进行。</p></li><li><p>实现方式：WebRTC。</p></li></ul></li><li><p>无感录屏</p><ul><li><p>无感录屏指在用户无感知的情况，对用户在页面上的操作进行录制。实现上与有感录制区别在于，无感录制通常是利用记录页面的 DOM 来进行录制。常见的有 canvas 截图绘制视频和 rrweb 录制等方案。</p></li><li><p>实现方式：</p><ol><li>canvas</li><li>rrweb</li></ol></li></ul></li></ul><h4 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h4><p>rrweb 的话只是对 SPA 场景比较好，但对于 微前端/Iframe 场景，它基于 DOM 的回溯就会失效从而失去其录制功能，加上整个 rrweb 链路代码实现复杂度较高，个人认为能用 WebRTC 还是走 RTC 实现比较好。</p><h3 id="如何为你的问题获得有用的答案"><a href="#如何为你的问题获得有用的答案" class="headerlink" title="如何为你的问题获得有用的答案"></a><a href="https://jvns.ca/blog/2021/10/21/how-to-get-useful-answers-to-your-questions/">如何为你的问题获得有用的答案</a></h3><p><em>原文地址：<a href="https://jvns.ca/blog/2021/10/21/how-to-get-useful-answers-to-your-questions/">《How to get useful answers to your questions》 | Julia Evans</a></em></p><ol><li>问一个模糊或未明确指定的问题时，可能出现的问题：<ol><li>这个人首先解释一堆我已经知道的东西</li><li>这个人解释了一些我不知道的事情，但我认为这些事情与我的问题无关</li><li>这个人开始给出相关的解释，但使用我不理解的术语，所以我仍然最终感到困惑</li></ol></li><li>通过问「是否」的问题，可以更快地得到有用的信息。</li><li>如果别人做了一个漫长而无关紧要的解释，可以直接打断</li><li>不接受没有回答你的问题的答案</li></ol><h3 id="谈谈在SQL语句中的优化技巧"><a href="#谈谈在SQL语句中的优化技巧" class="headerlink" title="谈谈在SQL语句中的优化技巧"></a><a href="https://qq52o.me/696.html">谈谈在SQL语句中的优化技巧</a></h3><p><em>原文地址：<a href="https://qq52o.me/696.html">《谈谈在SQL语句中的优化技巧》 | qq52o</a></em></p><p>此文一共列了 30 个优化技巧，内容已经比较精炼了，这里我就不一一列出，有兴趣直接进原文阅读。</p><h3 id="求职时的常见错误"><a href="#求职时的常见错误" class="headerlink" title="求职时的常见错误"></a><a href="https://1byte.io/resume-mistakes/">求职时的常见错误</a></h3><p><em>原文地址：<a href="https://1byte.io/resume-mistakes/">《求职时的常见错误》 | 1 Byte</a></em></p><ul><li>细节：对待简历要认真，一个连简历都不重视细节的人，可想而知在工作中有多马虎。</li><li>精通：慎重「精通」二字，除非你有自信比面试官更熟悉它。</li><li>面试：遇到不会的难题，不要轻易放弃，面试官想要看到的是你如何解决问题。</li></ul><h3 id="如何在-Emacs-里做所有事"><a href="#如何在-Emacs-里做所有事" class="headerlink" title="如何在 Emacs 里做所有事"></a><a href="https://1byte.io/how-to-do-everything-in-emacs/">如何在 Emacs 里做所有事</a></h3><p><em>原文地址：<a href="https://1byte.io/how-to-do-everything-in-emacs/">《如何在 Emacs 里做所有事》| 1 Byte</a></em></p><p>Emacs 简直堪称是一个操作系统，之前有研究过使用 Emacs 下面的 Org-mode 插件来做我的内容管理系统，但是折腾了一下觉得太难上手了，于是转向使用 Notion。</p><p>而本文中的视频就展示了 Emacs 的 Org-mode 强大，有兴趣可以看看。</p><h3 id="小程序单元测试最佳实践"><a href="#小程序单元测试最佳实践" class="headerlink" title="小程序单元测试最佳实践"></a><a href="https://wxsm.space/2021/unit-test-best-practice-of-mini-program/">小程序单元测试最佳实践</a></h3><p><em>原文地址：<a href="https://wxsm.space/2021/unit-test-best-practice-of-mini-program/">《小程序单元测试最佳实践》 | wxsm’s pace</a></em></p><ul><li><p>启动很慢！至少需要 30 秒；因为每个不同的测试文件都需要单独启动并连接一遍实例。</p><ul><li>共享同一个全局实例（×），不起作用。</li><li>将所有测试用例放在单文件中共享实例（×），运行一次需要等到所有测试跑完才能看到结果。</li><li>不通过 launch，直接 connect 到现有窗口（√），只在第一次会比较慢。</li></ul></li><li><p>通过 navigateTo 这类方法跳转很慢：通过点击页面元素的方式触发会比较快。</p></li></ul><h4 id="个人思考-1"><a href="#个人思考-1" class="headerlink" title="个人思考"></a>个人思考</h4><p>去年年初的时候也曾尝试过在项目中推动微信小程序的 E2E 自动化测试，当时把此文所提到的坑都踩过一遍、连最后选择的解决方案都是一样的。</p><p>之前也有在  Web 项目实践过的 E2E 测试（用的是 Cypress），体验比微信小程序的自动化测试好一万倍不止。不过回头想想，像微信小程序这样不伦不类的产物，本来就是恶心开发者的，还扯什么开发体验呢？</p><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://polypane.app/css-specificity-calculator">CSS Specificity Calculator</a>：CSS 选择器优先级计算，帮助你快速计算你的 CSS 选择器优先级。</p></li><li><p><a href="https://github.com/2nthony/blogkit">Blogkit</a>：一个朋友的开源项目，利用 Notion API 驱动，将 Notion 作为博客的后台数据库，目前已经支持分发到内置的静态网站以及语雀。</p><ul><li>btw，自从 Notion 开放 API 依赖，将 Notion 作为博客后台数据库的 idea 就层出不穷，并且已经有不少人付诸实践，比如这里还有一个：<a href="https://www.coryetzkorn.com/blog/how-the-notion-api-powers-my-blog">How the Notion API Powers My Blog</a>。 虽然我个人也很喜欢使用 Notion 作为我的资料库，但目前仍没有打算基于它来做博客。</li></ul></li><li><p><a href="https://coderwall.com/">Coderwall</a>：一个开发人员社区的开发和设计技巧、工具和项目，可以从上面学到很多技巧，包括但不限于：Shell、Git、JavaScript、CSS 等。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新文章&quot;&gt;&lt;a href=&quot;#新文章&quot; class=&quot;headerlink&quot; title=&quot;新文章&quot;&gt;&lt;/a&gt;新文章&lt;/h2&gt;&lt;p&gt;之前一直都有在写小抄的习惯，于是抽空整理了一下发到 Blog 上，希望能够帮助通过搜索引擎进来的同学们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>Git tips</title>
    <link href="https://4ark.me/post/git-tips.html"/>
    <id>https://4ark.me/post/git-tips.html</id>
    <published>2022-03-02T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="批量删除-git-分支"><a href="#批量删除-git-分支" class="headerlink" title="批量删除 git 分支"></a>批量删除 git 分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a | grep -e <span class="string">&quot;fix/&quot;</span> | xargs git branch -D</span><br></pre></td></tr></table></figure><h2 id="批量添加匹配文件到暂存区"><a href="#批量添加匹配文件到暂存区" class="headerlink" title="批量添加匹配文件到暂存区"></a>批量添加匹配文件到暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status -s -uall | grep .vue | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs git add</span><br></pre></td></tr></table></figure><h2 id="按最后提交日期排序所有远程分支"><a href="#按最后提交日期排序所有远程分支" class="headerlink" title="按最后提交日期排序所有远程分支"></a>按最后提交日期排序所有远程分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -rv --sort=-committerdate</span><br></pre></td></tr></table></figure><p>更多：<a href="https://stackoverflow.com/questions/5188320/how-can-i-get-a-list-of-git-branches-ordered-by-most-recent-commit">How can I get a list of Git branches, ordered by most recent commit?</a></p><h2 id="更好的-git-log"><a href="#更好的-git-log" class="headerlink" title="更好的 git log"></a>更好的 git log</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg <span class="string">&quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span></span><br></pre></td></tr></table></figure><h2 id="列出另外一个分支没有的提交"><a href="#列出另外一个分支没有的提交" class="headerlink" title="列出另外一个分支没有的提交"></a>列出另外一个分支没有的提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry -v branch-A branch-B</span><br></pre></td></tr></table></figure><h2 id="clone-特定分支"><a href="#clone-特定分支" class="headerlink" title="clone 特定分支"></a>clone 特定分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b develop git@github.com:user/myproject.git</span><br></pre></td></tr></table></figure><h2 id="递归移动文件夹"><a href="#递归移动文件夹" class="headerlink" title="递归移动文件夹"></a>递归移动文件夹</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv bar/&#123;,.&#125;* .</span><br></pre></td></tr></table></figure><h2 id="列出特定分支的记录"><a href="#列出特定分支的记录" class="headerlink" title="列出特定分支的记录"></a>列出特定分支的记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p branch-name</span><br></pre></td></tr></table></figure><h2 id="查看特定文件的-git-记录"><a href="#查看特定文件的-git-记录" class="headerlink" title="查看特定文件的 git 记录"></a>查看特定文件的 git 记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> -p -- filename</span><br></pre></td></tr></table></figure><h2 id="修改-git-提交为任何人"><a href="#修改-git-提交为任何人" class="headerlink" title="修改 git 提交为任何人"></a>修改 git 提交为任何人</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git -c user.name=<span class="string">&quot;NEW NAME&quot;</span> -c user.email=<span class="string">&quot;new_email@gmail.com&quot;</span> commit --amend --date=<span class="string">&quot;Tue Nov 20 03:00 2018 +0100&quot;</span> --author=<span class="string">&quot;NEW NAME &lt;new_email@gmail.com&gt;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="查看当前所有子目录的-git-状态"><a href="#查看当前所有子目录的-git-状态" class="headerlink" title="查看当前所有子目录的 git 状态"></a>查看当前所有子目录的 git 状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -maxdepth 1 -mindepth 1 -<span class="built_in">type</span> d -<span class="built_in">exec</span> sh -c <span class="string">&#x27;(echo &#123;&#125; &amp;&amp; cd &#123;&#125; &amp;&amp; git status -s &amp;&amp; echo)&#x27;</span> \\;</span><br></pre></td></tr></table></figure><h2 id="创建-git-归档时忽略某些目录"><a href="#创建-git-归档时忽略某些目录" class="headerlink" title="创建 git 归档时忽略某些目录"></a>创建 git 归档时忽略某些目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar cvfz app.tar.gz --exclude <span class="string">&quot;.git/*&quot;</span> --exclude <span class="string">&quot;.git&quot;</span> app/</span><br></pre></td></tr></table></figure><h2 id="列出未发布的-commit"><a href="#列出未发布的-commit" class="headerlink" title="列出未发布的 commit"></a>列出未发布的 commit</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> @&#123;u&#125;..</span><br></pre></td></tr></table></figure><h2 id="在所有-commit-中寻找代码"><a href="#在所有-commit-中寻找代码" class="headerlink" title="在所有 commit 中寻找代码"></a>在所有 commit 中寻找代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rev-list --all | xargs git grep</span><br></pre></td></tr></table></figure><h2 id="找到一个文件是何时被删掉的"><a href="#找到一个文件是何时被删掉的" class="headerlink" title="找到一个文件是何时被删掉的"></a>找到一个文件是何时被删掉的</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --diff-filter=D -- path/to/file</span><br></pre></td></tr></table></figure><h2 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin :branch</span><br></pre></td></tr></table></figure><h2 id="让-git-可以递归调用"><a href="#让-git-可以递归调用" class="headerlink" title="让 git 可以递归调用"></a>让 git 可以递归调用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.git <span class="string">&#x27;!git&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="revert-cherry-pick"><a href="#revert-cherry-pick" class="headerlink" title="revert cherry-pick"></a>revert cherry-pick</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -p --onto SHA^ SHA</span><br></pre></td></tr></table></figure><h2 id="永久删除文件"><a href="#永久删除文件" class="headerlink" title="永久删除文件"></a>永久删除文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git filter-branch --tree-filter <span class="string">&#x27;rm -rf my_folder/my_file&#x27;</span> HEAD</span><br></pre></td></tr></table></figure><h2 id="永久链接"><a href="#永久链接" class="headerlink" title="永久链接"></a>永久链接</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink = <span class="string">&quot;!f() &#123; echo &quot;</span>https://$(git config --get remote.origin.url | grep --color=never -o -E <span class="string">&#x27;github.com[:/][^\\.]+&#x27;</span> | sed s/\\:/\\\\//)/commit/$(git rev-parse @&#123;u&#125;)<span class="string">&quot;; &#125;; open <span class="subst">$(f)</span>&quot;</span></span><br></pre></td></tr></table></figure><h2 id="仅忽略本地副本的文件更改"><a href="#仅忽略本地副本的文件更改" class="headerlink" title="仅忽略本地副本的文件更改"></a>仅忽略本地副本的文件更改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git update-index --assume-unchanged &lt;file&gt;</span><br><span class="line"></span><br><span class="line">git update-index --no-assume-unchanged &lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="忽略已跟踪的文件"><a href="#忽略已跟踪的文件" class="headerlink" title="忽略已跟踪的文件"></a>忽略已跟踪的文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="获取当前分支名称"><a href="#获取当前分支名称" class="headerlink" title="获取当前分支名称"></a>获取当前分支名称</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-color 2&gt; /dev/null | sed -e <span class="string">&#x27;/^[^*]/d&#x27;</span> -e <span class="string">&#x27;s/* \(.*\)/\1/&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="查看某个版本的目录树"><a href="#查看某个版本的目录树" class="headerlink" title="查看某个版本的目录树"></a>查看某个版本的目录树</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git show HEAD~5:hello.txt</span><br><span class="line"></span><br><span class="line">git show awesome-feature:app/models</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;批量删除-git-分支&quot;&gt;&lt;a href=&quot;#批量删除-git-分支&quot; class=&quot;headerlink&quot; title=&quot;批量删除 git 分支&quot;&gt;&lt;/a&gt;批量删除 git 分支&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table</summary>
      
    
    
    
    
    <category term="git" scheme="https://4ark.me/tags/git/"/>
    
    <category term="vcs" scheme="https://4ark.me/tags/vcs/"/>
    
  </entry>
  
  <entry>
    <title>Hg tips</title>
    <link href="https://4ark.me/post/hg-tips.html"/>
    <id>https://4ark.me/post/hg-tips.html</id>
    <published>2022-03-02T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提高效率"><a href="#提高效率" class="headerlink" title="提高效率"></a>提高效率</h2><h3 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h3><p>Hg 本身支持简写，如：</p><ul><li>hg status =&gt; hg st</li><li>hg shelve =&gt; hg she</li><li>hg unshelve =&gt; hg unshe</li><li>hg update =&gt; hg up</li><li>hg commit =&gt; hg ci</li><li>hg diff =&gt; hg d</li></ul><p>也可以通过下面几种方式来自定义想要的别名。</p><h4 id="方式一：hg-alias"><a href="#方式一：hg-alias" class="headerlink" title="方式一：hg alias"></a>方式一：hg alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">amend = commit --amend</span><br><span class="line">br = branch</span><br><span class="line">brs = branches</span><br><span class="line">wip = !<span class="variable">$HG</span> addremove &gt;/dev/null 2&gt;&amp;1 &amp;&amp; <span class="variable">$HG</span> ci -m <span class="string">&quot;--wip-- [skip ci]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hg amend</span><br><span class="line">&gt; hg br</span><br><span class="line">&gt; hg brs</span><br><span class="line">&gt; hg wip</span><br></pre></td></tr></table></figure><h4 id="方式二：bash-alias"><a href="#方式二：bash-alias" class="headerlink" title="方式二：bash alias"></a>方式二：bash alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> hgst=<span class="string">&quot;hg status&quot;</span></span><br><span class="line"><span class="built_in">alias</span> hgd=<span class="string">&quot;hg diff&quot;</span></span><br><span class="line"><span class="built_in">alias</span> hga=<span class="string">&quot;hg add&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hgst</span><br></pre></td></tr></table></figure><h4 id="方式三：bash-function"><a href="#方式三：bash-function" class="headerlink" title="方式三：bash function"></a>方式三：bash function</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">  hg pull --rebase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; <span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hgpl</span><br></pre></td></tr></table></figure><h4 id="方式四：bash-function-hg-alias"><a href="#方式四：bash-function-hg-alias" class="headerlink" title="方式四：bash function + hg alias"></a>方式四：bash function + hg alias</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.bash_profile</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">hgpl</span></span>() &#123;</span><br><span class="line">  hg pull --rebase</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[<span class="built_in">alias</span>]</span><br><span class="line">pl = !<span class="built_in">source</span> ~/.bash_profile &amp;&amp; hgpl</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using</span></span><br><span class="line">&gt; hg pl</span><br></pre></td></tr></table></figure><h3 id="复制其它分支的-commit"><a href="#复制其它分支的-commit" class="headerlink" title="复制其它分支的 commit"></a>复制其它分支的 commit</h3><p>假设我们有多个分支在并行开发，在 A 分支做了某些改动，希望把这些改动也应用到 B 分支。</p><p>这时候可以用 <a href="https://www.mercurial-scm.org/repo/hg/help/graft">graft</a> 命令将这个 commit 从别的分支复制到当前分支，类似于 Git  <a href="https://git-scm.com/docs/git-cherry-pick">cherry-pick</a> 功能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg brs</span><br><span class="line">feature/v1                     6:f8528de0eb4c</span><br><span class="line">feature/v1.1                   5:288d0414598d</span><br><span class="line"></span><br><span class="line">&gt; hg <span class="built_in">log</span> -G --style compact</span><br><span class="line">@  6[tip]:1   f8528de0eb4c   2021-12-14 13:04 +0800   4Ark</span><br><span class="line">|    feat: feature-v1-04</span><br><span class="line">|</span><br><span class="line">| o  5   288d0414598d   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-03</span><br><span class="line">| |</span><br><span class="line">| o  4   d72548bcd32b   2021-12-14 12:56 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-02</span><br><span class="line">| |</span><br><span class="line">| o  3   8719f541d5d8   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">| |    feat: feature-v1.1-00</span><br><span class="line">| |</span><br><span class="line">| o  2   e7eb9420534e   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">|/     feat: feature-v1.1-00</span><br><span class="line">|</span><br><span class="line">o  1   431a3844a58c   2021-12-14 12:54 +0800   4Ark</span><br><span class="line">|    feat: feature-v1-01</span><br><span class="line">|</span><br><span class="line">o  0   5d35d7d5baf8   2021-12-14 12:53 +0800   4Ark</span><br><span class="line">     feat: feature-v1</span><br></pre></td></tr></table></figure><p>feature/v1.1 分支是基于 feature/v1 创建的，目前两个分支都分别提交了一些东西，我们希望将 feature/1.1 的最后一个提交（5:288d0414598d）复制到 feature/1 中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg update feature/v1</span><br><span class="line">&gt; hg graft -r 5</span><br><span class="line"></span><br><span class="line">&gt; hg <span class="built_in">log</span> -r tip --style compact</span><br><span class="line">7[tip]   42cf5e6dfe1e   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-03</span><br></pre></td></tr></table></figure><h4 id="更多例子"><a href="#更多例子" class="headerlink" title="更多例子"></a>更多例子</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制单个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制多个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit 2 3 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个</span></span><br><span class="line">&gt; hg graft -D <span class="string">&quot;2:5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个，但有一个例外</span></span><br><span class="line">&gt; hg graft -D <span class="string">&quot;2::5 and not 3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续复制多个并且编辑提交信息</span></span><br><span class="line">&gt; hg graft --edit <span class="string">&quot;2:5&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将整个分支作为一个提交复制过来，如果要编辑提交信息将 -r 改成 --edi</span></span><br><span class="line">&gt; hg graft -r feature/v1.1 --base <span class="string">&quot;ancestor(&#x27;feature/v1.1&#x27;,&#x27;feature/v1&#x27;)&quot;</span></span><br></pre></td></tr></table></figure><p>如果在 graft 过程中有冲突，可以解决后使用 <code>hg graft --continue</code> 继续进行，或者使用 <code>hg graft --abort</code> 终止本次操作。</p><h3 id="同一个仓库链接到多个目录（worktree）"><a href="#同一个仓库链接到多个目录（worktree）" class="headerlink" title="同一个仓库链接到多个目录（worktree）"></a>同一个仓库链接到多个目录（worktree）</h3><p>如果熟悉 git 的同学应该知道 git 有一个 <a href="https://git-scm.com/docs/git-worktree">worktree</a> 命令，它可以将多个目录链接同一个仓库，并且可以在各自的目录下切换到不同的分支，特别适合以下场景：</p><ol><li>并行开发：在两个不同的分支上开发，不需要频繁回来地切换。</li><li>快速试验、修复：在开发中需要验证、或修复某个 BUG，但不想影响现有的工作目录，就可以在新的工作目录中进行开发。</li><li>代码迁移合并：假如 A 分支和 B 分支版本区别过大，无法直接使用 <code>graft</code>，这时候就可以从新的工作目录中直接拷贝文件。</li></ol><p>其实 hg 也有类似的命令，那就是 <a href="https://www.mercurial-scm.org/wiki/ShareExtension">share</a>，需要先开启扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc </span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">share =</span><br></pre></td></tr></table></figure><p>然后这样操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg share xxx-project project-v2</span><br><span class="line">&gt; <span class="built_in">cd</span> project-v2</span><br><span class="line">&gt; hg up feature/xxx</span><br></pre></td></tr></table></figure><h2 id="操作历史"><a href="#操作历史" class="headerlink" title="操作历史"></a>操作历史</h2><p style="color: red; font-weight: bold;">注意：以下操作请谨慎执行，除非有特别声明，否则均只能操作未发布的提交。</p><h3 id="撤销前一次提交"><a href="#撤销前一次提交" class="headerlink" title="撤销前一次提交"></a>撤销前一次提交</h3><p>如果提交后发现某个文件忘记添加了，可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/rollback">rollback</a> 进行回滚：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg commit -m <span class="string">&quot;feat: do something&quot;</span></span><br><span class="line">&gt; hg rollback </span><br></pre></td></tr></table></figure><p>该操作会把最后一次 commit 移除，但这个 commit 的改动仍在。</p><h3 id="回滚某个-commit"><a href="#回滚某个-commit" class="headerlink" title="回滚某个 commit"></a>回滚某个 commit</h3><p>如果想要回滚某个 commit，可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/backout">backout</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回滚最后一个提交</span></span><br><span class="line">&gt; hg backout -r .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚某个提交</span></span><br><span class="line">&gt; hg backout -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回滚某个提交，但先不提交（推荐使用这种方式）</span></span><br><span class="line">&gt; hg backout -r 9487 --no-commit</span><br></pre></td></tr></table></figure><p>效果就和 <code>git revert</code> 一样。</p><h3 id="撤销某个-commit-及其后代"><a href="#撤销某个-commit-及其后代" class="headerlink" title="撤销某个 commit 及其后代"></a>撤销某个 commit 及其后代</h3><p>如果想要撤销某个 commit 及以后的所有改动，可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/strip">strip</a>，需要先开启扩展：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">strip =</span><br></pre></td></tr></table></figure><p>然后这样使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除单个</span></span><br><span class="line">&gt; hg strip -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除多个</span></span><br><span class="line">&gt; hg strip -r 9487 9488</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除 commit，但保留改动</span></span><br><span class="line">&gt; hg strip -r 9487--keep</span><br></pre></td></tr></table></figure><p>注意：该操作不属于修改历史，可用于已发布的 commit。</p><h3 id="修改前一次提交"><a href="#修改前一次提交" class="headerlink" title="修改前一次提交"></a>修改前一次提交</h3><p>如果我们在提交一次 commit 后，想要修改 commit 信息，或者想要再做一些改动，可以使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg add .</span><br><span class="line">&gt; hg commit -m <span class="string">&quot;feat: first commit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改一下</span></span><br><span class="line">&gt; hg commit --amend</span><br></pre></td></tr></table></figure><h3 id="修改前-N-次提交"><a href="#修改前-N-次提交" class="headerlink" title="修改前 N 次提交"></a>修改前 N 次提交</h3><p>如果要支持更复杂的修改历史操作，我们可以使用 <a href="https://www.mercurial-scm.org/wiki/HisteditExtension">histedit</a> 扩展，类似于 <code>git rebase -i</code>，使用它能够实现：</p><ul><li>修改某个 commit 的 commit 信息</li><li>移除某个提交</li><li>合并多次提交</li><li>等等..</li></ul><p>需要在 <code>.hgrc</code> 开启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line">histedit =</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>每次修改后 changeset 都会改变。</li></ul><p>假设，我们现在有下面几个提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg <span class="built_in">log</span> -b . --style compact</span><br><span class="line"></span><br><span class="line">5   288d0414598d   2021-12-14 12:57 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-03</span><br><span class="line"></span><br><span class="line">4   d72548bcd32b   2021-12-14 12:56 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-02</span><br><span class="line"></span><br><span class="line">3   8719f541d5d8   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-00</span><br><span class="line"></span><br><span class="line">2   e7eb9420534e   2021-12-14 12:55 +0800   4Ark</span><br><span class="line">  feat: feature-v1.1-00</span><br></pre></td></tr></table></figure><p>如果只是修改最后一个 commit 信息，我们可以使用 <code>hg commit --amend</code>，如果要修改前几个的 commit 信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 想要修改倒数第三个的 commit 信息</span></span><br><span class="line">&gt; hg histedit 8719f541d5d8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑内容：</span></span><br><span class="line">pick 8719f541d5d8 3 feat: feature-v1.1-00</span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br><span class="line"><span class="comment"># Edit history between 8719f541d5d8 and 288d0414598d</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commits are listed from least to most recent</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can reorder changesets by reordering the lines</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Commands:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  e, edit = use commit, but allow edits before making new commit</span></span><br><span class="line"><span class="comment">#  m, mess = edit commit message without changing commit content</span></span><br><span class="line"><span class="comment">#  p, pick = use commit</span></span><br><span class="line"><span class="comment">#  b, base = checkout changeset and apply further changesets from there</span></span><br><span class="line"><span class="comment">#  d, drop = remove commit from history</span></span><br><span class="line"><span class="comment">#  f, fold = use commit, but combine it with the one above</span></span><br><span class="line"><span class="comment">#  r, roll = like fold, but discard this commit&#x27;s description and date</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据描述，如果我们只是想要修改 commit 信息，我们可以直接在这里改：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- pick 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ mess 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure><p>但是如果想要修改这个 commit 的改动内容，比如新增一个文件，我们改成这样：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- pick 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ edit 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure><p>这时候就可以改动文件内容，最后再进行提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">echo</span> <span class="string">&#x27;new&#x27;</span> &gt; new-file.txt</span><br><span class="line">&gt; hg add .</span><br><span class="line">&gt; hg commit -m <span class="string">&quot;feat: feat: feature-v1.1-00(changed)&quot;</span></span><br><span class="line">created new head</span><br><span class="line"></span><br><span class="line">&gt; hg histedit --<span class="built_in">continue</span> <span class="comment"># 你也可以使用 hg histedit --abort 来终止本次操作</span></span><br></pre></td></tr></table></figure><p>如果要移除某个 commit：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- edit 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line"><span class="addition">+ drop 8719f541d5d8 3 feat: feature-v1.1-00</span></span><br><span class="line">pick d72548bcd32b 4 feat: feature-v1.1-02</span><br><span class="line">pick 288d0414598d 5 feat: feature-v1.1-03</span><br></pre></td></tr></table></figure><p>如果要合并多个 commit，并且保留所有提交信息：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pick 8719f541d5d8 3 feat: feature-v1.1-00  # 只能合并到第一个 commit</span><br><span class="line"><span class="deletion">- pick d72548bcd32b 4 feat: feature-v1.1-02</span></span><br><span class="line"><span class="deletion">- pick 288d0414598d 5 feat: feature-v1.1-03</span></span><br><span class="line"><span class="addition">+ fold d72548bcd32b 4 feat: feature-v1.1-02</span></span><br><span class="line"><span class="addition">+ fold 288d0414598d 5 feat: feature-v1.1-03</span></span><br></pre></td></tr></table></figure><p>如果要合并多个 commit，并且不保留提交信息（直接采用第一个 commit 信息），只需要将 <code>fold</code> 改成 <code>roll</code>。</p><h2 id="查找历史"><a href="#查找历史" class="headerlink" title="查找历史"></a>查找历史</h2><h3 id="查看-commit-的信息"><a href="#查看-commit-的信息" class="headerlink" title="查看 commit 的信息"></a>查看 commit 的信息</h3><p>使用 <a href="https://www.mercurial-scm.org/repo/hg/help/log">log</a> 命令某个提交的信息，通常我们使用 source tree 能够满足大部分日常需求。</p><p>但 log 还支持很多高阶操作，这里举几个最常使用的，推荐配合别名使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前分支的的 log</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -b .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更清晰地查看 log 历史</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> --template <span class="string">&quot;&#123;label(&#x27;custom.rev&#x27;, rev)&#125;\t&#123;label(&#x27;custom.node&#x27;,node|short)&#125; &#123;label(&#x27;custom.phase&#x27;,phase)&#125; \t&#123;label(&#x27;custom.age&#x27;,date|age)&#125;\t&#123;desc|firstline&#125; &#123;label(&#x27;custom.user&#x27;, author|user)&#125; &#123;label(&#x27;custom.branch&#x27;,branch)&#125; &#123;label(&#x27;custom.tag&#x27;,tags)&#125; &#123;label(&#x27;custom.book&#x27;,bookmarks)&#125;\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个提交的信息以及文件改动</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -p -r 9487</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件的改动信息</span></span><br><span class="line">&lt; hg <span class="built_in">log</span> package.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件的改动信息（包括删除）</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> --remove package</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个目录的改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -M src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个文件某几行的所有改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -L package.json,1:23 --follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看多个文件某几行的所有改动信息</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -L package.json,1:23 -L package2.json,1:23 --follow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看未发布的提交</span></span><br><span class="line">&gt; hg <span class="built_in">log</span> -r <span class="string">&quot;draft()&quot;</span></span><br></pre></td></tr></table></figure><h3 id="查看某个文件每一行的最后改动者"><a href="#查看某个文件每一行的最后改动者" class="headerlink" title="查看某个文件每一行的最后改动者"></a>查看某个文件每一行的最后改动者</h3><p>可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/annotate">annotate</a> 命令查看文件中每一行的最后改动者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; hg annotate -ulc package.json</span><br></pre></td></tr></table></figure><p>ps：该命令还有另一个别名 blame。</p><h3 id="二分法定位出问题的-commit"><a href="#二分法定位出问题的-commit" class="headerlink" title="二分法定位出问题的 commit"></a>二分法定位出问题的 commit</h3><p>如果想知道哪一次代码提交引入了错误，可以使用 <a href="https://www.mercurial-scm.org/repo/hg/help/bisect">bisect</a> 命令。</p><p>具体操作看阮一峰老师的这篇文章： <a href="http://www.ruanyifeng.com/blog/2018/12/git-bisect.html">《git bisect 命令教程》</a> 。</p><h2 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h2><h3 id="diff-tool-差异对比工具"><a href="#diff-tool-差异对比工具" class="headerlink" title="diff tool 差异对比工具"></a>diff tool 差异对比工具</h3><p>使用一个称手的 diff 工具可帮助你提高很多效率，比如：</p><ul><li>快速对比两个版本的差异</li><li>快速对比两个文件、文件夹的差异</li></ul><p>我个人使用 <a href="https://www.scootersoftware.com/index.php">Beyond Compare</a>，不过这个软件略贵，也可以使用其它同类工具，例如：<a href="https://apps.kde.org/en/kdiff3">KDiff3</a>、<a href="https://winmerge.org/">WinMergeU</a>、<a href="https://www.perforce.com/zh-hans/chanpin/helix-core-apps/merge-diff-tool-p4merge">P4Merge 等。</a></p><p>下面以 Beyond Compare 为例进行配置，其实基本大同小异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt; vim ~/.hgrc</span><br><span class="line"></span><br><span class="line">[extensions]</span><br><span class="line"><span class="comment"># uncomment the lines below to enable some popular extensions</span></span><br><span class="line"><span class="comment"># (see &#x27;hg help extensions&#x27; for more info)</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">extdiff =</span><br><span class="line">hgext.extdiff =</span><br><span class="line"></span><br><span class="line">[extdiff]</span><br><span class="line">cmd.bcomp = bcomp</span><br><span class="line">opts.bcomp = -leftreadonly -solo</span><br><span class="line"></span><br><span class="line">[merge-tools]</span><br><span class="line">bcomp.executable = Applications/Beyond Compare.app/Contents/MacOS/bcomp</span><br><span class="line">bcomp.priority=-1</span><br><span class="line">bcomp.args=<span class="variable">$local</span> <span class="variable">$other</span> <span class="variable">$base</span> /mergeoutput=<span class="variable">$output</span> /ro /lefttitle=<span class="built_in">local</span> /centertitle=base /righttitle=other /outputtitle=merged /automerge /reviewconflicts /solo</span><br><span class="line">bcomp.premerge=False</span><br><span class="line">bcomp.regname=ExePath</span><br><span class="line">bcomp.gui=True</span><br><span class="line">bcomp.diffargs=/lro /lefttitle=<span class="string">&#x27;$plabel1&#x27;</span> /righttitle=<span class="string">&#x27;$clabel&#x27;</span> /solo /expandall <span class="variable">$parent</span> <span class="variable">$child</span></span><br><span class="line">bcomp.diff3args=<span class="variable">$parent1</span> <span class="variable">$parent2</span> <span class="variable">$child</span> /lefttitle=<span class="string">&#x27;$plabel1&#x27;</span> /centertitle=<span class="string">&#x27;$clabel&#x27;</span> /righttitle=<span class="string">&#x27;$plabel2&#x27;</span> /solo /ro</span><br><span class="line">bcomp.dirdiff=True</span><br><span class="line">bcomp.binary=True</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对比某个版本与当前工作区</span></span><br><span class="line">&gt; hg bcomp -r 9816 -r .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个版本、分支</span></span><br><span class="line">&gt; hg bcomp -r 9646 -r 9677</span><br><span class="line">&gt; hg bcomp -r default -r 9677</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个版本的某个文件、文件夹</span></span><br><span class="line">&gt; hg bcomp -r 9552 -r 9553 filepath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个文件夹</span></span><br><span class="line">&gt; bcomp dir-a dir-b</span><br></pre></td></tr></table></figure><p>Beyond Compare 还支持三路比较、合并，就是比较 A 版本、B 版本、C 版本（两者共同祖先），不过要支持这个功能价格就更贵了。</p><h3 id="vscode-hg"><a href="#vscode-hg" class="headerlink" title="vscode-hg"></a>vscode-hg</h3><p>在使用 VSCode 的同学，推荐使用 <a href="https://marketplace.visualstudio.com/items?itemName=mrcrowl.hg">vscode-hg</a> 这个扩展，可支持大部分 hg 操作。</p><p>如果遇到 Mercurial installation not found. 报错 ，在 settings.json 添加配置并重启：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hg.path&quot;</span>: <span class="string">&quot;/opt/homebrew/bin/hg&quot;</span> <span class="comment">// 可通过 which hg 查看 hg 的可执行脚本路径</span></span><br></pre></td></tr></table></figure><p>另外推荐开启  <code>hg.lineAnnotationEnabled</code> ，即可轻松查看当前文件每一行最后改动，类似于 GitLens 扩展。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;提高效率&quot;&gt;&lt;a href=&quot;#提高效率&quot; class=&quot;headerlink&quot; title=&quot;提高效率&quot;&gt;&lt;/a&gt;提高效率&lt;/h2&gt;&lt;h3 id=&quot;设置别名&quot;&gt;&lt;a href=&quot;#设置别名&quot; class=&quot;headerlink&quot; title=&quot;设置别名&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="vcs" scheme="https://4ark.me/tags/vcs/"/>
    
    <category term="hg" scheme="https://4ark.me/tags/hg/"/>
    
  </entry>
  
  <entry>
    <title>周刊第2期：珍惜和平</title>
    <link href="https://4ark.me/post/weekly-02.html"/>
    <id>https://4ark.me/post/weekly-02.html</id>
    <published>2022-02-27T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="俄乌战争"><a href="#俄乌战争" class="headerlink" title="俄乌战争"></a>俄乌战争</h2><p>这是一个技术、踩坑记录、日常吐槽的博客，我本不想给它蒙上太多政治色彩，但原谅我实在是憋不住了。</p><p>2022年2月24号，俄罗斯入侵乌拉克，与此同时，国内的媒体出现了铺天盖地的假信息、在微博、抖音上网友们更是发表了各种极度令人恶心的言论，让我备受震撼。</p><p>你们到底有没有意识到，这可是战争，是要死很多人的！或许你们认为这不关你的事、或许你们认为这只是开开玩笑、又或许你们认为这本就是一场正义的战争。</p><p>每个人都可以有自己的政治立场，但我希望你们积点口德，不要拿这种事情来口嗨。</p><p>我想在此引用几句在网上看到的几句话，也正是我想说的：</p><blockquote><p>我们，强烈反对俄罗斯对乌克兰发动的战争。无论俄罗斯有千种理由，万般借口，以武力入侵一个主权国家都是对以联合国宪章为基础的国际关系准则的践踏，是对现有国际安全体系的破坏。<br /><br>我们，坚决支持乌克兰人民保家卫国的行动。我们担忧俄罗斯的武力行为将导致欧洲乃至整个世界局势的动荡，引发更大范围的人道主义灾难。<br /><br>我们，强烈呼吁俄罗斯政府和普京总统停止战争，用谈判解决纠纷。强权不仅会使文明进步的成果和国际正义的原则毁于一旦，还会给俄罗斯民族带来巨大的耻辱和灾难。<br /><br>和平始于人心的渴望。我们，反对不义战争。</p></blockquote><blockquote><p>没有任何一个战争的挑衅者，值得歌颂。<br /><br>也没有任何一个战争的发起者，值得赞扬。<br /><br>民族主义在现实世界值得提倡，但沦为民粹时就会反噬自己。<br /><br>宏大叙事是审美的一种需要，但如果全民歌颂将让集体万劫不复。<br /></p></blockquote><p>根据 The Kyiv Independent 报道，下面是目前双方的战损情况：</p><div style="display: flex;">    <img width="50%" src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202282142093.jpeg">    <img width="50%" src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202282142529.jpeg"></div><p>这一串数字的背后，是无数家庭的血和泪！</p><p>请珍惜来之不易的和平，任何为战争欢呼的人都是傻逼！</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些本周阅读过的好文章、以及我的一些总结和个人思考；非常建议你直接阅读原文，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错的。</p></blockquote><h3 id="Yes-I-can-connect-to-a-DB-in-CSS"><a href="#Yes-I-can-connect-to-a-DB-in-CSS" class="headerlink" title="Yes, I can connect to a DB in CSS"></a><a href="https://www.leemeichin.com/posts/yes-i-can-connect-to-a-db-in-css.html">Yes, I can connect to a DB in CSS</a></h3><p><em>原文地址：<a href="https://www.leemeichin.com/posts/yes-i-can-connect-to-a-db-in-css.html">《Yes, I can connect to a DB in CSS》 | kamelåså</a></em></p><p><img src="https://www.leemeichin.com/img/yes-i-can-connect-to-a-db-in-css/tweet.jpg"></p><blockquote><p>招聘人员会说：</p><p>我们正在寻找可以使用 CSS 连接到数据库的人。</p></blockquote><p>这能做到吗？是的，这篇文章的作者就做到了。</p><p>首先需要了解两个东西：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/Houdini">CSS Houdini</a>：可以通过 JavaScript 访问并控制 CSS 模型，其最大的特点就是 <a href="https://developer.mozilla.org/en-US/docs/Web/API/PaintWorklet">PaintWorklet</a>，它可以以编程方式生成一个图像，也与我们所熟悉的 Canvas 类似。</li><li><a href="https://sql.js.org/">sql.js</a>：它是一个 JS 库，允许你在浏览器中创建并查询一个关系型数据库，使用一个存储在浏览器内的虚拟数据库文件，所以数据的存储和修改都不是持久化的；不过它还支持将 SQLite 编译成 Wasm，也就意味着可以在浏览器访问现有的 SQLite 数据库文件。</li></ul><p>做法就是：在 JS 中通过 Houdini 获取 CSS 变量，然后传递给 SQLite 的 DB 实例。</p><p>最终效果看这里：<a href="https://sqlcss.xyz/">https://sqlcss.xyz</a></p><h3 id="我为什么说-Vim-比-VSCode-更好用"><a href="#我为什么说-Vim-比-VSCode-更好用" class="headerlink" title="我为什么说 Vim 比 VSCode 更好用"></a><a href="https://sean-warman.medium.com/why-vim-is-better-than-vscode-d09e2355eb37">我为什么说 Vim 比 VSCode 更好用</a></h3><p><em>原文地址：<a href="https://sean-warman.medium.com/why-vim-is-better-than-vscode-d09e2355eb37">《Why Vim is better than VSCode》 | Sean</a></em></p><p>随着微软开始全面拥抱开源世界，推出了一个又一个大型开源项目，例如 VSCode，就已经在代码编辑器中占据了一个重要的位置，并且随着 <a href="https://github.com/features/codespaces">Codespaces</a> 和 <a href="https://github.com/gitpod-io/openvscode-server">Open VSCode Server</a> 的推出，可以轻松在浏览器上进行远程开发。</p><p>除此之外，微软还开源了一个项目叫做 <a href="https://github.com/xtermjs/xterm.js/">xterm.js</a>，用于 VSCode 的终端，这也让浏览器实现终端功能变得更加简单。</p><p>作者认为相比于 VSCode，还是 Vim更胜一筹，因为它轻巧快熟，可以在服务器上通过 SSH 写代码，所有事情都可以在终端中完成，可移植性和可配置性都非常高，并且基于 xterm.js 也可以轻松实现在浏览器上使用 Vim 进行远程开发。</p><p>它并不像很多人想象得那么难以上手，它甚至让代码写起来就像打游戏一样，因为它的控制方式与游戏相似，都是通过各种命令的组合操作。</p><p>大多数命令有两个、三个或四个部分。三部分结构的一个版本是这样的：操作符（operator）-文本对象（text object）-动作（motion）。</p><p>操作符包括删除（delete）、更改（change）、视觉选择（visual select）和替换（replace），每次选一个使用。</p><p>所以可以这样组合：</p><ul><li>di’ —— 删除（delete）“单引号”内（inside）的内容。</li><li>da” —— 删除“双引号”周围（around）的内容。</li><li>dit —— 删除 html 标签（tag）内的内容。</li><li>ci[ —— 改变（change）[方括号] 内的内容。</li></ul><h5 id="个人思考"><a href="#个人思考" class="headerlink" title="个人思考"></a>个人思考</h5><p>对于 Vim，笔者一直在想要学习、放弃之间反复横跳，以至于到现在也只会一些简单的编辑，没有感受过 Vim 命令组合的强大。</p><p>但此文只是举了几个例子，就让笔者更加了解 Vim 的命令组合，重新燃起我想要学习 Vim 的热情。</p><h2 id="CSS-not-伪类选择器已支持复杂参数"><a href="#CSS-not-伪类选择器已支持复杂参数" class="headerlink" title="CSS :not()伪类选择器已支持复杂参数"></a><a href="https://www.zhangxinxu.com/wordpress/2022/02/css-not-pseudo-class-list-argument/?utm_source=tuicool&utm_medium=referral">CSS :not()伪类选择器已支持复杂参数</a></h2><p><em>原文地址：<a href="https://www.zhangxinxu.com/wordpress/2022/02/css-not-pseudo-class-list-argument/?utm_source=tuicool&utm_medium=referral">《CSS :not()伪类选择器已支持复杂参数》 | 张鑫旭</a></em></p><p>新特性：</p><ul><li>支持多个选择器：<code>:not(.a, .b)</code></li><li>权重的区别：无论 :not() 内部有多少个选择器，最终只计算 :not() 本身这一个标签选择器</li></ul><h2 id="Facebook-工程师文化独特之处"><a href="#Facebook-工程师文化独特之处" class="headerlink" title="Facebook 工程师文化独特之处"></a><a href="https://chinese.catchen.me/2022/02/unique-engineering-culture-of-facebook.html">Facebook 工程师文化独特之处</a></h2><p><em>原文地址：<a href="https://chinese.catchen.me/2022/02/unique-engineering-culture-of-facebook.html">《Facebook 工程师文化独特之处》 | Cat Chen</a></em></p><p>作者在 Facebook 工作了 7 年，结合 Facebook 之前和之后的其它公司的经验， 本文就分享了一些作者觉得属于 Facebook 的独特文化的地方。</p><ul><li>工程师对产品结果负责任<ul><li>工程师考评不只看技术，从高级工程师开始，考评主要看对产品结果的产出</li><li>假如产品的留存率没有得到提高，则工程师、产品经理的考评都会得到惩罚</li><li>鼓励下属自行定义「什么叫做成功」，而不是告诉下属「做什么才能成功」</li></ul></li><li>基础架构被视为内部产品<ul><li>基础架构在公司内部推广</li></ul></li><li>救火比防火更容易获得回报<ul><li>如果你做的事无法量化，即便它是非常有用的，公司也会认为这是无意义的</li><li>举个例子：如果在小镇未发生火灾前，即便消防队长在背后默默做了很多事情防范，大家也不会认为这是你的功劳；相反，只有在发生过一次非常严重的火灾后，你做的事才能体现价值。</li><li>这就是为什么 Facebook 内部那么多问题处于起火状态，因为不起火就没有救火英雄。</li></ul></li></ul><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><a href="https://npm.runkit.com/">NPM RunKit</a>：直接在浏览器中尝试任何 npm 软件包，如果你也曾有过与我一样的经历，想尝试一下某个库的运行结果，由于无法直接在浏览器 console 中运行，最终只能选择在项目内随便找个地方运行的话，那就可以试试这个工具，非常简单快捷，只需在 url 后面补上你想要的 npm 包名，如 <a href="https://npm.runkit.com/dayjs">dayjs</a>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;俄乌战争&quot;&gt;&lt;a href=&quot;#俄乌战争&quot; class=&quot;headerlink&quot; title=&quot;俄乌战争&quot;&gt;&lt;/a&gt;俄乌战争&lt;/h2&gt;&lt;p&gt;这是一个技术、踩坑记录、日常吐槽的博客，我本不想给它蒙上太多政治色彩，但原谅我实在是憋不住了。&lt;/p&gt;
&lt;p&gt;2022年2月</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>周刊第1期：搬新家了</title>
    <link href="https://4ark.me/post/weekly-01.html"/>
    <id>https://4ark.me/post/weekly-01.html</id>
    <published>2022-02-20T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我为什么要写周刊"><a href="#我为什么要写周刊" class="headerlink" title="我为什么要写周刊"></a>我为什么要写周刊</h2><p>前几天特地写了篇文章来分享一下我为什么要办这个周刊：《<a href="/post/weekly-idea.html">我为什么要写周刊</a>》。</p><h2 id="我搬新家了"><a href="#我搬新家了" class="headerlink" title="我搬新家了"></a>我搬新家了</h2><p>在去年《<a href="/post/2021-summary.html">2021 年度总结</a>》有提到，我曾有过一段开小电动车上班的时光，通勤时间极短，幸福感倍高，但由于公司地址搬迁，就再也没有享受过这样的日子了，即便后来跳槽到新公司，通勤时间缩短了一半，但也要 40 分钟左右的通勤时间，所以，在租房合同到期后，我决定搬到公司附近。</p><p>但搬家真的好累，而且广州这几天连续不断地下雨，心情也变得烦躁起来，搬家过程不太顺利，期间还遗漏了物品在楼下没带上车，幸好楼下的邻居平时关系比较好，愿意帮我保管，第二天又跑回去拿。</p><p>但从明天开始就可以享受极短通勤距离的好处，想想还是蛮开心的。</p><h2 id="分享文章"><a href="#分享文章" class="headerlink" title="分享文章"></a>分享文章</h2><blockquote><p>一些我本周阅读过的好文章、以及我的总结和启发；非常建议你阅读原文，而不是只看这些摘要，毕竟一千个读者就有一千个哈姆雷特，而且我的理解可能是错误的。</p></blockquote><h3 id="我对-Svelte-的看法"><a href="#我对-Svelte-的看法" class="headerlink" title="我对 Svelte 的看法"></a><a href="https://lutaonan.com/blog/svelte/">我对 Svelte 的看法</a></h3><p><em>原文地址：<a href="https://lutaonan.com/blog/svelte/">《我对 Svelte 的看法》 | Randy’s Blog</a></em></p><p>简单来说 Svelte 是一个在编译时实现了 Reactivity (反应式) 的框架。</p><p>如何不用 <code>defineProperty</code> 实现 Reactivity：</p><ol><li>只要在每次赋值的时候，手动执行 <code>update</code> 方法</li><li>Svelte 在编译阶段自动帮我们做了这件事</li><li>Svelte 使用了一个 <code>label</code> 语法（$:），实现类似于 Vue 的 <code>computed</code> 功能。</li></ol><p>Svelte 的跨组件通讯：</p><ul><li>通过在变量名前面加一个 $ 实现自动订阅<ul><li>不是黑魔法，只是针对 $ 开头的变量自动转换成 <code>subscribe</code></li></ul></li></ul><p>Svelte 所有功能都在编译阶段完成，并且可以写更少的代码，它相对于 React 和 Vue 更简单，不需要学太多额外的 API 和新语法。</p><p>目前的适用场景：</p><ul><li>适用做来做活动页。</li></ul><h5 id="我的启发"><a href="#我的启发" class="headerlink" title="我的启发"></a>我的启发</h5><p>学习一个框架或者一个语言，并不一定非要把它用到生产上才算真的有用。更多地是因为想看看在面对同一个问题的时候，不同的人解决问题的思路是怎样的，从而帮助我们提高自己的视野，这才是学习框架和语言真正的魅力。</p><h3 id="Svelte-的异步更新实现原理"><a href="#Svelte-的异步更新实现原理" class="headerlink" title="Svelte 的异步更新实现原理"></a><a href="https://lutaonan.com/blog/how-svelte-set-state-works/">Svelte 的异步更新实现原理</a></h3><p><em>原文地址：<a href="https://lutaonan.com/blog/how-svelte-set-state-works/">《Svelte 的异步更新实现原理》 | Randy’s Blog</a></em></p><p>如何异步更新：<strong>将所有导致 UI 更新的操作统一放到一个微任务里执行。</strong></p><p>Svelte 的实际做法：</p><ol><li>一个组件会被编译成一个 fragment</li><li>更新操作通过 <code>$$invalidate</code> 包裹</li><li>触发 <code>schedule_update()</code> ，通知框架需要被更新，框架会维护一个 <code>dirty_components</code> 数组。</li><li>在微任务更新时会统一遍历 <code>dirty_components</code> 数组里的任务，触发组件的更新方法。</li></ol><h3 id="开发模式-“Development-Mode”-是如何工作的？"><a href="#开发模式-“Development-Mode”-是如何工作的？" class="headerlink" title="开发模式 “Development Mode” 是如何工作的？"></a><a href="https://overreacted.io/zh-hans/how-does-the-development-mode-work/">开发模式 “Development Mode” 是如何工作的？</a></h3><p><em>原文地址：<a href="https://overreacted.io/zh-hans/how-does-the-development-mode-work/">《开发模式 “Development Mode” 是如何工作的？》 | Dan Abramov</a></em></p><p><code>process.env.NODE_ENV</code> 实际上是一个常量，在构建时会被替换成一个字符串，所以判断条件最终是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// In development:</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;development&#x27;</span> !== <span class="string">&#x27;production&#x27;</span>) &#123; // <span class="literal">true</span></span><br><span class="line">  doSomethingDev(); // 👈</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// In production:</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;production&#x27;</span> !== <span class="string">&#x27;production&#x27;</span>) &#123; // <span class="literal">false</span></span><br><span class="line">  doSomethingDev();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doSomethingProd(); // 👈</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上判断条件会被「死码消除」给优化，不被执行的代码将被移除。</p><p>但是，如果写成这样，则不会奏效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> mode = <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (mode !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  // 🔴 not guaranteed to be eliminated</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 JavaScript 并没有智能到这种程度。</p><h5 id="我的启发-1"><a href="#我的启发-1" class="headerlink" title="我的启发"></a>我的启发</h5><p>以前看 Vue 源码的时候发现很多文件都会重复好几次这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (something) &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">&#x27;something error message&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常好奇为什么不重构成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">const</span> warn = <span class="function">(<span class="params">condition, message</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// something.js</span></span><br><span class="line">warn(xxx, <span class="string">&#x27;something error message&#x27;</span>);</span><br></pre></td></tr></table></figure><p>现在知道为什么了，因为前者被「死码消除」后，所有相关代码都会被移除，</p><p>而后者，相当于调用了一个空的 <code>warn</code> 方法。</p><p>但没想到在 Vue3 中已经这么做了：<a href="https://github.com/vuejs/core/blob/main/packages/compiler-core/src/errors.ts#L16">defaultOnWarn</a>。</p><p>延伸阅读：<a href="https://segmentfault.com/a/1190000041469096">高效实现框架和 JS 库瘦身</a></p><h3 id="通俗易懂的代数效应"><a href="#通俗易懂的代数效应" class="headerlink" title="通俗易懂的代数效应"></a><a href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/">通俗易懂的代数效应</a></h3><p><em>原文地址：<a href="https://overreacted.io/zh-hans/algebraic-effects-for-the-rest-of-us/">《通俗易懂的代数效应》 | Dan Abramov</a></em></p><p>代数效应是什么：</p><ul><li>类似于 try…catch 语法，无论我们在多少层里面 throw 一个错误，外层的 catch 都能捕获到。</li><li>如果内层的 throw 还可以接受从 catch 发送的数据，这就是代数效应。</li><li>使用 async、await 的缺点是我们内部定义了 async、则会影响该函数底部所有的调用者。</li></ul><p>React 中的代数效应：</p><ul><li>JS 并没有一个类似于 try…handle 的语法，但仅在 React 内部可以通过其它方式实现类似的效果。</li><li>典型的场景是：某个组件的渲染是异步的，需要等数据请求返回后再回过来继续渲染。</li></ul><h3 id="防御性-CSS"><a href="#防御性-CSS" class="headerlink" title="防御性 CSS"></a><a href="https://ishadeed.com/article/defensive-css/">防御性 CSS</a></h3><p><em>原文地址：<a href="https://ishadeed.com/article/defensive-css/">《防御性 CSS》 | ishadeed</a></em></p><ol><li>确保 flex 布局能够换行</li><li>确保文字过长时的间距以及换行处理</li><li>防止图片被拉伸或压缩</li><li>弹窗锁定滚动</li><li>CSS 变量回退</li><li>尽量使用 min-height 固定宽度和高度</li><li>确保重置 <code>background-repeat</code></li><li>使用 <code>gap</code> 设置 flex 布局间距</li><li>给图片设置一个 background-color，以确保图片上方的文字能够正常显示</li><li>使用 <code>overflow: auto</code></li><li>图片 <code>object-fit: cover</code></li><li>分组选择器只要有一个无效，则所有选择器不生效</li></ol><h5 id="我的启发-2"><a href="#我的启发-2" class="headerlink" title="我的启发"></a>我的启发</h5><p>了解常用的防御性 CSS ，可以避免很多开发中没有意识到的问题。</p><h3 id="SSR、SSG、ISR、DPR-有什么区别？"><a href="#SSR、SSG、ISR、DPR-有什么区别？" class="headerlink" title="SSR、SSG、ISR、DPR 有什么区别？"></a><a href="http://www.yyyweb.com/5407.html">SSR、SSG、ISR、DPR 有什么区别？</a></h3><p><em>原文地址：<a href="http://www.yyyweb.com/5407.html">《SSR、SSG、ISR、DPR 有什么区别？》 | 前端里</a></em></p><ul><li>CSR（Client Side Rendering）: 客户端渲染<ul><li>缺点：SPA 应用不利于 SEO</li></ul></li><li>SSR（Server Side Rendering）: 服务端渲染<ul><li>优点：利于 SEO</li><li>缺点：需要更多的服务器计算资源和运维成本</li></ul></li><li>SSG（Static Site Generation）: 静态网站生成<ul><li>常年不变的直接生成为静态页面，页面中的动态内容使用 CSR</li><li>缺点：对于网页数量极多的页面，生成一次需要花费很长时间</li></ul></li><li>ISR（Incremental Site Rendering）: 增量式网站渲染<ul><li>关键性页面预渲染，缓存至 CDN；非关键性页面先显示 fallback，再使用 CSR渲染，并且缓存至 CDN</li><li>缺点：需要先显示 fallback 内容，用户体验不好</li></ul></li><li>DPR（Distributed Persistent Rendering）: 分布式持续渲染<ul><li>基于 ISR 的基础上去除 fallback，并且使用「按需构建器」来响应未渲染的页面</li></ul></li></ul><h3 id="不优雅的-React-Hooks"><a href="#不优雅的-React-Hooks" class="headerlink" title="不优雅的 React Hooks"></a><a href="https://zhuanlan.zhihu.com/p/455317250">不优雅的 React Hooks</a></h3><p><em>原文地址：<a href="https://zhuanlan.zhihu.com/p/455317250">《不优雅的 React Hooks》 | 蚂蚁 RichLab 前端团队</a></em></p><p>「奇怪的」规矩：</p><ul><li>命名：react hooks 要求 hooks 命名以 use 开头，作者觉得破坏了语义，应该以 _ 或者 $ 开头</li><li>调用时序：react hooks 区分不同的 state 是通过 hooks 的调用顺序，在内部维护一个链表，这个做法是相对简单粗暴的，所以这就是为什么 hooks 不能条件分支中使用，作者认为这种要求完全需要依赖开发者的经验或者 lint 工具，并不符合直觉。</li><li>useRef 的「排除万难」：useRef 仅在组件 mount 阶段初始化，后面 update 时引用同一个变量，但是作者这样多少有点违反 react hooks 的设计初衷，也即 useRef 并不函数式。</li></ul><p>有缺陷的生命周期：</p><ul><li>构造时：Class Component 和 Function Component 之间存在一个很大的区别，那就是后者每次 re-render 时都在重新调用自身，所以它并没有 constructor 来做某些仅执行一次的操作。</li><li>设计混乱的 useEffect：它实际上只监听能够触发 re-render 的变量，也就是 state，但是它接受的参数 deps 又不做任何限制，很难不让人认为是设计缺陷。</li></ul><p>useCallback：</p><ul><li>性能问题？无限套娃✓：使用 useCallback 是为了解决每次渲染都会创建一个新的回调函数，从而导致重新渲染的问题，但是使用 useCallback 也会引发一个更大的问题，那就是当useCallback之前存在依赖关系时，它们的引用维护也变得复杂。调用某个函数时要小心翼翼，你需要考虑它有没有引用过时的问题，如有遗漏又没有将其加入依赖数组，就会产生 Bug。</li></ul><p>小结：</p><ul><li>本文没有鼓吹 Class Component 拒绝使用 React Hooks 的意思，反而是希望通过细致地比对二者，从而更深入理解 Hooks。</li><li>React Hooks 的各种奇怪之处，也正是潜在症结之所在。</li><li>在 Hooks 之前，Function Component 都是 Stateless 的，小巧、可靠但功能有限。Hooks 为 Function Component 赋予了 State 能力并提供了生命周期，使 Function Component 的大规模使用成为了可能。</li><li>Hooks 的「优雅」来自向函数式的致敬，但useRef的滥用让 Hooks 离「优雅」相去甚远。</li><li>大规模实践 React Hooks 仍然有诸多问题，无论是从语义理解抑或是封装的必要性。</li><li>创新不易，期待 React 官方之后会有更好的设计吧。</li></ul><h3 id="DevTools-实现原理"><a href="#DevTools-实现原理" class="headerlink" title="DevTools 实现原理"></a><a href="https://mp.weixin.qq.com/s/H8iahg5WUOHXeRzvf0R01w?scene=25#wechat_redirect">DevTools 实现原理</a></h3><p><em>原文地址：<a href="https://mp.weixin.qq.com/s/H8iahg5WUOHXeRzvf0R01w?scene=25#wechat_redirect">《DevTools 实现原理》 | vivo 互联网浏览器内核团队</a></em></p><p>DevTools 架构：</p><ul><li>Chrome：TCP + CDP<ul><li>CDP（Chrome DevTools Protocol） 本质上是一个 JSON 协议，目前使用 Puppeteer 实现</li></ul></li><li>使用 WebSocket</li><li>Android：利用 ADB forward 端口转发能力连接 PC 和 Android 的网络访问</li></ul><p>内核实现</p><ul><li>Server 层，用于接收外部网络发过来的操作请求。</li><li>Agent 层，对于 Server 层发过来的请求，进行拆解，根据操作的类型不同，再分发给不同的 Agent 来处理。</li><li>Session 层，Session 是对不同的业务模块进行了一层抽象。过了 Session 层后，将会进入不同的业务模块，可以到达 V8， Blink 等。</li><li>业务层，就是具体的功能模块，比如 V8 模块，主要负责 JavaScript 的调试相关能力的支撑。</li></ul><h2 id="有趣的链接"><a href="#有趣的链接" class="headerlink" title="有趣的链接"></a>有趣的链接</h2><ul><li><p><a href="https://devtool.tech/tree">Tree 树形目录可视化生成器</a>：我们都知道 <code>tree</code> 这个命令，可以打印输出现有目录的树形结构，但现实中还存在一种情况，那就是需要输出并不存在的目录结构，这种需求在写开发设计文档时尤为常见，所以除了构造一个临时的目录，还可以使用这个工具直接生成树形目录结构。</p></li><li><p><a href="https://zh.z-lib.org/">Z-Library</a>：世界上最大的数字图书馆，在这里可以找到大量的电子书籍，格式包括：pdf、epub、mobi 等，对于笔者这种不爱看实体书的人来说，简直是神器。但需要注意每天一个 ip 会限制下载数量，未注册用户是 5 次，注册用户是 10 次，当然也可以通过捐赠来提高下载次数的限制。</p></li><li><p><a href="https://www.iizhi.cn/">毕方铺</a>：网盘搜索神器，个人认为是所有网盘搜索神器中最好的一个，所有资源都为用户自愿分享，下载需要耗费金币，你也可以上传你想要的分享的资源，别人购买你就能获取金币，当然到达一定金币后就可以提现。</p></li><li><p><a href="https://createfeed.fivefilters.org/index-mergefeeds.php?url%5B%5D=https://medium.com/feed/tag/open-source&max=20&order=feed">Feed Creator</a>：制作 RSS 源的工具，包括网页生成 RSS、合并多个 RSS 等功能；相信有些同学知道 <a href="https://docs.rsshub.app/">RSSHub</a> 这个开源项目，显然这个项目更加强大，但并不是所有场景都需要用到 RSSHub，这时候就可以使用 Feed Creator。分享一下我个人会在什么场景下使用 Feed Creator 而不是 RSSHub：对于某些访问需要科学上网的网站，我们可以直接通过它生成一个国内可以直接访问的 RSS 源。</p></li><li><p><a href="https://docs.microsoft.com/zh-cn/learn/paths/rust-first-steps/">Microsoft 的 Rust 入门教程</a>：要说这两年前端最新的技术莫过于 Rust 了，大量的前端基础设施都通过 Rust 重写了一遍，哪怕笔者这种学不动的人也需要学一些 Rust 的知识，但无奈一直没有找到满意的 Rust 教程，前段时间听闻微软出了一个 Rust 教程，第一次打开后就直接跟着学了两个星期，根本停不下来，真心不错。xdm，Rust 学起来吧！</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;我为什么要写周刊&quot;&gt;&lt;a href=&quot;#我为什么要写周刊&quot; class=&quot;headerlink&quot; title=&quot;我为什么要写周刊&quot;&gt;&lt;/a&gt;我为什么要写周刊&lt;/h2&gt;&lt;p&gt;前几天特地写了篇文章来分享一下我为什么要办这个周刊：《&lt;a href=&quot;/post/week</summary>
      
    
    
    
    
    <category term="weekly" scheme="https://4ark.me/tags/weekly/"/>
    
  </entry>
  
  <entry>
    <title>我为什么要写周刊</title>
    <link href="https://4ark.me/post/weekly-idea.html"/>
    <id>https://4ark.me/post/weekly-idea.html</id>
    <published>2022-02-14T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么想写周刊"><a href="#为什么想写周刊" class="headerlink" title="为什么想写周刊"></a>为什么想写周刊</h2><p>自从养成了阅读 RSS 的习惯以后，作为我获取信息的主要渠道，我每天都会花费 1 - 2 个小时去阅读大量的 RSS 订阅源，这其中的大部分基本都是只瞄一眼标题，或者快速阅读一下内容，而对于一些吸引我注意的标题，才会通过浏览器打开原文仔细阅读，当然这么多文章是无法一次性读完的，这时候会通过 <a href="https://chrome.google.com/webstore/detail/onetab/chphlpgkkbolifaimnlloiipkdnihall">OneTab</a> 扩展先保存起来，也就是充当稍后阅读的工具（题外话：我在 OneTab 上常年保存着 200+ 以上的标签页），如果读到觉得不错的文章，就会通过 <a href="https://chrome.google.com/webstore/detail/save-to-notion/ldmmifpegigmeammaeckplhnjbbpccmm">Save to Notion</a> 这个扩展保存到我的 Notion 页面中，使用这个扩展可以很方便地对文章进行分类、原文剪藏，方便后续快速索引。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202121723977.png?imageMogr2/format/webp"></p><p>但是后面我发现，大部分文章读完就忘了，能记下来的往往只有少部分，这是因为我没有针对文章的内容做总结，也就是用自己的话去输出这些文章的核心内容、以及一些更深入的思考，以此加深自己的理解。</p><p>于是，我又开了一个 Notion 页面，利用 Relation 字段去关联文章，大概长这样：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202202121826436.png?imageMogr2/format/webp"></p><p>但就这样「单机」玩，很难坚持下去，所以就索性把这个 Weekly 挂在 Blog 上，虽然也是基本没人看：）</p><p>但这意义就不一样了呀！无论是对保持更新频率、提高博客逼格都能提到一些帮助（不是吗？）。</p><p>所以，你会发现在 Blog 的顶部菜单栏里面多一个 Weekly 的栏目，当然也提供了 RSS 订阅。</p><h2 id="只是记录阅读吗"><a href="#只是记录阅读吗" class="headerlink" title="只是记录阅读吗"></a>只是记录阅读吗</h2><p>以上的确是我想办这个周刊的初衷，但我并不会局限于此，如果只是分享我阅读过的文章就未免显得过于学术性（流水账），我还是希望我这个周刊既有专业性的内容、也有我个人的一些思考在里面，毕竟有一些琐碎的事情不想专门开一篇文章来长篇大论，就特别适合写在我的周刊里面。还是那句话，我这个周刊的主要读者是我自己，所以这里也充当我一个定时输出我不成熟观点的地方。</p><p>其实已经有不少人在做这件事，就国内而言，最著名的莫过于阮一峰老师的 <a href="https://www.ruanyifeng.com/blog/weekly/">《科技爱好者周刊》</a>，截止本文编写之时，已经更新到 194 期了，几乎坚持每周一更（没有经过仔细核实）。虽然他是一个相对有争议的人，但我还是非常敬佩他，相信很多人和我一样，是通过他的文章来入门前端技术的，所以尊称他一声老师并不为过。</p><p>我不是他最早的一批读者，这当然是因为我比较年轻：），但是我曾经把他博客上所有的文章从头开始读了一遍，从 03 年最早一篇文章开始（可能还是更早），这么多年写作风格自然也有很大的转变，从以前一名愤青，写作文章主要都是关注一些社会、文学、经济等问题，到后来开始转行计算机，主要写一些技术入门、科技新闻的文章。但无论如何，就从他坚持做这件事二十年来看，这种态度非常值得我们学习。</p><p>也有人和我一样，刚刚开始做这件事，这不，前几天就看到了这个：<a href="https://www.codedump.info/post/20220116-weekly-1/">周刊第 1 期：开刊，数字化生活数据</a>。</p><p>总之，我希望和他们一样，通过这种方式来分享自己看到的东西、观点，多给自己一个与外界沟通的渠道。</p><h2 id="开刊日"><a href="#开刊日" class="headerlink" title="开刊日"></a>开刊日</h2><p>由于之前的比较零散，就从 2022 年 2 月 14 号这一天作为这个周刊的开始吧。</p><p>因为这一天意义非凡，首先当然是情人节，另外也是计算机的生日，不过更重要的是这一天也是我生日：）</p><p>可惜我们老家那边普遍过农历生日，所以要每隔 19 年才会碰上同一天生日，这周刊开在三年前就更有意义了。</p><p>不过每次想起我诞生于本世纪第一个情人节，还跟计算机同一天生日，想必我是一个无论在计算机还是感情方面都应该会有很高造诣的人，然而事实证明是我在这两方面都非常菜。</p><p>感谢阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;为什么想写周刊&quot;&gt;&lt;a href=&quot;#为什么想写周刊&quot; class=&quot;headerlink&quot; title=&quot;为什么想写周刊&quot;&gt;&lt;/a&gt;为什么想写周刊&lt;/h2&gt;&lt;p&gt;自从养成了阅读 RSS 的习惯以后，作为我获取信息的主要渠道，我每天都会花费 1 - 2 个小时去阅</summary>
      
    
    
    
    
    <category term="随笔" scheme="https://4ark.me/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>2021 年度总结</title>
    <link href="https://4ark.me/post/2021-summary.html"/>
    <id>https://4ark.me/post/2021-summary.html</id>
    <published>2022-01-01T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2021 已经走到尽头，在这一年中，世界上发生了很多事情，疫情仍在持续，国际形势在不断发生改变，就连娱乐圈你也不知道第二天睡醒后会吃出什么大瓜，总而言之，这又是不平凡的一年。</p><p>但是，仍然有无数像我一样的平凡人在过着平凡的生活，每天生活三点一线，为了生计奔波忙碌。</p><p>本文就记录一个平凡人如何度过他平凡的一年，以此给 2021 年画上一个平凡的句号。</p><p>：）抱歉你可能已经不认识「平凡」这两个字了 </p><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><h3 id="Q1：团队解散，找工作"><a href="#Q1：团队解散，找工作" class="headerlink" title="Q1：团队解散，找工作"></a>Q1：团队解散，找工作</h3><p>去年《<a href="https://4ark.me/posts/2020-summary.html#%E5%B7%A5%E4%BD%9C%E4%B8%8E%E6%88%90%E9%95%BF">2021 年度总结</a>》中有提到年末时我选择了离开广州，并回到我老家清远，与一位师兄组建了一个创业团队，然而还是太年轻，远远低估了创业这条道路的艰辛和风险，不到三个月团队就解散了。</p><p>深刻反省一下当时做这个决定真的不够慎重，压根没有结合自身情况来考虑这件事情。</p><p>这段时间也并非全无收获，我感觉到在四线城市的生活节奏要相对缓慢一些，比起大城市，我更喜欢这里，因为我这里有家的感觉，她属于我，我也属于她。</p><p>但当务之急就是尽快入职来维持收入，不过这个四线城市没有多少互联网公司，也只能选择广州了，所以最终是在 BOSS 直聘上面海投简历，由于当时正值金三银四的时候，招聘的公司也很多，所以不到两天就把一个星期的面试安排给排满了，当然也是因为我对公司并没多少要求，所以约我面试的公司也没几家算得上是心仪的，总之最终入职了一家郊区的小公司，并在附近租了个房子，这段经历在《<a href="https://4ark.me/post/2021-03-04-2020-feb-summary.html">二月总结</a>》中有提到。</p><h3 id="Q2：那一段悠闲的时光"><a href="#Q2：那一段悠闲的时光" class="headerlink" title="Q2：那一段悠闲的时光"></a>Q2：那一段悠闲的时光</h3><p>虽然大部分公司 HR 在面试的时候都会说公司基本不会加班，但大家懂的都懂：）</p><p>我之前也是待过小公司的，上班时间不会比大公司短，但我入职后，惊讶地发现大家几乎都在晚上六点准时下班。</p><p>由于我住的地方离公司比较近，通勤时间简直可以忽略不计，相当于每天工作只需要 6.5 个小时，我负责的工作内容就是写一些小程序、APP 内嵌的活动页，基本没有什么难度可言，经常会出现一天时间把活干完，剩下几天没事可干的情况。所以上班摸鱼也就习以为常了。但摸了不到一个月觉得这样下去自己迟早会废掉，索性将摸鱼的时间花在读源码上，于是又用了一个月时间把 Vue 生态库的源码都读了一遍，还顺便产出了一些笔记：</p><ul><li><a href="https://4ark.me/post/vuex-score-code.html">《vuex 源码解析》</a></li><li><a href="https://4ark.me/post/composition-api-score-code.html">《composition-api 源码解析》</a></li><li><a href="https://4ark.me/post/vue-router-score-code.html">《vue-router 源码解析》</a></li></ul><p>所以那段时间我的生活写照是这样的：每天睡到九点，起床吃早餐去公司，如果没有工作就自己整点活，主要是看源码，摸到晚上六点就下班去买菜自己回家煮饭，接着看一个小时左右《史记》，在本博客输出一些自己不太成熟的读书感悟：</p><ul><li><a href="https://4ark.me/posts/cong-si-bina-xue-xi-li-shi.html">《从思辨中学历史》</a></li><li><a href="https://4ark.me/post/about-si-ma-qian.html">《司马迁是一个什么样的人？》</a></li></ul><p>这可以说是我工作以后过得最悠闲的日子了。</p><h3 id="Q3：那一段痛苦的时光"><a href="#Q3：那一段痛苦的时光" class="headerlink" title="Q3：那一段痛苦的时光"></a>Q3：那一段痛苦的时光</h3><p>可惜好景不长，迎来了一个不好的消息，公司要搬迁，从原本的郊区搬到市中心地段，美名其曰乡巴佬进城了，但我的通勤时间从原本五分钟变成了七十分钟，这无疑是非常痛苦的，通勤时间如此之长足以让任何一份神仙工作的优势荡然无存。</p><p>当然我是可以选择搬家的，说实话我当时也已经在看房了，但突然有一天我破防了，起因是有一天与一个老同学闲聊，得知他跳槽后的薪资已比我高一倍，这让我的焦虑感瞬间就上来了，我自认在学校的时候能力并不比他差，所以我不断反思毕业这两年到底干了些什么？那几天睡觉前都在思考几个问题，是否我现在过得太安逸了？是否我的能力已经早已远远低于别人？我是否应该作出某些改变？</p><p>后面慢慢清醒起来，承认这样的自己并不成熟，我没必要跟任何人比较，虽说工资的高低确实可以从某种程度看出能力的差距，但不代表我现在拿的薪资就是我个人能力真正的写照，因为我这几个月确实可以说是在躺平。</p><p>但我还是有了一些想法，我需要出去面试证明自己的能力，从而让我内心平衡一些，于是我开始复习、刷题。原本的计划是一边复习一边面试，一直到明年的金三银四，再试着挑战一下大厂。然而有一件事打破了我的计划，公司开始延迟发放工资，足足拖了二十天，这自然能从侧面看到目前公司现金流不足，这时候就只能及时止损了。</p><p>于是只能赶鸭子上架出去面试，这一次我没有选择胡乱海投，而是先选择心仪的公司再进行投递，但由于简历上存在不少硬伤，学历低、频繁跳槽，目前 base 低却要求涨幅过高，所以很多公司都不给面试机会，有些公司的 HR 也会拿简历上的硬伤来说事，以此压低薪资，所幸还是有几家比较满意的，这才让我稍微恢复了一些自信。</p><p>最终我选择了一家做科技媒体的公司，因为我本身就是该媒体的读者，并且参与研发的产品也是我比较感兴趣的。</p><h3 id="Q4：那一段充实的时光"><a href="#Q4：那一段充实的时光" class="headerlink" title="Q4：那一段充实的时光"></a>Q4：那一段充实的时光</h3><p>新公司的通勤时间相对上一家要短一半，终于不用每天早起，生活、工作又开始慢慢回到正轨。</p><p>相对上一家公司的悠闲，这里的工作量还是比较饱和的，也逐渐开始习惯。除了完成日常的工作任务以外，也开始整了一点活，比如这个：</p><ul><li><a href="https://github.com/gd4Ark/husky/pull/1">support mercurial repo by gd4Ark</a></li></ul><p>另外还花了一个星期写了一篇技术文章：</p><ul><li><a href="https://4ark.me/post/how-object-keys-work.html">《一行 Object.keys() 引发的血案》</a></li></ul><p>值得一提的是，这篇文章在掘金上发布后，被评为每周精选文章，收到奖品：一个马克杯和帆布袋。</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291615563.image?imageMogr2/format/webp"></p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291615795.png?imageMogr2/format/webp"></p><p style="text-align:center;">懒得拍了，网上找的图</p><p>总的来说，这段时间相对比较充实，不过也有一些习惯被落下了，明年需要重新拾起来。</p><p>再晒一下公司送的新年礼品：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images202201291618945.png?imageMogr2/format/webp"></p><h2 id="年度盘点"><a href="#年度盘点" class="headerlink" title="年度盘点"></a>年度盘点</h2><h3 id="最喜欢的书"><a href="#最喜欢的书" class="headerlink" title="最喜欢的书"></a>最喜欢的书</h3><p>今年看过的书不多，其中比较喜欢的这几本：</p><ul><li><strong>《最初的爱情，最后的仪式》</strong></li><li><strong>《不平等的尸体》</strong></li><li><strong>《人间失格》</strong></li><li><strong>《丑陋的中国人》</strong></li></ul><h3 id="最喜欢的音乐"><a href="#最喜欢的音乐" class="headerlink" title="最喜欢的音乐"></a>最喜欢的音乐</h3><p>今年我从网易云音乐转到了 Spotify，终于可以实现听歌自由了。</p><p>今年最喜欢的音乐：</p><ul><li><strong>《梵高先生》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/572mdcKFCEMVgtSELmoIuU?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><ul><li><strong>《差不多先生》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/6fADwOnsMmCM70OAxDF3fc?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><ul><li><strong>《夕阳之歌》</strong></li></ul><iframe src="https://open.spotify.com/embed/track/5tVzG4tw3M9VLkcQ0fOtgF?utm_source=generator" width="40%" height="80" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe><h3 id="最喜欢的电影（电视剧）"><a href="#最喜欢的电影（电视剧）" class="headerlink" title="最喜欢的电影（电视剧）"></a>最喜欢的电影（电视剧）</h3><p>今年喜欢在 Netflix 看剧，所以看了不少的经典高分剧；另外用我的黑群晖下载了一些经典电影。</p><p>为此，我还特地用 notion 做了一个<a href="https://4ark.notion.site/4b4180c7bf3249c2b47bc9127150b240?v=3df58ff87655451c9873a8aadd9a72db">页面</a>，来记录我看过的那些电影（电视剧）。</p><p>这里盘点一下我今年最喜欢的几部电影：</p><ul><li><strong>《杀人回忆》</strong></li><li><strong>《拯救大兵瑞恩》</strong></li><li><strong>《触不可及》</strong></li><li><strong>《指环王系列》</strong></li><li><strong>《金福南杀人事件》</strong></li><li><strong>《出租车司机》</strong>（是罗伯特·德尼罗主演， “Are You Talking to Me?” 那部</li></ul><p>下面是我今年最喜欢的电视剧：</p><ul><li><strong>《权利的游戏》</strong>（如果不烂尾的话多好</li><li><strong>《请回答 1988》</strong></li><li><strong>《性爱自修室》</strong></li><li><strong>《绝命毒师》</strong>、<strong>《风骚律师》</strong></li></ul><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这就是我平凡的一年，是一个年轻人迷茫的一年，我开始接受自己只是一个极其普通的平凡人，接受自己并不优秀的事实，我也并没有雄心壮志去改变世界，有时候甚至连改变自己都无法做到，我只想好好地活下去，做我喜欢做的事情。</p><p>我很喜欢罗翔老师的这几句话：</p><blockquote><p>人最大的痛苦就是在于无法跨越知道和做到的那个鸿沟。笛卡尔说：“我思故我在”，这个很对，但是，“我思故我在”会经常让我们沉浸于一种幻想之中，就是我们只要思考到了，我们就能做到。但其实不是这样。</p></blockquote><blockquote><p>因为人要接受事与愿违啊。我们太有限了，我们只能做我们觉得对的事情，然后，接受它的事与愿违。</p></blockquote><blockquote><p>我们登上并非我们所选择的舞台，演出并非我们选择的剧本。我们自己一生中能够决定的东西很少，可能只有百分之五的剧本，百分之九十五的东西是我们决定不了的。我们决定不了我们的出身，决定不了我们的智商，更决定不了我们一生中的贵人相助。很多时候我们经常会羡慕别人剧本，但是没有谁的剧本值得羡慕，很多人的剧本就是专门演给别人看的。而你要做的就是演好属于自己的剧本。如果你不幸遇到了某些挫折，你有两种选择，一种是弃演，一种是把既定的剧本演好，即使过程会痛苦，但一定很独特并很精彩。</p></blockquote><p>所以，就算「有人出生在罗马，有人生来是牛马」，我们也不要轻易放弃自己，即便我们并不优秀，你也要去接受，这就是属于你的剧本，无论你的选择是躺平还是奋斗，那是你的自由，没有人可以谴责你。</p><p>最后，以一首西城男孩演唱《平凡之路》，来结束这平凡的 2021。</p><iframe src="//player.bilibili.com/player.html?aid=592381368&bvid=BV17q4y1B7BR&cid=463084542&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe><h2 id="2022？"><a href="#2022？" class="headerlink" title="2022？"></a>2022？</h2><p>好好活着。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;2021 已经走到尽头，在这一年中，世界上发生了很多事情，疫情仍在持续，国际形势在不断发生改变，就连娱乐圈你也不知道第二天睡醒后会吃出什么大</summary>
      
    
    
    
    
    <category term="总结" scheme="https://4ark.me/tags/%E6%80%BB%E7%BB%93/"/>
    
    <category term="年终总结" scheme="https://4ark.me/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>一行 Object.keys() 引发的血案</title>
    <link href="https://4ark.me/post/how-object-keys-work.html"/>
    <id>https://4ark.me/post/how-object-keys-work.html</id>
    <published>2021-12-06T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h2><p>有一天上线后大佬在群里反馈了一个问题，他刚发的动态在生成分享卡片的时候，卡片底部的小程序码丢失了，然而其他小伙伴都表示在自己手机上运行正常。事实上大佬也说除了这条动态以外，其它都是正常的。</p><p>说明这个 BUG 需要特定的动态卡片 + 特定的设备才能复现，所幸坐我对面的小姐姐手机与大佬是同款，也能复现 BUG，避免了作为社恐的我要去找大佬借手机测试的尴尬。</p><p>先交代一下项目背景，这是一个微信小程序项目，其中生成分享卡片功能用到的是一个叫 <a href="https://github.com/wg-front/wxml2canvas">wxml2canvas</a> 的库，然而该库目前看上去已经「年久失修」，上面所说的 BUG 就是因为这个库，本文主要对其进行「鞭尸」之余，顺便分享一下排查该 BUG 的过程、以及如何从 ECMAScript 规范中找到关于 <code>Object.keys()</code> 返回顺序的规范定义，最后介绍一下在 V8 引擎中是如何处理对象属性的。</p><p>希望大家在阅读本文后，不会再因为搞不懂  <code>Object.keys()</code> 输出的顺序而犯错导致产生莫名其妙的 BUG。</p><h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><blockquote><p>浪费读者的时间是可耻的。———— 鲁迅</p></blockquote><p>本文很长，如果你不想阅读整篇文章，可以阅读这段摘要；如果你打算阅读整篇文章，那么你完全可以跳过本段。</p><p>如果阅读摘要时未能帮助你理解，可以跳转到对应章节进行详细阅读。</p><p>摘要：</p><ol><li>这个 BUG 是如何产生的？</li></ol><ul><li><code>wxml2canvas</code> 在绘制的时候，会根据一个叫做 <code>sorted</code> 的对象对它的 keys 进行遍历，该对象的 key 为节点的 top 值，value 为节点元素；问题就是出在这里，该库作者误以为 <code>Object.keys()</code> 总是会按照实际创建属性的顺序返回，<strong>然而当 key 为正整数的时候</strong>，返回顺序就不符合原本的预期了，会出现了绘制顺序错乱，从而导致这个 BUG 的产生。</li><li>源码：<a href="https://github.com/wg-front/wxml2canvas/blob/master/src/index.js#L1146">src/index.js#L1146</a> 和 <a href="https://github.com/wg-front/wxml2canvas/blob/master/src/index.js#L829">src/index.js#L829</a></li></ul><ol start="2"><li>如何解决这个 BUG</li></ol><ul><li>由于对象的 key 是一个数字，那么 key 有可能会是整数，也有可能是浮点数。但是预期行为是希望  <code>Object.keys()</code> 按照属性实际创建的顺序返回，那只要将所有 key 都强制转换为浮点数就好了。</li></ul><ol start="3"><li><code>Object.keys()</code> 是按照什么顺序返回值的？</li></ol><ul><li><code>Object.keys()</code> 返回顺序与遍历对象属性时的顺序一样，调用的是 <code>[[OwnPropertyKeys]]()</code> 内部方法。</li><li>根据 <a href="https://262.ecma-international.org/6.0/#sec-ordinary-object-internal-methods-and-internal-slots-ownpropertykeys">ECMAScript 规范</a>，在输出 keys 时会<strong>先将所有 key 为数组索引类型（正整数）从小到大的顺序排序，然后将所有字符串类型（包括负数、浮点数）的 key 按照实际创建的顺序来排序</strong>。</li></ul><ol start="4"><li>V8 内部是如何处理对象属性的？</li></ol><ul><li>V8 在存储对象属性时，为了提高访问效率，会分为<strong>常规属性(properties)</strong> 和 <strong>排序属性(elements)</strong><ul><li><strong>排序属性(elements)</strong> ，就是数组索引类型的属性（也就是正整数类型）。</li><li><strong>常规属性(properties)</strong> ，就是字符串类型的属性（也包括负数、浮点数）。</li><li>以上两种属性都会存放在线性结构中，称为<strong>快属性</strong>。</li><li>然而这样每次查询都有一个间接层，会影响效率，所以 V8 引入<strong>对象内属性(in-object-properties)</strong>  。</li></ul></li><li>V8 会为每一个对象关联一个隐藏类，用于记录该对象的形状，相同形状的对象会共用同一个隐藏类。<ul><li>当对象添加、删除属性的时候，会创建一个新的对应的<strong>隐藏类</strong>，并重新关联。</li></ul></li><li><strong>对象内属性</strong>会将部分<strong>常规属性</strong>直接放在对象第一层，所以它访问效率是最高的。<ul><li>当<strong>常规属性</strong>的数量<strong>少于对象初始化时的属性数量</strong>时，<strong>常规属性</strong>会直接作为<strong>对象内属性</strong>存放。</li></ul></li><li>虽然<strong>快属性</strong>访问速度快，但是从线性结构中添加或删除时执行效率会非常低，因此如果属性特别多、或出现添加和删除属性时，就会将<strong>常规属性</strong>从线性存储改为字典存储，这就是<strong>慢属性</strong>。</li></ul><p>可以看一下这两张图帮助理解：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/object-keys.jpeg"></p><p style="text-align:center;">V8 常规属性和排序属性</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/v8-object-keys.jpeg"></p><p style="text-align:center;">V8 对象内属性、快属性和慢属性</p><p style="text-align:center;"><a href="https://time.geekbang.org/column/intro/100048001">图片出处：《图解 Google V8》 —— 极客时间</a></p><h2 id="如何解决该-BUG"><a href="#如何解决该-BUG" class="headerlink" title="如何解决该 BUG"></a>如何解决该 BUG</h2><p>由于是特定的动态 + 特定的设备才能复现问题，可以很轻易地排除掉网络原因，通过在 <code>wxml2canvas</code> 输出绘制的节点列表，也能看到小程序码相关的节点。</p><p>既然 <code>wxml2canvas</code> 已经接收到小程序码的节点，却没有绘制出来，那么问题自然就出在 <code>wxml2canvas</code>  内部，不过已经见怪不怪了，在我加入项目以后就已经多次因为这操蛋的 <code>wxml2canvas</code> 出现各种问题而搞得头皮发麻，有机会一定要替换掉这个库，但由于已经有很多页面在依赖这个库，现在也只能硬着头皮上。</p><p>首先怀疑是小程序码节点的坐标位置不太对，通过对比，发现位置相差不大，排除该原因。</p><p>然后对比所有节点的绘制顺序，发现了一个不太寻常的点，在复现 BUG 的手机上，绘制小程序码节点的时机是比较靠前的，但由于它在卡片底部，所以在正常情况下，应该是比较靠后才对。</p><p>于是通过查看相关代码，果然发现了其中的玄机：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/WechatIMG100.jpeg"></p><p>在绘制的时候，通过遍历 <code>sorted</code> 对象，从上往下、从左到右依次绘制，但是通过对比两台手机的 <code>Object.keys()</code>，发现了它们的输出是不一样的，这时候我就明白怎么回事了。</p><p>先来说说这个 <code>sorted</code> 对象，它是一个 key 为节点 top 值，value 为所有相同 top 值（同一行）的元素数组。</p><p>下面是生成它的代码：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/Snipaste_2021-12-08_00-07-16.png"></p><p>问题就发生在前面所说的 <code>Object.keys()</code> 这里，我们先来看个 🌰：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sorted = &#123;&#125;</span><br><span class="line"></span><br><span class="line">sorted[<span class="number">300</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">200</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">100</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(sorted)) <span class="comment">// 输出什么呢？</span></span><br></pre></td></tr></table></figure><p>相信大部分同学都知道答案是：[‘100’, ‘200’, ‘300’]。</p><p>如果在有浮点数的情况呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sorted = &#123;&#125;</span><br><span class="line"></span><br><span class="line">sorted[<span class="number">300</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">100</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">200</span>] = &#123;&#125;</span><br><span class="line">sorted[<span class="number">50.5</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(sorted)) <span class="comment">// 这次又输出什么呢？</span></span><br></pre></td></tr></table></figure><p>会不会有同学以为答案是：[‘50.5’, ‘100’, ‘200’, ‘300’] 呢？</p><p>但正确的答案应该是：[‘100’, ‘200’, ‘300’,’50.5’]。</p><p>所以我合理地猜测 <code>wxml2canvas</code> 的作者就是犯了这样的错误，他可能以为 <code>Object.keys</code>  会根据 key 从小到大的顺序返回，因此满足从上往下绘制的逻辑。但是他却没有考虑浮点数的情况，所以当某个节点 top 值为整数的时候，会比其他 top 值为浮点数的节点更早地绘制，导致绘制后面的节点时覆盖了前面的节点。</p><p>于是，当我把代码改成这样后，分享卡片的小程序码就正常绘制出来了：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Object</span><br><span class="line">  .keys(sorted)</span><br><span class="line"><span class="addition">+ .sort((a, b)=&gt; a - b)</span></span><br><span class="line">  .forEach((top, topIndex) =&gt; &#123;</span><br><span class="line">    //  do something</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>OK，搞定收工。</p><p><strong>测试小姐姐</strong>：慢着！影响到其它地方了。</p><p>我一看，果然。于是再次经过对比，发现原来大部分情况下，top 值都会是浮点数，而本次出 BUG 的卡片小程序码只是非常凑巧地为整数，导致绘制顺序不对。</p><p>我才发现 <code>wxml2canvas</code> 原本的逻辑是想根据 <code>sorted</code> 创建的顺序来绘制，但是没有考虑 key 为整数的情况。</p><p>所以，最后这样修改解决问题：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">_sortListByTop (list = []) &#123;</span><br><span class="line">    let sorted = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // 粗略地认为2px相差的元素在同一行</span><br><span class="line">    list.forEach((item, index) =&gt; &#123;</span><br><span class="line"><span class="deletion">-       let top = item.top;</span></span><br><span class="line"><span class="addition">+       let top = item.top.toFixed(6); // 强制添加小数点，将整数转为浮点数</span></span><br><span class="line">        if (!sorted[top]) &#123;</span><br><span class="line">            if (sorted[top - 2]) &#123;</span><br><span class="line">                top = top - 2;</span><br><span class="line">            &#125;else if (sorted[top - 1]) &#123;</span><br><span class="line">                top = top - 1;</span><br><span class="line">            &#125; else if (sorted[top + 1]) &#123;</span><br><span class="line">                top = top + 1;</span><br><span class="line">            &#125; else if (sorted[top + 2]) &#123;</span><br><span class="line">                top = top + 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sorted[top] = [];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sorted[top].push(item);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return sorted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，是因为 <code>wxml2canvas</code> 作者对 <code>Object.keys()</code> 返回顺序的机制不了解，才导致出现这样的 BUG。</p><p>不知道是否也有同学犯过同样的错误，为避免再次出现这样的情况，非常有必要深入、全面地介绍一下 <code>Object.keys()</code> 的执行机制。 </p><p>所以接下来就跟随我一探究竟吧。</p><h2 id="深入理解-Object-keys"><a href="#深入理解-Object-keys" class="headerlink" title="深入理解 Object.keys()"></a>深入理解 Object.keys()</h2><p>可能会有同学说： <code>Object.keys()</code> 又不是什么新出的 API， Google 一下不就行了，何必大费周章写一篇文章来介绍呢？</p><p>的确通过搜索引擎可以很快就能知道 <code>Object.keys()</code> 的返回顺序是怎样的，但是很多都只流于表面，甚至我还见过这样片面的回答：数字排前面，字符串排后面。</p><p>所以这次我想试着追本溯源，通过第一手资料来获取信息，轻易相信口口相传得来的信息，都极有可能是片面的、甚至是错误的。</p><p>PS：其实不光技术，我们在对待其它不了解的事物都应保持同样的态度。 </p><p>我们先来看看在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys">MDN</a> 上关于 <code>Object.keys()</code> 的描述：</p><blockquote><p><code>Object.keys()</code> 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和正常循环遍历该对象时返回的顺序一致 。</p></blockquote><p>emmm… 并没有直接告诉我们输出顺序是什么，不过我们可以看看上面的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys#polyfill">Polyfill</a> 是怎么写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.keys) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty,</span><br><span class="line">        hasDontEnumBug = !(&#123;<span class="attr">toString</span>: <span class="literal">null</span>&#125;).propertyIsEnumerable(<span class="string">&#x27;toString&#x27;</span>),</span><br><span class="line">        dontEnums = [</span><br><span class="line">          <span class="string">&#x27;toString&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;toLocaleString&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;valueOf&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;hasOwnProperty&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;isPrototypeOf&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;propertyIsEnumerable&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;constructor&#x27;</span></span><br><span class="line">        ],</span><br><span class="line">        dontEnumsLength = dontEnums.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">&#x27;function&#x27;</span> || obj === <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Object.keys called on non-object&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> result = [];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasOwnProperty.call(obj, prop)) result.push(prop);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hasDontEnumBug) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; dontEnumsLength; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasOwnProperty.call(obj, dontEnums[i])) result.push(dontEnums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实就是利用 <code>for...in</code> 来进行遍历，接下来我们可以再看看关于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in">for…in</a> 的文档，然而里面也没有告诉我们顺序是怎样的。</p><p>既然 MDN 上没有，那我们可以直接看 ECMAScript 规范，通常 MDN 上都会附上关于这个 API 的规范链接，我们直接点开最新（Living Standard）的那个，下面是关于 Object.keys 的<a href="https://tc39.es/ecma262/#sec-object.keys">规范定义</a>：</p><blockquote><p>When the keys function is called with argument <em>O</em>, the following steps are taken:</p><ol><li> Let <em>obj</em> be ? <a href="https://tc39.es/ecma262/#sec-toobject">ToObject</a>(<em>O</em>).</li><li> Let <em>nameList</em> be ? <a href="https://tc39.es/ecma262/#sec-enumerableownpropertynames">EnumerableOwnPropertyNames</a>(<em>obj</em>, key).</li><li> Return <a href="https://tc39.es/ecma262/#sec-createarrayfromlist">CreateArrayFromList</a>(<em>nameList</em>).</li></ol></blockquote><p>对象属性列表是通过 <code> EnumerableOwnPropertyNames</code> 获取的，这是它的<a href="https://tc39.es/ecma262/#sec-enumerableownpropertynames">规范定义</a>：</p><blockquote><p>The abstract operation EnumerableOwnPropertyNames takes arguments O (an Object) and kind (key, value, or key+value). It performs the following steps when called:</p><ol><li><p>Let ownKeys be ? O.<a href="">[OwnPropertyKeys]</a>.</p></li><li><p>Let properties be a new empty List.</p></li><li><p>For each element key of ownKeys, do<br> a. If Type(key) is String, then</p><ol><li>Let desc be ? O.<a href="key">[GetOwnProperty]</a>.</li><li>If desc is not undefined and desc.[[Enumerable]] is true, then<br> a. If kind is key, append key to properties.<br> b. Else,<ol><li>Let value be ? Get(O, key).</li><li>If kind is value, append value to properties.</li><li>Else<br> i. Assert: kind is key+value.<br> ii. Let entry be ! CreateArrayFromList(« key, value »).<br> iii. Append entry to properties.</li></ol></li></ol></li><li><p>Return properties.</p></li></ol></blockquote><p><strong>敲黑板！</strong> 这里有个细节，请同学们多留意，后面会考。</p><p>我们接着探索，<code>OwnPropertyKeys</code> 最终返回的 <code>OrdinaryOwnPropertyKeys</code>：</p><blockquote><p>The [[OwnPropertyKeys]] internal method of an ordinary object O takes no arguments. It performs the following steps when called:</p><ol><li>Return ! <a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys">OrdinaryOwnPropertyKeys(O)</a>.</li></ol></blockquote><p>重头戏来了，关于 keys 如何排序就在 <code>OrdinaryOwnPropertyKeys</code> 的<a href="https://tc39.es/ecma262/#sec-ordinaryownpropertykeys">定义</a>中：</p><blockquote><p>The abstract operation OrdinaryOwnPropertyKeys takes argument O (an Object). It performs the following steps when called:</p><ol><li>Let keys be a new empty List.</li><li>For each own property key P of O such that P is an array index, in ascending numeric index order, do<br> a. Add P as the last element of keys.</li><li>For each own property key P of O such that Type(P) is String and P is not an array index, in ascending chronological order of property creation, do<br> a. Add P as the last element of keys.</li><li>For each own property key P of O such that Type(P) is Symbol, in ascending chronological order of property creation, do<br> a. Add P as the last element of keys.</li><li>Return keys.</li></ol></blockquote><p>到这里，我们已经知道我们想要的答案，这里总结一下：</p><ol><li>创建一个空的列表用于存放 keys</li><li>将所有<strong>合法的数组索引</strong>按升序的顺序存入</li><li>将所有<strong>字符串类型索引</strong>按属性创建时间以升序的顺序存入</li><li>将所有 <strong><code>Symbol</code> 类型索引</strong>按属性创建时间以升序的顺序存入</li><li>返回 keys</li></ol><p>这里顺便也纠正一个普遍的误区：有些回答说将所有属性为数字类型的 key 从小到大排序，其实不然，还必须要符合<strong>「合法的数组索引」</strong>，也即只有<strong>正整数</strong>才行，负数或者浮点数，一律当做字符串处理。</p><p>PS：严格来说对象属性没有数字类型的，无论是数字还是字符串，都会被当做字符串来处理。</p><p>我们结合上面的规范，来思考一下下面这段代码会输出什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testObj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">testObj[-<span class="number">1</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="number">1</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="number">1.1</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;c&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;b&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;a&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="built_in">Symbol</span>(<span class="number">1</span>)] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="built_in">Symbol</span>(<span class="string">&#x27;b&#x27;</span>)] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">testObj[<span class="string">&#x27;d&#x27;</span>] = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(testObj))</span><br></pre></td></tr></table></figure><p>请认真思考后，在这里核对你的答案是否正确：</p><details>  <summary>查看结果</summary>    <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;<span class="number">1</span>&#x27;, &#x27;<span class="number">2</span>&#x27;, &#x27;<span class="number">-1</span>&#x27;, &#x27;<span class="number">1.1</span>&#x27;, &#x27;c&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;d&#x27;]</span><br></pre></td></tr></table></figure><p>  是否与你想象的一致？你可能会奇怪为什么没有 <code>Symbol</code> 类型。</p><p>  还记得前面敲黑板让同学们留意的地方吗，因为在 <code>EnumerableOwnPropertyNames</code> 的规范中规定了返回值只应包含字符串属性（上面说了数字其实也是字符串）。</p><p>  所以 Symbol 属性是不会被返回的，可以看 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames">MDN</a> 上关于 <code>Object.getOwnPropertyNames()</code> 的描述。</p><p>  如果要返回 Symbol 属性可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols">Object.getOwnPropertySymbols()</a>。</p></details><p>看完 ECMAScript 的规范定义，相信你不会再搞错 <code>Object.keys()</code> 的输出顺序了。但是你好奇 V8 是如何处理对象属性的吗，下一节我们就来讲讲。</p><h2 id="V8-是如何处理对象属性的"><a href="#V8-是如何处理对象属性的" class="headerlink" title="V8 是如何处理对象属性的"></a>V8 是如何处理对象属性的</h2><p>在 V8 的官方博客上有一篇文章<a href="https://v8.dev/blog/fast-properties">《Fast properties in V8》</a>（<a href="https://blog.crimx.com/2018/11/25/v8-fast-properties/">中译版</a>），非常详细地向我们解释了 V8 内部如何处理 JavaScript 的对象属性，强烈推荐阅读。</p><p>另外再推荐一下极客时间上的课程《<a href="https://time.geekbang.org/column/intro/100048001">图解 Google V8</a>》（毕竟本文借用了里面的图片，怎么好意思不推荐）。</p><p>本节内容主要参考这两个地方，下面我们来总结一下。</p><p>首先，V8 为了提高对象属性的访问效率，将属性分为两种类型：</p><ul><li><p><strong>排序属性(elements)</strong> ，就是符合数组索引类型的属性（也就是正整数）。</p></li><li><p><strong>常规属性(properties)</strong> ，就是字符串类型的属性（也包括负数、浮点数）。</p></li></ul><p>所有的<strong>排序属性</strong>都会存放在一个线性结构中，线性结构的特点就是支持通过索引随机访问，所以能加快访问速度，对于存放在线性结构的属性都称为<strong>快属性</strong>。</p><p><strong>常规属性</strong>也会存放在另一个线性结构中，可以看下面这张图帮助理解：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/object-keys.jpeg" alt="img"></p><p style="text-align:center;">V8 排序属性和常规属性</p><p>但是<strong>常规属性</strong>还需要做一些额外的处理，这里我们要先介绍一下什么是<strong>隐藏类</strong>。</p><p>由于 JavaScript 在运行时是可以修改对象属性的，所以在查询的时候会比较慢，可以看回上面那张图，每次访问一个属性的时候都需要经过多一层的访问，而像 C++ 这类静态语言在声明对象之前需要定义这个对象的结构（形状），经过编译后每个对象的形状都是固定的，所以在访问的时候由于知道了属性的偏移量，自然就会比较快。</p><p>V8 采用的思路就是将这种机制应用在 JavaScript 对象中，所以引入了<strong>隐藏类</strong>的机制，你可以简单的理解<strong>隐藏类</strong>就是描述这个对象的形状、包括每个属性对应的位置，这样查询的时候就会快很多。</p><p>关于<strong>隐藏类</strong>还有几点要补充：</p><ol><li>对象的第一个字段指向它的<strong>隐藏类</strong>。</li><li>如果两个对象的形状是完全相同的，会共用同一个<strong>隐藏类</strong>。</li><li>当对象添加、删除属性的时候，会创建一个新的对应的<strong>隐藏类</strong>，并重新指向它。</li><li>V8 有一个转换树的机制来创建隐藏类，不过本文不赘述，有兴趣可以看<a href="https://v8.dev/blog/fast-properties#hiddenclasses-and-descriptorarrays">这里</a>。</li></ol><p>解释完隐藏类，我们再回头来讲讲<strong>常规属性</strong>，通过上面那张图我们很容易发现一个问题，那就是每次访问一个属性的时候，都需要经过一个间接层才能访问，这无疑降低了访问效率，为了解决这个问题，V8 又引入了一个叫做<strong>对象内属性</strong>，顾名思义，它会将某些属性直接存放在对象的第一层里，它的访问是最快的，如下图所示：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/%E4%B8%8B%E8%BD%BD.jpeg"></p><p style="text-align:center;">V8 对象内属性</p><p>但要注意，<strong>对象内属性</strong>只存放<strong>常规属性</strong>，排序属性依旧不变。而且需要常规属性的数量<strong>小于</strong>某个数量的时候才会直接存放<strong>对象内属性</strong>，那这个数量是多少呢？</p><p>答案是取决于<strong>对象初始化时的大小</strong>。</p><p>PS：有些文章说是少于 10 个属性时才会存放对象内属性，<strong>别被误导了</strong>。</p><p>除了<strong>对象内属性</strong>、<strong>快属性</strong>以外，还有一个<strong>慢属性</strong>。</p><p>为什么会有<strong>慢属性</strong>呢？<strong>快属性</strong>虽然访问很快，但是如果要从对象中添加或删除大量属性，则可能会产生大量时间和内存开销来维护<strong>隐藏类</strong>，所以在<strong>属性过多或者反复添加、删除属性时</strong>会将<strong>常规属性</strong>的存储方式从线性结构变成字典，也就是降级到<strong>慢属性</strong>，而由于<strong>慢属性</strong>的信息不会再存放在<strong>隐藏类</strong>中，所以它的访问会比<strong>快属性</strong>要慢，但是可以高效地添加和删除属性。可以通过下图帮助理解：</p><p><img src="https://gd4ark-1258805822.cos.ap-guangzhou.myqcloud.com/images/v8-object-keys.jpeg" alt="img"></p><p style="text-align:center;">V8 慢属性</p><p>写到这里，我觉得自己对 V8 的快属性、慢属性这些知识已经非常了解，简直要牛逼到上天了。</p><p>但当我看到这段代码的时候：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFastProperties</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*jshint -W027*/</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    f.prototype = obj;</span><br><span class="line">    ASSERT(<span class="string">&quot;%HasFastProperties&quot;</span>, <span class="literal">true</span>, obj);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">    <span class="built_in">eval</span>(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的心情是这样的：</p><img src="https://ozinparis.com/wp-content/uploads/2016/04/jon-snow-know-nothing-e1461048094110-1.jpg" style="text-align: left; margin-left: 0;" /><p>关于这段代码是如何能让 V8 使用对象<strong>快属性</strong>的可以看这篇文章：<a href="https://zhuanlan.zhihu.com/p/25069272">开启 V8 对象属性的“fast”模式</a>。</p><p>另外也可以看一下这段代码：<a href="https://github.com/sindresorhus/to-fast-properties/blob/main/index.js">to-fast-properties/index.js</a>。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>当在开发时遇到一个简单的错误，通常可以很快地利用搜索引擎解决问题，但如果只是面向 Google 编程，可能在技术上很难会有进步，所以我们不光要能解决问题，还要理解这个产生问题的背后的原因到底是什么，也就是知其然更知其所以然。</p><p>真的非常建议每个 JavaScript 开发者都应该去了解一些关于 V8 或其它 JavaScript 引擎的知识，无论你是通过什么途径（真的没有打广告），这样能保证我们在编写 JavaScript 代码时出现问题可以更加地得心应手。</p><p>最后，本文篇幅有限，部分细节难免会有遗漏，非常建议有兴趣深入了解的同学可以延伸阅读下面的列表。</p><p>感谢阅读。</p><h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ul><li><a href="https://v8.dev/blog/fast-properties">Fast properties in V8</a><ul><li><a href="https://blog.crimx.com/2018/11/25/v8-fast-properties/">中译版</a></li></ul></li><li><a href="https://time.geekbang.org/column/intro/100048001">《图解 Google V8》 —— 极客时间</a></li><li><a href="https://blog.dashlane.com/how-is-data-stored-in-v8-js-engine-memory/">How is data stored in V8 JS engine memory?</a></li><li><a href="https://z3rog.tech/blog/2020/fast-properties.html">V8 中的快慢属性与快慢数组</a></li><li><a href="https://zhuanlan.zhihu.com/p/25069272">开启 V8 对象属性的“fast”模式</a></li><li><a href="https://262.ecma-international.org/6.0/">ECMAScript® 2015 Language Specification</a></li><li><a href="https://stackoverflow.com/questions/5525795/does-javascript-guarantee-object-property-order">Does JavaScript guarantee object property order? —— stackoverflow</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;故事背景&quot;&gt;&lt;a href=&quot;#故事背景&quot; class=&quot;headerlink&quot; title=&quot;故事背景&quot;&gt;&lt;/a&gt;故事背景&lt;/h2&gt;&lt;p&gt;有一天上线后大佬在群里反馈了一个问题，他刚发的动态在生成分享卡片的时候，卡片底部的小程序码丢失了，然而其他小伙伴都表示在自己</summary>
      
    
    
    
    
    <category term="前端" scheme="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://4ark.me/tags/JavaScript/"/>
    
    <category term="V8" scheme="https://4ark.me/tags/V8/"/>
    
  </entry>
  
  <entry>
    <title>vue-router 源码解析</title>
    <link href="https://4ark.me/post/vue-router-score-code.html"/>
    <id>https://4ark.me/post/vue-router-score-code.html</id>
    <published>2021-07-16T00:00:00.000Z</published>
    <updated>2022-05-17T05:28:58.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是针对 vue-router <a href="https://github.com/vuejs/vue-router/releases/tag/v3.5.2">v3.5.2</a> 版本的一次源码解析，由于笔者水平有限，有些地方写得比较混乱，还望多多包涵。</p><p>希望本文能够给那些想阅读 vue-router 源代码却又不知从何上手的同学们给予一些帮助。</p><h2 id="一、-new-Router-时发生了什么？"><a href="#一、-new-Router-时发生了什么？" class="headerlink" title="一、 new Router 时发生了什么？"></a>一、 new Router 时发生了什么？</h2><p>对应源码在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/index.js">src/index.js</a>，下面讲一下它做了哪些操作：</p><h3 id="1-声明一些变量"><a href="#1-声明一些变量" class="headerlink" title="1. 声明一些变量"></a>1. 声明一些变量</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前实例</span></span><br><span class="line"><span class="built_in">this</span>.app = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 存在多实例的话则保存</span></span><br><span class="line"><span class="built_in">this</span>.apps = []</span><br><span class="line"><span class="comment">// 传入的配置</span></span><br><span class="line"><span class="built_in">this</span>.options = options</span><br><span class="line"><span class="comment">// 存放已注册的一些导航守卫</span></span><br><span class="line"><span class="built_in">this</span>.beforeHooks = []</span><br><span class="line"><span class="built_in">this</span>.resolveHooks = []</span><br><span class="line"><span class="built_in">this</span>.afterHooks = []</span><br><span class="line"><span class="comment">// 创建 matcher</span></span><br><span class="line"><span class="built_in">this</span>.matcher = createMatcher(options.routes || [], <span class="built_in">this</span>)</span><br></pre></td></tr></table></figure><h3 id="2-创建-matcher"><a href="#2-创建-matcher" class="headerlink" title="2. 创建 matcher"></a>2. 创建 <code>matcher</code></h3><p><code>createMatcher</code> 的源码位置在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/create-matcher.js">src/create-matcher.js</a>，这个方法的整体是这样的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createMatcher</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  router: VueRouter</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Matcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathList, pathMap, nameMap &#125; = createRouteMap(routes)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addRoutes</span>(<span class="params">routes</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addRoute</span>(<span class="params">parentOrRoute, route</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getRoutes</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    raw: RawLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">    currentRoute?: Route,</span></span></span><br><span class="line"><span class="params"><span class="function">    redirectedFrom?: Location</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">Route</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">redirect</span>(<span class="params">record: RouteRecord, location: Location</span>): <span class="title">Route</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">alias</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    record: RouteRecord,</span></span></span><br><span class="line"><span class="params"><span class="function">    location: Location,</span></span></span><br><span class="line"><span class="params"><span class="function">    matchAs: string</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">Route</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_createRoute</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    record: ?RouteRecord,</span></span></span><br><span class="line"><span class="params"><span class="function">    location: Location,</span></span></span><br><span class="line"><span class="params"><span class="function">    redirectedFrom?: Location</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>): <span class="title">Route</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    match,</span><br><span class="line">    addRoute,</span><br><span class="line">    getRoutes,</span><br><span class="line">    addRoutes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是两点：</p><ol><li>根据传入的路由配置生成三张表：<code>pathList</code>、 <code>pathMap</code>、 <code>nameMap</code>，这样后面就可以更高效地访问路由表。</li><li>返回一些方法，让它可以获取，操作这三张表。</li></ol><h3 id="3-根据路由配置生成三张表"><a href="#3-根据路由配置生成三张表" class="headerlink" title="3. 根据路由配置生成三张表"></a>3. 根据路由配置生成三张表</h3><p><code>createRouteMap</code> 的源码位置在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/create-route-map.js">src/create-route-map.js</a>，可以点开来对照看。</p><p>我们先不管其它逻辑，只关注它在第一次时是如何生成这三张表的，其核心逻辑是如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routes.forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">  addRouteRecord(pathList, pathMap, nameMap, route, parentRoute)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里给循环调用了 <code>addRouteRecord</code> 方法，它就在同一个文件中，总结一下它做了如下操作：</p><ol><li> 首先检查是否有配置 <code>pathToRegexpOptions</code> 参数，这个属性值是路由高级匹配模式中（<code>path-to-regexp</code>）的参数。</li><li> 调用 <code>normalizePath</code> 将 <code>path</code> 标准化，比较重要的是这里会将子路由的 <code>path</code> 父路由的 <code>path</code> 拼接在一起。</li><li> 处理 <code>caseSensitive</code> 参数，它也是 <code>path-to-regexp</code> 中的参数。</li><li> 声明一个 <code>RouteRecord</code> ，主要代码：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> record: RouteRecord = &#123;</span><br><span class="line">  <span class="attr">path</span>: normalizedPath,</span><br><span class="line">  <span class="comment">// 用于匹配该路由的正则</span></span><br><span class="line">  <span class="attr">regex</span>: compileRouteRegex(normalizedPath, pathToRegexpOptions),</span><br><span class="line">  <span class="comment">// 该路由对应的组件，注意这里与 &lt;router-view&gt; 的 name 有关联</span></span><br><span class="line">  <span class="attr">components</span>: route.components || &#123; <span class="attr">default</span>: route.component &#125;,</span><br><span class="line">  <span class="comment">// 路由别名</span></span><br><span class="line">  <span class="attr">alias</span>: route.alias</span><br><span class="line">    ? <span class="keyword">typeof</span> route.alias === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">      ? [route.alias]</span><br><span class="line">      : route.alias</span><br><span class="line">    : []</span><br><span class="line">  <span class="comment">// other property</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li> 如果该路由存在子路由，则递归调用 <code>addRouteRecord</code> 添加路由记录。</li><li> 将这条 <code>RouteRecord</code> 存入 <code>pathList</code> 。</li><li> 将这条记录以 <code>path</code> 作为 <code>key</code> 存入 <code>pathMap</code> 。</li><li> 如果存在 <code>alias</code> ，则用 <code>alias</code> 作为 <code>path</code> 再添加一条路由记录。</li><li> 如果存在 <code>name</code> ，则以 <code>name</code> 作为 <code>key</code> 存入 <code>nameMap</code>。</li></ol><p>到这里，已经搞懂如何生成这三张表了。</p><h3 id="4-使用一些方法来操作这三张表"><a href="#4-使用一些方法来操作这三张表" class="headerlink" title="4. 使用一些方法来操作这三张表"></a>4. 使用一些方法来操作这三张表</h3><p>接着我们回到 <code>createMatcher</code> 方法内部，可以看到它返回的一些方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createMatcher</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  routes: <span class="built_in">Array</span>&lt;RouteConfig&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  router: VueRouter</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Matcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    match,</span><br><span class="line">    addRoute,</span><br><span class="line">    getRoutes,</span><br><span class="line">    addRoutes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部无非就是根据这三张表来做一些匹配或者改动而已，后面也基本会提到，这里就先略过。<br>​</p><p>到这里 <code>createMatcher</code> 的操作就基本讲完了，下面我们回到 <code>new Router</code> 本身。</p><h3 id="5-检查-mode-，使用对应的路由模式"><a href="#5-检查-mode-，使用对应的路由模式" class="headerlink" title="5. 检查 mode ，使用对应的路由模式"></a>5. 检查 <code>mode</code> ，使用对应的路由模式</h3><p>根据传入的路由配置创建一系列的数据表后，下面就要根据不同的 <code>mode</code> 来做不同的操作，核心代码如下：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 众所周知，hash 是默认值</span></span><br><span class="line"><span class="keyword">let</span> mode = options.mode || <span class="string">&#x27;hash&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用了 history 但不支持 pushState 的情况也需要回退到 hash</span></span><br><span class="line"><span class="built_in">this</span>.fallback =</span><br><span class="line">  mode === <span class="string">&#x27;history&#x27;</span> &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.fallback) &#123;</span><br><span class="line">  mode = <span class="string">&#x27;hash&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非浏览器环境(比如SSR)，则使用 abstract</span></span><br><span class="line"><span class="keyword">if</span> (!inBrowser) &#123;</span><br><span class="line">  mode = <span class="string">&#x27;abstract&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.mode = mode</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据不同的 mode 构建不同的 history</span></span><br><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;history&#x27;</span>:</span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="built_in">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;hash&#x27;</span>:</span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="built_in">this</span>, options.base, <span class="built_in">this</span>.fallback)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;abstract&#x27;</span>:</span><br><span class="line">    <span class="built_in">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="built_in">this</span>, options.base)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="attr">default</span>:</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于三种 mode 有何不同下面会讲。</p><p>到这里， <code>new Router()</code> 的整个过程就基本讲完了。</p><h2 id="二、-use-Router-时发生了什么？"><a href="#二、-use-Router-时发生了什么？" class="headerlink" title="二、 use Router 时发生了什么？"></a>二、 use Router 时发生了什么？</h2><p>我们知道仅仅通过 <code>new Router()</code> 来构造一个 vue-router 实例后，还需要通过 <code>Vue.use(router)</code> 才能真正在项目中使用它，下面就来讲讲这过程到底发生了什么？</p><h3 id="1-Vue-use-源码"><a href="#1-Vue-use-源码" class="headerlink" title="1. Vue.use 源码"></a>1. Vue.use 源码</h3><p>在这之前，我们先来看看 Vue.use 做了哪些操作，它的源码在 <a href="https://github1s.com/vuejs/vue/blob/HEAD/src/core/global-api/use.js">src/core/global-api/use.js</a>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span>(<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: <span class="built_in">Function</span> | <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins =</span><br><span class="line">      <span class="built_in">this</span>._installedPlugins || (<span class="built_in">this</span>._installedPlugins = [])</span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不长，就是接受一个 <code>plugin</code> ，这个 <code>plugin</code> 要么是一个函数，要么就是一个有 <code>install</code> 方法的对象，然后 Vue 会调用这方法，并且将当前 Vue 作为参数传入，以便插件对 Vue 来进行扩展，最后将 <code>plugin</code> 传入 <code>installedPlugins</code> 中，防止重复调用。</p><h3 id="2-安装-Router"><a href="#2-安装-Router" class="headerlink" title="2. 安装 Router"></a>2. 安装 Router</h3><p>然后我们看看在 Vue 安装 VueRouter 时，VueRouter 会做哪些操作，它的源码在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/install.js">src/install.js</a>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> View <span class="keyword">from</span> <span class="string">&#x27;./components/view&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;./components/link&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> _Vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 防止重复执行</span></span><br><span class="line">  <span class="keyword">if</span> (install.installed &amp;&amp; _Vue === Vue) <span class="keyword">return</span></span><br><span class="line">  install.installed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 Vue 存起来并 export 供其它文件使用</span></span><br><span class="line">  _Vue = Vue</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> isDef = <span class="function">(<span class="params">v</span>) =&gt;</span> v !== <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> registerInstance = <span class="function">(<span class="params">vm, callVal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> i = vm.$options._parentVnode</span><br><span class="line">    <span class="comment">// router-view 才有 registerRouteInstance 属性</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      isDef(i) &amp;&amp;</span><br><span class="line">      isDef((i = i.data)) &amp;&amp;</span><br><span class="line">      isDef((i = i.registerRouteInstance))</span><br><span class="line">    ) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册一个全局 mixin</span></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化</span></span><br><span class="line">      <span class="keyword">if</span> (isDef(<span class="built_in">this</span>.$options.router)) &#123;</span><br><span class="line">        <span class="built_in">this</span>._routerRoot = <span class="built_in">this</span></span><br><span class="line">        <span class="built_in">this</span>._router = <span class="built_in">this</span>.$options.router</span><br><span class="line">        <span class="comment">// 调用 router.init()，后面会讲</span></span><br><span class="line">        <span class="built_in">this</span>._router.init(<span class="built_in">this</span>)</span><br><span class="line">        <span class="comment">// 使 _router 变成响应式</span></span><br><span class="line">        Vue.util.defineReactive(<span class="built_in">this</span>, <span class="string">&#x27;_route&#x27;</span>, <span class="built_in">this</span>._router.history.current)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经初始化，继承父组件的 _routerRoot</span></span><br><span class="line">        <span class="built_in">this</span>._routerRoot = (<span class="built_in">this</span>.$parent &amp;&amp; <span class="built_in">this</span>.$parent._routerRoot) || <span class="built_in">this</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册实例，实际上是挂载 &lt;router-view&gt;</span></span><br><span class="line">      registerInstance(<span class="built_in">this</span>, <span class="built_in">this</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 离开时卸载</span></span><br><span class="line">      registerInstance(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把 $router 和 $route 挂载到 Vue 原型上，这样就能在任意 Vue 实例中访问</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$router&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._routerRoot._router</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">&#x27;$route&#x27;</span>, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>._routerRoot._route</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局组件</span></span><br><span class="line">  Vue.component(<span class="string">&#x27;RouterView&#x27;</span>, View)</span><br><span class="line">  Vue.component(<span class="string">&#x27;RouterLink&#x27;</span>, Link)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用 Vue 合并策略新增几个相关的生命周期</span></span><br><span class="line">  <span class="keyword">const</span> strats = Vue.config.optionMergeStrategies</span><br><span class="line">  <span class="comment">// use the same hook merging strategy for route hooks</span></span><br><span class="line">  strats.beforeRouteEnter =</span><br><span class="line">    strats.beforeRouteLeave =</span><br><span class="line">    strats.beforeRouteUpdate =</span><br><span class="line">      strats.created</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到它调用了 <code>router.init()</code> 这个方法，它的源码在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/index.js">src/index.js</a>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">init (app: any <span class="comment">/* Vue component instance */</span>) &#123;</span><br><span class="line">    <span class="comment">// 开发环境下检查是否已安装</span></span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      assert(</span><br><span class="line">        install.installed,</span><br><span class="line">        <span class="string">`not installed. Make sure to call \`Vue.use(VueRouter)\` `</span> +</span><br><span class="line">          <span class="string">`before creating root instance.`</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存当前 app 实例</span></span><br><span class="line">    <span class="built_in">this</span>.apps.push(app)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 app 销毁时需要在 apps 中移除，由 issue #2639 提出</span></span><br><span class="line">    app.$once(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// clean out app from this.apps array once destroyed</span></span><br><span class="line">      <span class="keyword">const</span> index = <span class="built_in">this</span>.apps.indexOf(app)</span><br><span class="line">      <span class="keyword">if</span> (index &gt; -<span class="number">1</span>) <span class="built_in">this</span>.apps.splice(index, <span class="number">1</span>)</span><br><span class="line">      <span class="comment">// ensure we still have a main app or null if no apps</span></span><br><span class="line">      <span class="comment">// we do not release the router so it can be reused</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.app === app) <span class="built_in">this</span>.app = <span class="built_in">this</span>.apps[<span class="number">0</span>] || <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.app) <span class="built_in">this</span>.history.teardown()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 防止重复调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.app) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.app = app</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前的 history，由之前 new Router 时根据不同 mode 来创建</span></span><br><span class="line">    <span class="keyword">const</span> history = <span class="built_in">this</span>.history</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在浏览器环境下初始化时根据当前路由位置做路由跳转</span></span><br><span class="line">    <span class="keyword">if</span> (history <span class="keyword">instanceof</span> HTML5History || history <span class="keyword">instanceof</span> HashHistory) &#123;</span><br><span class="line">      <span class="keyword">const</span> handleInitialScroll = <span class="function"><span class="params">routeOrError</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">from</span> = history.current</span><br><span class="line">        <span class="keyword">const</span> expectScroll = <span class="built_in">this</span>.options.scrollBehavior</span><br><span class="line">        <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supportsScroll &amp;&amp; <span class="string">&#x27;fullPath&#x27;</span> <span class="keyword">in</span> routeOrError) &#123;</span><br><span class="line">          handleScroll(<span class="built_in">this</span>, routeOrError, <span class="keyword">from</span>, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> setupListeners = <span class="function"><span class="params">routeOrError</span> =&gt;</span> &#123;</span><br><span class="line">        history.setupListeners()</span><br><span class="line">        handleInitialScroll(routeOrError)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 切换路由的方法，这个方法后面会讲</span></span><br><span class="line">      history.transitionTo(</span><br><span class="line">        history.getCurrentLocation(),</span><br><span class="line">        setupListeners,</span><br><span class="line">        setupListeners</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听路由变化，在所有 app 实例中设置当前路由</span></span><br><span class="line">    <span class="comment">// 所以我们一直可以通过 this.$route 拿到当前路由</span></span><br><span class="line">    history.listen(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.apps.forEach(<span class="function"><span class="params">app</span> =&gt;</span> &#123;</span><br><span class="line">        app._route = route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>相信现在对安装 VueRouter 时的大致流程已经很清楚了，我们还看到了它会调用一些很重要的方法，这些方法会从后面的问题中继续深入探讨。</p><h2 id="三、-切换路由时发生了什么"><a href="#三、-切换路由时发生了什么" class="headerlink" title="三、 切换路由时发生了什么"></a>三、 切换路由时发生了什么</h2><p>下面我们看看 vue-router 在切换路由时做了哪些操作，首先回想一下我们平时使用 vue-router 时有哪些操作可以切换路由？</p><h4 id="切换路由的几种方式"><a href="#切换路由的几种方式" class="headerlink" title="切换路由的几种方式"></a>切换路由的几种方式</h4><p>我们可以通过以下方式切换不同的路由：</p><ol><li>手动触发 URL 更新</li><li>点击 <code>router-link</code></li><li>通过 <code>this.$router</code> 的 <code>push</code> 、<code>replace</code> 等方法</li></ol><h5 id="1-手动触发-URL-更新"><a href="#1-手动触发-URL-更新" class="headerlink" title="1. 手动触发 URL 更新"></a>1. 手动触发 URL 更新</h5><p>只要我们更新了 <code>URL</code> ，vue-router 都会相应执行切换路由的逻辑，能更新 <code>URL</code> 操作有以下：</p><ul><li>如支持 <code>history</code> api<ul><li>history.pushState</li><li>history.replaceState</li><li>history.back</li><li>history.go</li></ul></li><li><code>location.href = &#39;xxx&#39;</code></li><li><code>location.hash = &#39;xxx&#39;</code></li></ul><p>vue-router 是如何监听这些操作的呢？其实只要监听 <code>popstate</code> 或者 <code>hashchange</code> 就可以了，不过这部分留到后面讲 <code>history</code> 实现时再仔细讲，这里先略过。</p><h5 id="2-通过-router-link-切换"><a href="#2-通过-router-link-切换" class="headerlink" title="2. 通过 router-link 切换"></a>2. 通过 <code>router-link</code> 切换</h5><p>还有就是通过 <code>router-link</code> 组件的方式来切换，这个组件相信大家已经很熟悉了，它的源码在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/components/link.js">src/components/link.js</a>，我们直接看最关键的部分：<br>​</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件处理，不一定是 click，取决于用户传入的 event</span></span><br><span class="line"><span class="keyword">const</span> handler = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断用户触发该事件时的行为，具体看下面的 guardEvent 方法</span></span><br><span class="line">  <span class="keyword">if</span> (guardEvent(e)) &#123;</span><br><span class="line">    <span class="comment">// 使用不同的方式来切换路由</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.replace) &#123;</span><br><span class="line">      router.replace(location, noop)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      router.push(location, noop)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件</span></span><br><span class="line"><span class="keyword">const</span> on = &#123; <span class="attr">click</span>: guardEvent &#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(<span class="built_in">this</span>.event)) &#123;</span><br><span class="line">  <span class="built_in">this</span>.event.forEach(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    on[e] = handler</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  on[<span class="built_in">this</span>.event] = handler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">guardEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 不处理有媒体键的情况</span></span><br><span class="line">  <span class="comment">// 比如 a 标签可以通过按住 shift 点击链接在新窗口打开，这时候原本的窗口不做任何处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 调用了 preventDefault 也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.defaultPrevented) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果是 button，并且不是使用左键单击也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.button !== <span class="literal">undefined</span> &amp;&amp; e.button !== <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 如果给 a 标签设置了 _blank 也不处理</span></span><br><span class="line">  <span class="keyword">if</span> (e.currentTarget &amp;&amp; e.currentTarget.getAttribute) &#123;</span><br><span class="line">    <span class="keyword">const</span> target = e.currentTarget.getAttribute(<span class="string">&#x27;target&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/\b_blank\b/i</span>.test(target)) <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 取消默认行为，这里要判断是因为在诸如 weex 环境中没有该方法</span></span><br><span class="line">  <span class="keyword">if</span> (e.preventDefault) &#123;</span><br><span class="line">    e.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显， <code>router-link</code> 本质上也是通过 router 的方法来切换路由，那下面就来看看 router 的方法。</p><h5 id="3-通过-router-的方法切换"><a href="#3-通过-router-的方法切换" class="headerlink" title="3. 通过 router 的方法切换"></a>3. 通过 router 的方法切换</h5><p>通过 router 方法来切换路由主要是三个：</p><ol><li><code>push</code></li><li><code>replace</code></li><li><code>go</code></li></ol><p>当然还有其它的，比如 <code>resolve</code> ，但这个方法并不是切换路由，但只是把对应路由信息返回过来，这里就不谈了。</p><p>其实不同的 <code>mode</code> 它们的实现是不一样的，这里我们就拿最常用的 <code>hash</code> 模式来讲，其它 <code>mode</code> 的方法实现会在后面将不同的 <code>mode</code> 的差异时讨论。</p><p>下面是这些方法在 <code>hash</code> 模式下的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            pushHash(route.fullPath)</span><br><span class="line">            handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">replace</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">current</span>: fromRoute &#125; = <span class="built_in">this</span></span><br><span class="line">  <span class="built_in">this</span>.transitionTo(</span><br><span class="line">    location,</span><br><span class="line">    <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">      replaceHash(route.fullPath)</span><br><span class="line">      handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">    &#125;,</span><br><span class="line">    onAbort</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">go</span>(<span class="params">n: number</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.history.go(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，除了 <code>go</code> 之外（它是通过事件监听器），都是在调用 <code>transitionTo</code> 这个方法，下面我们就看看这个方法的内部。</p><h4 id="切换过程"><a href="#切换过程" class="headerlink" title="切换过程"></a>切换过程</h4><h5 id="1-调用-transitionTo-方法"><a href="#1-调用-transitionTo-方法" class="headerlink" title="1. 调用 transitionTo 方法"></a>1. 调用 transitionTo 方法</h5><p>前面我们得知切换路由实际上都在调用 <code>transitionTo</code> ，它是一个 <code>History</code> 基类的方法，三种 <code>mode</code> 都是共用的同一个，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">transitionTo</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> route</span><br><span class="line">  <span class="comment">// 这里要 try 一下是因为 match 方法内部会在有 redirect 属性时调用它</span></span><br><span class="line">  <span class="comment">// 但用户提供的 redirect 方法可能会发生报错，所以这里需要捕获到错误回调方法</span></span><br><span class="line">  <span class="comment">// 具体看 issues #3201</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这是根据当前位置匹配路由，下面会讲</span></span><br><span class="line">    route = <span class="built_in">this</span>.router.match(location, <span class="built_in">this</span>.current)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">this</span>.errorCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      cb(e)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 依然要抛出异常，让用户得知</span></span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录之前的路由，后面会用到</span></span><br><span class="line">  <span class="keyword">const</span> prev = <span class="built_in">this</span>.current</span><br><span class="line">  <span class="comment">// 这个才是真正切换路由的方法，下面会讲</span></span><br><span class="line">  <span class="built_in">this</span>.confirmTransition(</span><br><span class="line">    <span class="comment">// 传入准备切换的路由</span></span><br><span class="line">    route,</span><br><span class="line">    <span class="comment">// 切换之后的回调</span></span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 更新到当前路由信息 (current)，下面会讲</span></span><br><span class="line">      <span class="built_in">this</span>.updateRoute(route)</span><br><span class="line">      <span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      <span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line">      <span class="built_in">this</span>.ensureURL()</span><br><span class="line">      <span class="comment">// 执行注册的 afterHooks</span></span><br><span class="line">      <span class="built_in">this</span>.router.afterHooks.forEach(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">        hook &amp;&amp; hook(route, prev)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">        <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">        <span class="comment">// 执行用户传入的 onReady 回调</span></span><br><span class="line">        <span class="built_in">this</span>.readyCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">          cb(route)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 发生错误的回调</span></span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 执行用户传入的 onAbort 回调</span></span><br><span class="line">      <span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">        onAbort(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行用户传入的 onError 回调</span></span><br><span class="line">      <span class="keyword">if</span> (err &amp;&amp; !<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">        <span class="comment">// Initial redirection should not mark the history as ready yet</span></span><br><span class="line">        <span class="comment">// because it&#x27;s triggered by the redirection instead</span></span><br><span class="line">        <span class="comment">// https://github.com/vuejs/vue-router/issues/3225</span></span><br><span class="line">        <span class="comment">// https://github.com/vuejs/vue-router/issues/3331</span></span><br><span class="line">        <span class="keyword">if</span> (!isNavigationFailure(err, NavigationFailureType.redirected) || prev !== START) &#123;</span><br><span class="line">          <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">          <span class="built_in">this</span>.readyErrorCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">            cb(err)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段方法中我们得知，要切换路由首先调用 <code>match</code> 方法来匹配到待切换的路由，下面我们看看实现。</p><h5 id="2-调用-match-方法匹配路由"><a href="#2-调用-match-方法匹配路由" class="headerlink" title="2. 调用 match 方法匹配路由"></a>2. 调用 <code>match</code> 方法匹配路由</h5><p>在 <code>transitionTo</code> 中调用的是 <code>router</code> 的 <code>match</code> 方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">match (raw: RawLocation, current?: Route, redirectedFrom?: Location): Route &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.matcher.match(raw, current, redirectedFrom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而它实际上是调用了 <code>matcher</code> 的 <code>match</code> 方法，这个方法我们之前在 <a href="#_2-%E5%88%9B%E5%BB%BA-matcher">创建 match</a> 这一小节有提到过，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">match</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 待切换的路由，取值为 字符串 或者 Location 对象</span></span></span></span><br><span class="line"><span class="params"><span class="function">  raw: RawLocation,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 当前的路由</span></span></span></span><br><span class="line"><span class="params"><span class="function">  currentRoute?: Route,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 使用重定向方式切换时才会传入</span></span></span></span><br><span class="line"><span class="params"><span class="function">  redirectedFrom?: Location</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Route</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将待切换的路由转换成一个标准的 Location 对象</span></span><br><span class="line">  <span class="comment">// 例如：path 补全、合并 params 等</span></span><br><span class="line">  <span class="keyword">const</span> location = normalizeLocation(raw, currentRoute, <span class="literal">false</span>, router)</span><br><span class="line">  <span class="comment">// 待切换路由的 name</span></span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = location</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    <span class="comment">// 有 name 属性的时候直接通过 nameMap 获取，根本无需遍历，非常高效</span></span><br><span class="line">    <span class="keyword">const</span> record = nameMap[name]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      warn(record, <span class="string">`Route with name &#x27;<span class="subst">$&#123;name&#125;</span>&#x27; does not exist`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该路由不存在，创建一个空的路由记录</span></span><br><span class="line">    <span class="keyword">if</span> (!record) <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">    <span class="comment">// 获取可以从父路由中继承的 param 参数</span></span><br><span class="line">    <span class="keyword">const</span> paramNames = record.regex.keys</span><br><span class="line">      .filter(<span class="function">(<span class="params">key</span>) =&gt;</span> !key.optional)</span><br><span class="line">      .map(<span class="function">(<span class="params">key</span>) =&gt;</span> key.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  params 需要为对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> location.params !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      location.params = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承父路由的 param 参数</span></span><br><span class="line">    <span class="keyword">if</span> (currentRoute &amp;&amp; <span class="keyword">typeof</span> currentRoute.params === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> currentRoute.params) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(key <span class="keyword">in</span> location.params) &amp;&amp; paramNames.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">          location.params[key] = currentRoute.params[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 path 和 param 合并为 URL</span></span><br><span class="line">    location.path = fillParams(</span><br><span class="line">      record.path,</span><br><span class="line">      location.params,</span><br><span class="line">      <span class="string">`named route &quot;<span class="subst">$&#123;name&#125;</span>&quot;`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 创建路由记录</span></span><br><span class="line">    <span class="keyword">return</span> _createRoute(record, location, redirectedFrom)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (location.path) &#123;</span><br><span class="line">    <span class="comment">// 如果是通过 path 跳转，则需要通过遍历 pathList 匹配对应的路由</span></span><br><span class="line">    location.params = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; pathList.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> path = pathList[i]</span><br><span class="line">      <span class="keyword">const</span> record = pathMap[path]</span><br><span class="line">      <span class="comment">// 检查路径与当前遍历到的路由是否匹配，该方法下面会讲</span></span><br><span class="line">      <span class="keyword">if</span> (matchRoute(record.regex, location.path, location.params)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _createRoute(record, location, redirectedFrom)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找不到匹配的则创建一条空的路由记录</span></span><br><span class="line">  <span class="keyword">return</span> _createRoute(<span class="literal">null</span>, location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是通过 <code>path</code> 的方式跳转，由于 <code>path</code> 可能会携带一些 <code>params</code> 的信息，前面我们已经提到过<a href="#%E4%B8%80%E3%80%81-new-router-%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">初始化路由</a>信息时，会为每条路由生成一个正则表达式，所以这里就可以根据这个正则来检查是否符合当前路由，也就是上面提到 <code>matchRoute</code> 作用，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchRoute</span>(<span class="params">regex: RouteRegExp, path: string, params: <span class="built_in">Object</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> m = path.match(regex)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!m) &#123;</span><br><span class="line">    <span class="comment">// 不匹配则直接退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!params) &#123;</span><br><span class="line">    <span class="comment">// 如果匹配并且该路由没有声明 param 参数，则匹配成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将使用正则匹配到的 param 参数放入 params 对象中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, len = m.length; i &lt; len; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = regex.keys[i - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      <span class="comment">// Fix #1994: using * with props: true generates a param named 0</span></span><br><span class="line">      params[key.name || <span class="string">&#x27;pathMatch&#x27;</span>] =</span><br><span class="line">        <span class="keyword">typeof</span> m[i] === <span class="string">&#x27;string&#x27;</span> ? decode(m[i]) : m[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，关于如何匹配对应的路由已经讲完了，下面我们讲讲匹配到之后它还会做什么？</p><h5 id="3-调用-confirmTransition-方法"><a href="#3-调用-confirmTransition-方法" class="headerlink" title="3. 调用 confirmTransition 方法"></a>3. 调用 confirmTransition 方法</h5><p>前面我们在 <a href="#_1-%E8%B0%83%E7%94%A8-transitionto-%E6%96%B9%E6%B3%95">1. 调用 transitionTo 方法</a> 时讲到它拿到匹配的路由之后，就会调用 <code>confirmTransition</code> 方法，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为待跳转路由有可能是一个异步组件，所以设计成有回调的方法</span></span><br><span class="line"><span class="function"><span class="title">confirmTransition</span>(<span class="params">route: Route, onComplete: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 跳转前的的路由（from）</span></span><br><span class="line">  <span class="keyword">const</span> current = <span class="built_in">this</span>.current</span><br><span class="line">  <span class="comment">// 待跳转的路由（to）</span></span><br><span class="line">  <span class="built_in">this</span>.pending = route</span><br><span class="line">  <span class="comment">// 错误时的回调</span></span><br><span class="line">  <span class="keyword">const</span> abort = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// changed after adding errors with</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/pull/3047 before that change,</span></span><br><span class="line">    <span class="comment">// redirect and aborted navigation would produce an err == null</span></span><br><span class="line">    <span class="keyword">if</span> (!isNavigationFailure(err) &amp;&amp; isError(err)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.errorCbs.length) &#123;</span><br><span class="line">        <span class="built_in">this</span>.errorCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">          cb(err)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(<span class="literal">false</span>, <span class="string">&#x27;uncaught error during route navigation:&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.error(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    onAbort &amp;&amp; onAbort(err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> lastRouteIndex = route.matched.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> lastCurrentIndex = current.matched.length - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 判断是否相同路径</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isSameRoute(route, current) &amp;&amp;</span><br><span class="line">    <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">    lastRouteIndex === lastCurrentIndex &amp;&amp;</span><br><span class="line">    route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 依旧切换</span></span><br><span class="line">    <span class="built_in">this</span>.ensureURL()</span><br><span class="line">    <span class="comment">// 报一个重复导航的错误</span></span><br><span class="line">    <span class="keyword">return</span> abort(createNavigationDuplicatedError(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过 from 和 to的 matched 数组拿到新增、更新、销毁的部分，以便执行组件的生命周期</span></span><br><span class="line">  <span class="comment">// 该方法下面会仔细讲</span></span><br><span class="line">  <span class="keyword">const</span> &#123; updated, deactivated, activated &#125; = resolveQueue(</span><br><span class="line">    <span class="built_in">this</span>.current.matched,</span><br><span class="line">    route.matched</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 一个队列，存放各种组件生命周期和导航守卫</span></span><br><span class="line">  <span class="comment">// 这里的顺序可以看回前面讲的完整的导航解析流程，具体实现下面会讲</span></span><br><span class="line">  <span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">    <span class="comment">// in-component leave guards</span></span><br><span class="line">    extractLeaveGuards(deactivated),</span><br><span class="line">    <span class="comment">// global before hooks</span></span><br><span class="line">    <span class="built_in">this</span>.router.beforeHooks,</span><br><span class="line">    <span class="comment">// in-component update hooks</span></span><br><span class="line">    extractUpdateHooks(updated),</span><br><span class="line">    <span class="comment">// in-config enter guards</span></span><br><span class="line">    activated.map(<span class="function">(<span class="params">m</span>) =&gt;</span> m.beforeEnter),</span><br><span class="line">    <span class="comment">// async components</span></span><br><span class="line">    resolveAsyncComponents(activated)</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// 迭代器，每次执行一个钩子，调用 next 时才会进行下一项</span></span><br><span class="line">  <span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook: NavigationGuard, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在当前导航还没有完成之前又有了一个新的导航。</span></span><br><span class="line">    <span class="comment">// 比如，在等待导航守卫的过程中又调用了 router.push</span></span><br><span class="line">    <span class="comment">// 这时候需要报一个 cancel 错误</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">      <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行当前钩子，但用户传入的导航守卫有可能会出错，需要 try 一下</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这就是路由钩子的参数：to、from、next</span></span><br><span class="line">      hook(route, current, <span class="function">(<span class="params">to: any</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 我们可以通过 next(&#x27;/login&#x27;) 这样的方式来重定向</span></span><br><span class="line">        <span class="comment">// 如果传入 false 则中断当前的导航，并将 URL 重置到 from 路由对应的地址</span></span><br><span class="line">        <span class="keyword">if</span> (to === <span class="literal">false</span>) &#123;</span><br><span class="line">          <span class="comment">// next(false) -&gt; abort navigation, ensure current URL</span></span><br><span class="line">          <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">          abort(createNavigationAbortedError(current, route))</span><br><span class="line">        <span class="comment">// 如果传入 next 的参数是一个 Error 实例</span></span><br><span class="line">        <span class="comment">// 则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isError(to)) &#123;</span><br><span class="line">          <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">          abort(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">          <span class="comment">// 判断传入的参数是否符合要求</span></span><br><span class="line">          <span class="keyword">typeof</span> to === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">          (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">            (<span class="keyword">typeof</span> to.path === <span class="string">&#x27;string&#x27;</span> || typeofto.name === <span class="string">&#x27;string&#x27;</span>))</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// next(&#x27;/&#x27;) or next(&#123; path: &#x27;/&#x27; &#125;) -&gt; redirect</span></span><br><span class="line">          abort(createNavigationRedirectedError(current, route))</span><br><span class="line">          <span class="comment">// 判断切换类型</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; to.replace) &#123;</span><br><span class="line">            <span class="built_in">this</span>.replace(to)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.push(to)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 不符合则跳转至 to</span></span><br><span class="line">          <span class="comment">// confirm transition and pass on the value</span></span><br><span class="line">          next(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="comment">// 出错时执行 abort 回调</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      abort(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行队列，下面仔细讲</span></span><br><span class="line">  runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// wait until async components are resolved before</span></span><br><span class="line">    <span class="comment">// extracting in-component enter guards</span></span><br><span class="line">    <span class="keyword">const</span> enterGuards = extractEnterGuards(activated)</span><br><span class="line">    <span class="keyword">const</span> queue = enterGuards.concat(<span class="built_in">this</span>.router.resolveHooks)</span><br><span class="line">    runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">        <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">      onComplete(route)</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.router.app) &#123;</span><br><span class="line">        <span class="built_in">this</span>.router.app.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          handleRouteEntered(route)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4-构造导航守卫队列"><a href="#4-构造导航守卫队列" class="headerlink" title="4. 构造导航守卫队列"></a>4. 构造导航守卫队列</h5><p>我们知道在切换路由时需要执行一系列的导航守卫和路由相关的生命周期，下面就讲讲它的实现，其实也是在 <code>confirmTransition</code> 这个方法中。<br>​</p><p>第一步就是构造队列，关于它们执行的顺序可以看回文档。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个队列，存放各种组件生命周期和导航守卫</span></span><br><span class="line"><span class="comment">// 注意：这里只是完整迭代导航解析流程中的 2~6 步</span></span><br><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt; = [].concat(</span><br><span class="line">  <span class="comment">// 调用此次失活的部分组件的 beforeRouteLeave</span></span><br><span class="line">  extractLeaveGuards(deactivated),</span><br><span class="line">  <span class="comment">// 全局的 before 钩子</span></span><br><span class="line">  <span class="built_in">this</span>.router.beforeHooks,</span><br><span class="line">  <span class="comment">// 调用此次更新的部分组件的 beforeRouteUpdate</span></span><br><span class="line">  extractUpdateHooks(updated),</span><br><span class="line">  <span class="comment">// 调用此次激活的路由配置的 beforeEach</span></span><br><span class="line">  activated.map(<span class="function">(<span class="params">m</span>) =&gt;</span> m.beforeEnter),</span><br><span class="line">  <span class="comment">// 解析异步组件</span></span><br><span class="line">  resolveAsyncComponents(activated)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还记得前面我们讲了 <code>updated, deactivated, activated</code> 这三个数组是从 <code>resolveQueue</code> 方法中获取：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; updated, deactivated, activated &#125; = resolveQueue(</span><br><span class="line">  <span class="built_in">this</span>.current.matched,</span><br><span class="line">  route.matched</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveQueue</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  current: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  next: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): </span>&#123;</span><br><span class="line">  <span class="attr">updated</span>: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  activated: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span><br><span class="line">  deactivated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> i</span><br><span class="line">  <span class="keyword">const</span> max = <span class="built_in">Math</span>.max(current.length, next.length)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current[i] !== next[i]) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">updated</span>: next.slice(<span class="number">0</span>, i),</span><br><span class="line">    <span class="attr">activated</span>: next.slice(i),</span><br><span class="line">    <span class="attr">deactivated</span>: current.slice(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理很简单，只需要对比 <code>current</code> 和 <code>next</code> 的 <code>match</code> 数组，就能拿到以下数组：</p><ol><li><code>updated</code>：有交集的部分</li><li><code>activated</code>：next 有并且 current 没有的部分</li><li><code>deactivated</code>：current 有并且 next 没有的部分</li></ol><p>下面是队列中各项的实现</p><ol><li>调用 <code>extractLeaveGuards(deactivated)</code> 执行销毁的组件 <code>beforeRouteLeave</code> 生命周期：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractLeaveGuards</span>(<span class="params">deactivated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 最后一个参数为 true 是因为这个生命周期要倒序执行，先执行子路由的再执行父路由的</span></span><br><span class="line">  <span class="keyword">return</span> extractGuards(deactivated, <span class="string">&#x27;beforeRouteLeave&#x27;</span>, bindGuard, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用全局的 <code>beforeHooks</code> ，其实也就是存放用户通过 <code>beforeEach</code> 注册的数组：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">beforeEach (fn: <span class="built_in">Function</span>): <span class="built_in">Function</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> registerHook(<span class="built_in">this</span>.beforeHooks, fn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>调用 <code>extractUpdateHooks(updated)</code> 执行更新的组件：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractUpdateHooks</span>(<span class="params">updated: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> extractGuards(updated, <span class="string">&#x27;beforeRouteUpdate&#x27;</span>, bindGuard)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用所有激活组件的 <code>beforeEnter</code> 生命周期：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activated.map(<span class="function">(<span class="params">m</span>) =&gt;</span> m.beforeEnter)</span><br></pre></td></tr></table></figure><ol start="5"><li>调用 <code>resolveAsyncComponents(activated)</code> 来解析异步组件：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponents</span>(<span class="params">matched: <span class="built_in">Array</span>&lt;RouteRecord&gt;</span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回一个队列钩子函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 用于标记是否异步组件</span></span><br><span class="line">    <span class="keyword">let</span> hasAsync = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 待加载的组件数量</span></span><br><span class="line">    <span class="keyword">let</span> pending = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 是否加载错误</span></span><br><span class="line">    <span class="keyword">let</span> error = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个方法下面会讲，主要作用是依次遍历传入的 matched 数组相关的 component</span></span><br><span class="line">    flatMapComponents(matched, <span class="function">(<span class="params">def, _, match, key</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否异步组件</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> def === <span class="string">&#x27;function&#x27;</span> &amp;&amp; def.cid === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        hasAsync = <span class="literal">true</span></span><br><span class="line">        pending++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// webpack 加载这个异步组件的 chunk 后执行</span></span><br><span class="line">        <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">resolvedDef</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (isESModule(resolvedDef)) &#123;</span><br><span class="line">            resolvedDef = resolvedDef.default</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将它变成一个 vue 组件</span></span><br><span class="line">          <span class="comment">// save resolved on async factory in case it&#x27;s used elsewhere</span></span><br><span class="line">          def.resolved =</span><br><span class="line">            <span class="keyword">typeof</span> resolvedDef === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">              ? resolvedDef</span><br><span class="line">              : _Vue.extend(resolvedDef)</span><br><span class="line">          <span class="comment">// 把解析好的组件更新到当前路由记录中</span></span><br><span class="line">          match.components[key] = resolvedDef</span><br><span class="line">          pending--</span><br><span class="line">          <span class="comment">// 如果已经加载完则调用 next 进入下一个队列</span></span><br><span class="line">          <span class="keyword">if</span> (pending &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            next()</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// webpack 加载这个异步组件失败后执行</span></span><br><span class="line">        <span class="keyword">const</span> reject = once(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 报个错</span></span><br><span class="line">          <span class="keyword">const</span> msg = <span class="string">`Failed to resolve async component <span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;reason&#125;</span>`</span></span><br><span class="line">          process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(<span class="literal">false</span>, msg)</span><br><span class="line">          <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">            error = isError(reason) ? reason : <span class="keyword">new</span> <span class="built_in">Error</span>(msg)</span><br><span class="line">            next(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> res</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 这里是调用 webpack 方法加载这个组件，返回的是一个 Promise</span></span><br><span class="line">          res = def(resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">          <span class="comment">// 这里才真正加载这个组件</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> res.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            res.then(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// new syntax in Vue 2.3</span></span><br><span class="line">            <span class="keyword">const</span> comp = res.component</span><br><span class="line">            <span class="keyword">if</span> (comp &amp;&amp; <span class="keyword">typeof</span> comp.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">              comp.then(resolve, reject)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是异步则直接 next</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAsync) next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步加载这一块其实涉及比较多，深入讲的话还要讲 <code>webpack</code> ，所以这里只讲大概的流程，以后有机会的话再深入讲解。</p><p>可以看到执行导航守卫都是通过调用一个 <code>extractGuards</code> 方法，下面是它的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// records: routerRecord 数组</span></span><br><span class="line"><span class="comment">// name 钩子的名字</span></span><br><span class="line"><span class="comment">// bind 就是 bindGuard 方法，下面会讲</span></span><br><span class="line"><span class="comment">// reverse 是否倒序执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractGuards</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  records: <span class="built_in">Array</span>&lt;RouteRecord&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  name: string,</span></span></span><br><span class="line"><span class="params"><span class="function">  bind: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  reverse?: boolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Array</span>&lt;?<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> guards = flatMapComponents(records, <span class="function">(<span class="params">def, instance, match, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> guard = extractGuard(def, name)</span><br><span class="line">    <span class="keyword">if</span> (guard) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.isArray(guard)</span><br><span class="line">        ? guard.map(<span class="function">(<span class="params">guard</span>) =&gt;</span> bind(guard, instance, match, key))</span><br><span class="line">        : bind(guard, instance, match, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> flatten(reverse ? guards.reverse() : guards)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在仔细讲这个方法内部逻辑前，要先搞清楚这三个方法的内部： <code>extractGuard</code> 、 <code>bindGuard</code> 、 <code>flatMapComponents</code> ：</p><p><code>extractGuard</code> 很简单，其实就是获取 vue 组件实例中特定的生命周期：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractGuard</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  def: <span class="built_in">Object</span> | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: string</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">NavigationGuard</span> | <span class="title">Array</span>&lt;<span class="title">NavigationGuard</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> def !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// extend now so that global mixins are applied.</span></span><br><span class="line">    def = _Vue.extend(def)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> def.options[key]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>bindGuard</code> 的作用就是返回一个函数，这个函数会调用组件特定生命周期，给后续执行队列时调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// guard：某个生命周期钩子</span></span><br><span class="line"><span class="comment">// instance：执行的 vue 实例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindGuard</span>(<span class="params">guard: NavigationGuard, instance: ?_Vue</span>): ?<span class="title">NavigationGuard</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance) &#123;</span><br><span class="line">    <span class="comment">// 这时只是返回这个方法，没有立即调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">boundRouteGuard</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 调用这个钩子</span></span><br><span class="line">      <span class="keyword">return</span> guard.apply(instance, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>flatMapComponents</code> 顾名思义就是跟组件相关的，它的作用是依次遍历传入的 <code>matched</code> 数组相关的组件，并调用传入的回调的返回值作为自己的返回值，所以它的返回值是调用者决定的：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flatMapComponents</span>(<span class="params">matched, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> flatten(</span><br><span class="line">    matched.map(<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.keys(m.components).map(<span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fn(m.components[key], m.instances[key], m, key)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以现在再回过头来看 <code>extractGuards</code> 就很清晰了，它的作用就是通过 <code>flatMapComponents</code> 遍历所有 <code>match</code> 数组中的组件，并通过 <code>extractGuard</code> 拿到这些组件的特定生命周期，然后通过 <code>bindGuard</code> 返回一个可以调用这个生命周期的函数，然后利用 <code>flatten</code> 将它们扁平化，根据 <code>reverse</code> 决定是否倒序返回这些函数数组。</p><p>最后这些函数全部放在 <code>queue</code> 中，这就是构造整个队列的过程了。</p><h5 id="5-执行队列"><a href="#5-执行队列" class="headerlink" title="5. 执行队列"></a>5. 执行队列</h5><p>构造完队列，下面就要开始执行这个队列了，在这之前我们先来看看 <code>runQueue</code> 的实现：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">runQueue</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  queue: <span class="built_in">Array</span>&lt;?NavigationGuard&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  fn: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  cb: <span class="built_in">Function</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> step = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= queue.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (queue[index]) &#123;</span><br><span class="line">        fn(queue[index], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          step(index + <span class="number">1</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        step(index + <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  step(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也不复杂，首先从 0 开始按顺序遍历 <code>queue</code> 中的每一项，在调用 <code>fn</code> 时作为第一个参数传入，当使用者调用了第二个参数的回调时，才进入下一次项，最后遍历完 <code>queue</code> 中所有的项后，调用 <code>cb</code> 回到参数。</p><p>下面是执行这个队列的过程：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行队列</span></span><br><span class="line"><span class="comment">// queue 就是上面那个队列</span></span><br><span class="line"><span class="comment">// iterator 传入 to、from、next，只有执行 next 才会进入下一项</span></span><br><span class="line"><span class="comment">// cb 回调函数，当执行完整个队列后调用</span></span><br><span class="line">runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// wait until async components are resolved before</span></span><br><span class="line">  <span class="comment">// extracting in-component enter guards</span></span><br><span class="line">  <span class="keyword">const</span> enterGuards = extractEnterGuards(activated)</span><br><span class="line">  <span class="keyword">const</span> queue = enterGuards.concat(<span class="built_in">this</span>.router.resolveHooks)</span><br><span class="line">  runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">      <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">    onComplete(route)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.router.app) &#123;</span><br><span class="line">      <span class="built_in">this</span>.router.app.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        handleRouteEntered(route)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>iterator</code> 的定义在 <a href="#_1-%E8%B0%83%E7%94%A8-transitionto-%E6%96%B9%E6%B3%95">1. 调用 transitionTo 方法</a> 这一小节中已经有提到了，这里拷贝一份过来：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器，每次执行一个钩子，调用 next 时才会进行下一项</span></span><br><span class="line"><span class="keyword">const</span> iterator = <span class="function">(<span class="params">hook: NavigationGuard, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 在当前导航还没有完成之前又有了一个新的导航。</span></span><br><span class="line">  <span class="comment">// 比如，在等待导航守卫的过程中又调用了 router.push</span></span><br><span class="line">  <span class="comment">// 这时候需要报一个 cancel 错误</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">    <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行当前钩子，但用户传入的导航守卫有可能会出错，需要 try 一下</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这就是路由钩子的参数：to、from、next</span></span><br><span class="line">    hook(route, current, <span class="function">(<span class="params">to: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 我们可以通过 next(&#x27;/login&#x27;) 这样的方式来重定向</span></span><br><span class="line">      <span class="comment">// 如果传入 false 则中断当前的导航，并将 URL 重置到 from 路由对应的地址</span></span><br><span class="line">      <span class="keyword">if</span> (to === <span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// next(false) -&gt; abort navigation, ensure current URL</span></span><br><span class="line">        <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">        abort(createNavigationAbortedError(current, route))</span><br><span class="line">        <span class="comment">// 如果传入 next 的参数是一个 Error 实例</span></span><br><span class="line">        <span class="comment">// 则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isError(to)) &#123;</span><br><span class="line">        <span class="built_in">this</span>.ensureURL(<span class="literal">true</span>)</span><br><span class="line">        abort(to)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        <span class="comment">// 判断传入的参数是否符合要求</span></span><br><span class="line">        <span class="keyword">typeof</span> to === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">        (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">          (<span class="keyword">typeof</span> to.path === <span class="string">&#x27;string&#x27;</span> || typeofto.name === <span class="string">&#x27;string&#x27;</span>))</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// next(&#x27;/&#x27;) or next(&#123; path: &#x27;/&#x27; &#125;) -&gt; redirect</span></span><br><span class="line">        abort(createNavigationRedirectedError(current, route))</span><br><span class="line">        <span class="comment">// 判断切换类型</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">&#x27;object&#x27;</span> &amp;&amp; to.replace) &#123;</span><br><span class="line">          <span class="built_in">this</span>.replace(to)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.push(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不符合则跳转至 to</span></span><br><span class="line">        <span class="comment">// confirm transition and pass on the value</span></span><br><span class="line">        next(to)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 出错时执行 abort 回调</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    abort(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们留意到这里其实是嵌套执行了两次 <code>runQueue</code> ，这是因为我们前面构造的 <code>queue</code> 只是 vue-router 完整的导航解析流程中的 第 2<del>6 步，而接下来就要执行第 7</del>9 步：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这时候异步组件已经解析完成</span></span><br><span class="line"><span class="comment">// 下面是构造 beforeRouteEnter 和 beforeResolve 守卫的队列</span></span><br><span class="line"><span class="keyword">const</span> enterGuards = extractEnterGuards(activated)</span><br><span class="line"><span class="keyword">const</span> queue = enterGuards.concat(<span class="built_in">this</span>.router.resolveHooks)</span><br><span class="line">runQueue(queue, iterator, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.pending !== route) &#123;</span><br><span class="line">    <span class="keyword">return</span> abort(createNavigationCancelledError(current, route))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 这里是调用 transitionTo 传入的 onComplete 回调</span></span><br><span class="line">  <span class="comment">// 在这里会做一些更新路由、URL、调用 afterHooks、onReady 等回调，下面就讲</span></span><br><span class="line">  onComplete(route)</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.router.app) &#123;</span><br><span class="line">    <span class="comment">// 下次更新 DOM 时触发 handleRouteEntered</span></span><br><span class="line">    <span class="built_in">this</span>.router.app.$nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// TODO 不太明白这个方法的内部</span></span><br><span class="line">      handleRouteEntered(route)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="6-执行-confirmTransition-后的操作"><a href="#6-执行-confirmTransition-后的操作" class="headerlink" title="6. 执行 confirmTransition 后的操作"></a>6. 执行 <code>confirmTransition</code> 后的操作</h5><p>到这里 <code>confirmTransition</code> 方法就已经执行完了，最后会调用 <code>transitionTo</code> 传入的 <code>onComplete</code> 方法，之前就有提到：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新到当前路由信息 (current)，下面会讲</span></span><br><span class="line"><span class="built_in">this</span>.updateRoute(route)</span><br><span class="line"><span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">onComplete &amp;&amp; onComplete(route)</span><br><span class="line"><span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line"><span class="built_in">this</span>.ensureURL()</span><br><span class="line"><span class="comment">// 执行注册的 afterHooks</span></span><br><span class="line"><span class="built_in">this</span>.router.afterHooks.forEach(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">  hook &amp;&amp; hook(route, prev)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">  <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// 执行用户传入的 onReady 回调</span></span><br><span class="line">  <span class="built_in">this</span>.readyCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">    cb(route)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要做了几步：更新当前路由、调用传入的 <code>onComplete</code> 、更新 <code>URL</code> 、调用 <code>afterHooks</code> 、 <code>onReady</code> 钩子。</p><p>而如果 <code>confirmTransition</code> 执行失败的话，则会执行传入的 <code>onAbort</code> ：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (onAbort) &#123;</span><br><span class="line">  onAbort(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (err &amp;&amp; !<span class="built_in">this</span>.ready) &#123;</span><br><span class="line">  <span class="comment">// Initial redirection should not mark the history as ready yet</span></span><br><span class="line">  <span class="comment">// because it&#x27;s triggered by the redirection instead</span></span><br><span class="line">  <span class="comment">// https://github.com/vuejs/vue-router/issues/3225</span></span><br><span class="line">  <span class="comment">// https://github.com/vuejs/vue-router/issues/3331</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !isNavigationFailure(err, NavigationFailureType.redirected) ||</span><br><span class="line">    prev !== START</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="built_in">this</span>.ready = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.readyErrorCbs.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">      cb(err)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是调用传入的 <code>onAbort</code> 回调，执行 <code>onError</code> 钩子。</p><p>到这里整个 <code>transitionTo</code> 方法的执行过程已经讲完了，导航守卫和一些钩子函数也已经全部执行完毕。<br>​</p><h5 id="7-更新路由信息"><a href="#7-更新路由信息" class="headerlink" title="7. 更新路由信息"></a>7. 更新路由信息</h5><p>接着我们看看它是如何更新当前路由信息的，也就是 <code>updateRoute</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">updateRoute</span>(<span class="params">route: Route</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.current = route</span><br><span class="line">    <span class="built_in">this</span>.cb &amp;&amp; <span class="built_in">this</span>.cb(route)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是更新一下 <code>current</code> 的指向，接着调用 <code>cb</code> 这个回调函数并且将当前路由传入，那这个 <code>cb</code> 是什么东西呢？它是在 <code>listen</code> 方法中被赋值的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">listen</span>(<span class="params">cb: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而哪里调用了这个 <code>listen</code> 方法呢？我们看回之前在 <a href="#_2-%E5%AE%89%E8%A3%85-router">2. 安装 Router</a> 时初始化那里的一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听路由变化，在所有 app 实例中设置当前路由</span></span><br><span class="line"><span class="comment">// 所以我们一直可以通过 this.$route 拿到当前路由</span></span><br><span class="line">history.listen(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.apps.forEach(<span class="function">(<span class="params">app</span>) =&gt;</span> &#123;</span><br><span class="line">    app._route = route</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以到这里，我们通过 <code>this.$route</code> 拿到的路由就已经变成跳转的路由了。<br>​</p><h5 id="8-更新-URL"><a href="#8-更新-URL" class="headerlink" title="8. 更新 URL"></a>8. 更新 URL</h5><p>接着就是更新 <code>URL</code> 了，在 <code>transitionTo</code> 这里它是先调用了 <code>onComplete</code> 方法，然后再调用 <code>ensureURL</code> 方法来更新浏览器上的 <code>URL</code> ，对应源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行用户传入的 onComplete回调</span></span><br><span class="line">onComplete &amp;&amp; onComplete(route)</span><br><span class="line"><span class="comment">// 更新浏览器地址栏上的 URL</span></span><br><span class="line"><span class="built_in">this</span>.ensureURL()</span><br></pre></td></tr></table></figure><p>由于我们这里是以 <code>hash</code> 模式来展开的，所以我们看看它的 <code>push</code> 方法里传入的 <code>onComplete</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            pushHash(route.fullPath)</span><br><span class="line">            handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>pushHash</code> 这里实际到后面已经可以更新 <code>URL</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位于：src/util/push-state.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushState</span>(<span class="params">url?: string, replace?: boolean</span>) </span>&#123;</span><br><span class="line">  saveScrollPosition()</span><br><span class="line">  <span class="comment">// try...catch the pushState call to get around Safari</span></span><br><span class="line">  <span class="comment">// DOM Exception 18 where it limits to 100 pushState calls</span></span><br><span class="line">  <span class="keyword">const</span> history = <span class="built_in">window</span>.history</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      <span class="comment">// preserve existing history state as it could be overriden by the user</span></span><br><span class="line">      <span class="keyword">const</span> stateCopy = extend(&#123;&#125;, history.state)</span><br><span class="line">      stateCopy.key = getStateKey()</span><br><span class="line">      history.replaceState(stateCopy, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.pushState(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">key</span>: setStateKey(genStateKey())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        url</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location[replace ? <span class="string">&#x27;replace&#x27;</span> : <span class="string">&#x27;assign&#x27;</span>](url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pushHash</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    pushState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.hash = path</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以后面再执行 <code>ensureURL</code> 时就不需要再更新一遍了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">ensureURL</span>(<span class="params">push ? : boolean</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">this</span>.current.fullPath</span><br><span class="line">    <span class="keyword">if</span> (getHash() !== current) &#123;</span><br><span class="line">        push ? pushHash(current) : replaceHash(current)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>难道这个 <code>ensureURL</code> 就是多此一举吗？也不是，在其他地方调用就会更新 <code>URL</code> 的，比如 <code>transitionTo</code> 检查是否跳转至相同路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">  isSameRoute(route, current) &amp;&amp;</span><br><span class="line">  <span class="comment">// in the case the route map has been dynamically appended to</span></span><br><span class="line">  lastRouteIndex === lastCurrentIndex &amp;&amp;</span><br><span class="line">  route.matched[lastRouteIndex] === current.matched[lastCurrentIndex]</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="built_in">this</span>.ensureURL()</span><br><span class="line">  <span class="keyword">return</span> abort(createNavigationDuplicatedError(current, route))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里更新了 <code>URL</code> 以后，还会调用 <code>handleScroll</code> 来滚动相关的操作，如：保存当前滚动位置、根据传入的 <code>scrollBehavior</code> 设置当前滚动位置，不过这里就不展开讲了。</p><p>另外，更新 <code>URL</code> 这部分行为也是根据不同的路由模式有所区别，后面的章节会详情讲解。</p><h5 id="9-渲染对应的路由视图"><a href="#9-渲染对应的路由视图" class="headerlink" title="9. 渲染对应的路由视图"></a>9. 渲染对应的路由视图</h5><p>除了更新 <code>URL</code> 以外，我们还要渲染当前路由对应的视图，那这又是如何做到的呢？我们知道 vue-router 是通过一个叫 <code>router-view</code> 的组件来渲染，下面看看它的实现，它的源码在：<a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/components/view.js">src/components/view.js</a>，我们先粗略看一下它的 <code>render</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params">_, &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    props,</span></span></span><br><span class="line"><span class="params"><span class="function">    children,</span></span></span><br><span class="line"><span class="params"><span class="function">    parent,</span></span></span><br><span class="line"><span class="params"><span class="function">    data</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// used by devtools to display a router-view badge</span></span><br><span class="line">    data.routerView = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// directly use parent context&#x27;s createElement() function</span></span><br><span class="line">    <span class="comment">// so that components rendered by router-view can resolve named slots</span></span><br><span class="line">    <span class="keyword">const</span> h = parent.$createElement</span><br><span class="line">    <span class="keyword">const</span> name = props.name</span><br><span class="line">    <span class="comment">// 拿到当前路由</span></span><br><span class="line">    <span class="keyword">const</span> route = parent.$route</span><br><span class="line">    <span class="comment">// 缓存路由视图，keepAlive 时会用到</span></span><br><span class="line">    <span class="keyword">const</span> cache = parent._routerViewCache || (parent._routerViewCache = &#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// determine current view depth, also check to see if the tree</span></span><br><span class="line">    <span class="comment">// has been toggled inactive but kept-alive.</span></span><br><span class="line">    <span class="keyword">let</span> depth = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> inactive = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">while</span> (parent &amp;&amp; parent._routerRoot !== parent) &#123;</span><br><span class="line">        <span class="keyword">const</span> vnodeData = parent.$vnode ? parent.$vnode.data : &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> (vnodeData.routerView) &#123;</span><br><span class="line">            depth++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (vnodeData.keepAlive &amp;&amp; parent._directInactive &amp;&amp; parent._inactive) &#123;</span><br><span class="line">            inactive = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    data.routerViewDepth = depth</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里是渲染已经缓存的视图</span></span><br><span class="line">    <span class="keyword">if</span> (inactive) &#123;</span><br><span class="line">        <span class="keyword">const</span> cachedData = cache[name]</span><br><span class="line">        <span class="keyword">const</span> cachedComponent = cachedData &amp;&amp; cachedData.component</span><br><span class="line">        <span class="keyword">if</span> (cachedComponent) &#123;</span><br><span class="line">            <span class="comment">// #2301</span></span><br><span class="line">            <span class="comment">// pass props</span></span><br><span class="line">            <span class="keyword">if</span> (cachedData.configProps) &#123;</span><br><span class="line">                fillPropsinData(</span><br><span class="line">                    cachedComponent,</span><br><span class="line">                    data,</span><br><span class="line">                    cachedData.route,</span><br><span class="line">                    cachedData.configProps</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> h(cachedComponent, data, children)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// render previous empty view</span></span><br><span class="line">            <span class="keyword">return</span> h()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到对应的视图组件</span></span><br><span class="line">    <span class="keyword">const</span> matched = route.matched[depth]</span><br><span class="line">    <span class="keyword">const</span> component = matched &amp;&amp; matched.components[name]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// render empty node if no matched route or no config component</span></span><br><span class="line">    <span class="keyword">if</span> (!matched || !component) &#123;</span><br><span class="line">        cache[name] = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">return</span> h()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cache component</span></span><br><span class="line">    cache[name] = &#123;</span><br><span class="line">        component</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// attach instance registration hook</span></span><br><span class="line">    <span class="comment">// this will be called in the instance&#x27;s injected lifecycle hooks</span></span><br><span class="line">    data.registerRouteInstance = <span class="function">(<span class="params">vm, val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// val could be undefined for unregistration</span></span><br><span class="line">        <span class="keyword">const</span> current = matched.instances[name]</span><br><span class="line">        <span class="keyword">if</span> ((val &amp;&amp; current !== vm) || (!val &amp;&amp; current === vm)) &#123;</span><br><span class="line">            matched.instances[name] = val</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also register instance in prepatch hook</span></span><br><span class="line">    <span class="comment">// in case the same component instance is reused across different routes</span></span><br><span class="line">    ;</span><br><span class="line">    (data.hook || (data.hook = &#123;&#125;)).prepatch = <span class="function">(<span class="params">_, vnode</span>) =&gt;</span> &#123;</span><br><span class="line">        matched.instances[name] = vnode.componentInstance</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register instance in init hook</span></span><br><span class="line">    <span class="comment">// in case kept-alive component be actived when routes changed</span></span><br><span class="line">    data.hook.init = <span class="function">(<span class="params">vnode</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">            vnode.data.keepAlive &amp;&amp;</span><br><span class="line">            vnode.componentInstance &amp;&amp;</span><br><span class="line">            vnode.componentInstance !== matched.instances[name]</span><br><span class="line">        ) &#123;</span><br><span class="line">            matched.instances[name] = vnode.componentInstance</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if the route transition has already been confirmed then we weren&#x27;t</span></span><br><span class="line">        <span class="comment">// able to call the cbs during confirmation as the component was not</span></span><br><span class="line">        <span class="comment">// registered yet, so we call it here.</span></span><br><span class="line">        handleRouteEntered(route)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> configProps = matched.props &amp;&amp; matched.props[name]</span><br><span class="line">    <span class="comment">// save route and configProps in cache</span></span><br><span class="line">    <span class="keyword">if</span> (configProps) &#123;</span><br><span class="line">        extend(cache[name], &#123;</span><br><span class="line">            route,</span><br><span class="line">            configProps</span><br><span class="line">        &#125;)</span><br><span class="line">        fillPropsinData(component, data, route, configProps)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染组件</span></span><br><span class="line">    <span class="keyword">return</span> h(component, data, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>router-view</code> 是通过 <code>$route</code> 变量来获取当前组件的，而在前面 <a href="#_7-%E6%9B%B4%E6%96%B0%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF">7. 更新路由信息</a> 时有提到会更新 <code>_route</code> 变量，而它在 <a href="#_2-%E5%AE%89%E8%A3%85-router">2. 安装 Router</a> 时就已经用 <code>$route</code> 包装成响应式了，这里自然也就可以渲染对应的组件了。</p><h2 id="四、-动态添加路由实现"><a href="#四、-动态添加路由实现" class="headerlink" title="四、 动态添加路由实现"></a>四、 动态添加路由实现</h2><p>我们在开发时可能会遇到一些比较复杂的场景，需要动态添加路由，最常见的例子就是根据后端返回的不同用户角色去配置不同的前端路由，那下面就讲讲它在 vue-router 内部是如何实现的。<br>​</p><p>我们只需要使用 <code>router.addRoute</code> 方法就能新增一条路由记录，之前我们在讲 <a href="#_2-%E5%88%9B%E5%BB%BA-matcher">2. 创建 matcher</a> 有看到这个方法的定义，下面是它的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addRoute</span>(<span class="params">parentOrRoute, route</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否有传入父路由，有则取，无则 undefined</span></span><br><span class="line">  <span class="keyword">const</span> parent =</span><br><span class="line">    <span class="keyword">typeof</span> parentOrRoute !== <span class="string">&#x27;object&#x27;</span> ? nameMap[parentOrRoute] : <span class="literal">undefined</span></span><br><span class="line">  <span class="comment">// 插入一条路由，由于这里可能只会传入一个参数，所以需要判断一下</span></span><br><span class="line">  createRouteMap([route || parentOrRoute], pathList, pathMap, nameMap, parent)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有父路由并且父路由存在别名的情况下，需要给这个别名路由也新增一条子路由</span></span><br><span class="line">  <span class="keyword">if</span> (parent) &#123;</span><br><span class="line">    createRouteMap(</span><br><span class="line">      <span class="comment">// $flow-disable-line route is defined if parent is</span></span><br><span class="line">      parent.alias.map(<span class="function">(<span class="params">alias</span>) =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">path</span>: alias,</span><br><span class="line">        <span class="attr">children</span>: [route]</span><br><span class="line">      &#125;)),</span><br><span class="line">      pathList,</span><br><span class="line">      pathMap,</span><br><span class="line">      nameMap,</span><br><span class="line">      parent</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里比较重要的是调用 <code>createRouteMap</code> 来创建路由，它的实现之前在 <a href="#_3-%E6%A0%B9%E6%8D%AE%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E4%B8%89%E5%BC%A0%E8%A1%A8">3. 根据路由配置生成三张表</a> 有提到，不过当时只关注它如何生成三张表，在现在这种情况下调用它的区别在于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这三张表都无需新增，直接拿之前的</span></span><br><span class="line"><span class="keyword">const</span> pathList: <span class="built_in">Array</span>&lt;string&gt; = oldPathList || []</span><br><span class="line"><span class="keyword">const</span> pathMap: Dictionary&lt;RouteRecord&gt; = oldPathMap || <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"><span class="keyword">const</span> nameMap: Dictionary&lt;RouteRecord&gt; = oldNameMap || <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>好了，可以看到新增一条路由规则十分简单，只需要对 <code>pathList</code> 、 <code>pathMap</code> 、 <code>nameMap</code> 进行改动就好了。</p><h2 id="五、-三种路由模式的实现"><a href="#五、-三种路由模式的实现" class="headerlink" title="五、 三种路由模式的实现"></a>五、 三种路由模式的实现</h2><p>vue-router 的核心逻辑已经讲得差不多了，就剩下三种路由模式之间的差异，这一小节就来仔细讲讲它们各自的内部实现。<br>​</p><h4 id="相同的部分"><a href="#相同的部分" class="headerlink" title="相同的部分"></a>相同的部分</h4><p>我们知道三种路由模式都是 <code>History</code> 的派生类，源码位置在 <a href="https://github1s.com/vuejs/vue-router/blob/HEAD/src/history/base.js">src/history/base.js</a>，我们先来看看它们一些比较重要的公用方法：</p><ul><li>onReady</li><li>onError</li><li>transitionTo</li><li>confirmTransition</li><li>updateRoute</li></ul><p>其实这些方法在前文中已经或多或少有提到了，其余的那些也只是做一些更新变量的操作，这里也不谈了。</p><p>其实还有一个非常重要的就是构造函数，它主要是做一些实例变量的初始化，这里混个眼熟就好：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">router: Router, base: ? string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.router = router</span><br><span class="line">    <span class="built_in">this</span>.base = normalizeBase(base)</span><br><span class="line">    <span class="comment">// start with a route object that stands for &quot;nowhere&quot;</span></span><br><span class="line">    <span class="built_in">this</span>.current = START</span><br><span class="line">    <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.ready = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.readyCbs = []</span><br><span class="line">    <span class="built_in">this</span>.readyErrorCbs = []</span><br><span class="line">    <span class="built_in">this</span>.errorCbs = []</span><br><span class="line">    <span class="built_in">this</span>.listeners = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们就讲讲它们不同的地方。</p><h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>hash 应该是最常用的一种模式了，它也是浏览器环境下的默认模式，至于它的特点相信大家也很熟悉了，就是利用 <code>URL</code> 中的 <code>hash</code> 值来做路由，这种模式兼容性是最好的。<br>​</p><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>我们先来看看它在初始化时会做哪些操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">router: Router, base: ? string, fallback : boolean</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(router, base)</span><br><span class="line">    <span class="comment">// check history fallback deeplinking</span></span><br><span class="line">    <span class="keyword">if</span> (fallback &amp;&amp; checkFallback(<span class="built_in">this</span>.base)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ensureSlash()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码不多，首先是检查是否因为回退而使用 hash 模式，如果是的话则调用 <code>checkFallback</code> 检查它的返回值，如果为 <code>true</code> 则不调用 <code>ensureSlash</code> 。<br>​</p><p>下面是 <code>checkFallback</code> 的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkFallback</span>(<span class="params">base</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个方法位于 src/history/html5.js，用于获取 URL 中的路径部分</span></span><br><span class="line">  <span class="comment">// http://a.com/user/routes =&gt; /user/routes</span></span><br><span class="line">  <span class="comment">// http://a.com/#/user/routes =&gt; /#/user/routes</span></span><br><span class="line">  <span class="keyword">const</span> location = getLocation(base)</span><br><span class="line">  <span class="comment">// 检查是否以 /## 开头，如果不是，则重定向至以 /## 开头</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="regexp">/^\/#/</span>.test(location)) &#123;</span><br><span class="line">    <span class="comment">// http://a.com/user/routes =&gt; http://a.com/#/user/routes</span></span><br><span class="line">    <span class="built_in">window</span>.location.replace(cleanPath(base + <span class="string">&#x27;/#&#x27;</span> + location))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说当我们使用了 <code>history</code> 模式但由于不支持需要回退到 <code>hash</code> 模式时，它会自动重定向到符合 <code>hash</code> 模式下的 <code>url</code> ，接着再执行 <code>ensureSlash</code> 方法。</p><p>下面是 <code>ensureSlash</code> 方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://a.com/#/user/routes =&gt; /user/routes</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getHash</span>(<span class="params"></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We can&#x27;t use window.location.hash here because it&#x27;s not</span></span><br><span class="line">  <span class="comment">// consistent across browsers - Firefox will pre-decode it!</span></span><br><span class="line">  <span class="keyword">let</span> href = <span class="built_in">window</span>.location.href</span><br><span class="line">  <span class="keyword">const</span> index = href.indexOf(<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">  <span class="comment">// empty path</span></span><br><span class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  href = href.slice(index + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> href</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceHash</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    replaceState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(getUrl(path))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureSlash</span>(<span class="params"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> path = getHash()</span><br><span class="line">  <span class="keyword">if</span> (path.charAt(<span class="number">0</span>) === <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  replaceHash(<span class="string">&#x27;/&#x27;</span> + path)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，就是判断一下 <code>hash</code> 部分是否以 <code>/</code> 开头，如果不是则要重定向到以 <code>/</code> 开头的 <code>URL</code> 。<br>​</p><p>这样就能解释我们在使用 vue-router 开发项目时，为什么打开调试页面 <a href="http://localhost:8080/">http://localhost:8080</a> 后会自动把 url 修改为 <a href="http://localhost:8080/#/">http://localhost:8080/#/</a> 了。</p><h5 id="push-和-replace"><a href="#push-和-replace" class="headerlink" title="push 和 replace"></a>push 和 replace</h5><p><code>hash</code> 模式的 <code>push</code> 方法我们在 <a href="#%E4%B8%89%E3%80%81-%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">三、 切换路由时发生了什么</a> 这一小节已经提到过了，其实 <code>replace</code> 也是大同小异，下面是这两个方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            pushHash(route.fullPath)</span><br><span class="line">            handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">replace</span>(<span class="params">location: RawLocation, onComplete ? : <span class="built_in">Function</span>, onAbort ? : <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="attr">current</span>: fromRoute</span><br><span class="line">    &#125; = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">        location,</span><br><span class="line">        <span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">            replaceHash(route.fullPath)</span><br><span class="line">            handleScroll(<span class="built_in">this</span>.router, route, fromRoute, <span class="literal">false</span>)</span><br><span class="line">            onComplete &amp;&amp; onComplete(route)</span><br><span class="line">        &#125;,</span><br><span class="line">        onAbort</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>replace</code> 方法跟 <code>push</code> 方法不同的地方是它调用的是 <code>replaceHash</code> 而不是 <code>pushHash</code> ，下面是 <code>replaceHash</code> 方法的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceHash</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (supportsPushState) &#123;</span><br><span class="line">    replaceState(getUrl(path))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.replace(getUrl(path))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下方法在 src/util/push-state.js 中</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushState</span>(<span class="params">url?: string, replace?: boolean</span>) </span>&#123;</span><br><span class="line">  saveScrollPosition()</span><br><span class="line">  <span class="comment">// try...catch the pushState call to get around Safari</span></span><br><span class="line">  <span class="comment">// DOM Exception 18 where it limits to 100 pushState calls</span></span><br><span class="line">  <span class="keyword">const</span> history = <span class="built_in">window</span>.history</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (replace) &#123;</span><br><span class="line">      <span class="comment">// preserve existing history state as it could be overriden by the user</span></span><br><span class="line">      <span class="keyword">const</span> stateCopy = extend(&#123;&#125;, history.state)</span><br><span class="line">      stateCopy.key = getStateKey()</span><br><span class="line">      history.replaceState(stateCopy, <span class="string">&#x27;&#x27;</span>, url)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      history.pushState(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">key</span>: setStateKey(genStateKey())</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        url</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location[replace ? <span class="string">&#x27;replace&#x27;</span> : <span class="string">&#x27;assign&#x27;</span>](url)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">replaceState</span>(<span class="params">url?: string</span>) </span>&#123;</span><br><span class="line">  pushState(url, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以它们在更新 <code>URL</code> 时的区别在于调用的是 <code>push</code> 还是 <code>replace</code> 方法。<br>​</p><h5 id="go"><a href="#go" class="headerlink" title="go"></a>go</h5><p>而 <code>go</code> 方法就更直接了，实际上就是调用 <code>history.go</code> 这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">go</span>(<span class="params">n: number</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.history.go(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家会不会疑惑，这里没有调用 <code>transitionTo</code> 方法， <code>vue-router</code> 是如何知道需要更新路由的呢？<br>​</p><p>这就是就得不得说一下 <code>setupListeners</code> 这个方法了。</p><h5 id="setupListeners"><a href="#setupListeners" class="headerlink" title="setupListeners"></a>setupListeners</h5><p>还记得在 <a href="#%E4%B8%89%E3%80%81-%E5%88%87%E6%8D%A2%E8%B7%AF%E7%94%B1%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88">三、 切换路由时发生了什么</a> 这一小节的 <code>init</code> 方法里有这么一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器环境下初始化时根据当前路由位置做路由跳转</span></span><br><span class="line"><span class="keyword">if</span> (history <span class="keyword">instanceof</span> HTML5History || history <span class="keyword">instanceof</span> HashHistory) &#123;</span><br><span class="line">  <span class="keyword">const</span> handleInitialScroll = <span class="function">(<span class="params">routeOrError</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">from</span> = history.current</span><br><span class="line">    <span class="keyword">const</span> expectScroll = <span class="built_in">this</span>.options.scrollBehavior</span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll &amp;&amp; <span class="string">&#x27;fullPath&#x27;</span> <span class="keyword">in</span> routeOrError) &#123;</span><br><span class="line">      handleScroll(<span class="built_in">this</span>, routeOrError, <span class="keyword">from</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> setupListeners = <span class="function">(<span class="params">routeOrError</span>) =&gt;</span> &#123;</span><br><span class="line">    history.setupListeners()</span><br><span class="line">    handleInitialScroll(routeOrError)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 切换路由的方法，这个方法后面会讲</span></span><br><span class="line">  history.transitionTo(</span><br><span class="line">    history.getCurrentLocation(),</span><br><span class="line">    setupListeners,</span><br><span class="line">    setupListeners</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>history</code> 或者 <code>hash</code> 模式下初始化时也会调用一下 <code>transitionTo</code> ，而这里传入的 <code>onComplete</code> 回调就会调用 <code>setupListeners</code> 方法，为什么要这么做呢？我们直接看 <code>setupListeners</code> 里面是什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">setupListeners</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.listeners.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> router = <span class="built_in">this</span>.router</span><br><span class="line">    <span class="keyword">const</span> expectScroll = router.options.scrollBehavior</span><br><span class="line">    <span class="keyword">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">        <span class="built_in">this</span>.listeners.push(setupScroll())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> handleRoutingEvent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> current = <span class="built_in">this</span>.current</span><br><span class="line">        <span class="comment">// 检查当前 URL 是否符合 hash 模式的规则，如果符合会直接重定向一下</span></span><br><span class="line">        <span class="comment">// 由于重定向后还是会再触发一下当前方法，这次就没必要执行了</span></span><br><span class="line">        <span class="keyword">if</span> (!ensureSlash()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.transitionTo(getHash(), <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (supportsScroll) &#123;</span><br><span class="line">                handleScroll(<span class="built_in">this</span>.router, route, current, <span class="literal">true</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!supportsPushState) &#123;</span><br><span class="line">                replaceHash(route.fullPath)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> eventType = supportsPushState ? <span class="string">&#x27;popstate&#x27;</span> : <span class="string">&#x27;hashchange&#x27;</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(eventType, handleRoutingEvent)</span><br><span class="line">    <span class="built_in">this</span>.listeners.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">window</span>.removeEventListener(eventType, handleRoutingEvent)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是做了两件事情：</p><ol><li>监听 <code>popstate</code> 或者 <code>hashchange</code> 事件，触发时会执行一下 <code>transitionTo</code>​</li><li>在 <code>listeners</code> 中存入两个回调：处理滚动相关、取消监听第 1 点中的事件</li></ol><p>也就是说 vue-router 除了调用 <code>push</code> 或者 <code>replece</code> 这些方法以外，它也支持通过其它方式来切换路由，只要这个操作会触发 <code>popstate</code> 或者 <code>hashchange</code> 事件，比如下面这些方式：</p><ul><li>如支持 <code>history</code> api<ul><li>history.pushState</li><li>history.replaceState</li><li>history.back</li><li>history.go</li></ul></li><li><code>location.hash = &#39;#/a&#39;</code></li></ul><p>当然这个事件监听器会在应用实例销毁时取消监听，避免产生副作用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">teardown</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// clean up event listeners</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/issues/2341</span></span><br><span class="line">    <span class="built_in">this</span>.listeners.forEach(<span class="function"><span class="params">cleanupListener</span> =&gt;</span> &#123;</span><br><span class="line">        cleanupListener()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">this</span>.listeners = []</span><br><span class="line">    <span class="comment">// reset current history route</span></span><br><span class="line">    <span class="comment">// https://github.com/vuejs/vue-router/issues/3294</span></span><br><span class="line">    <span class="built_in">this</span>.current = START</span><br><span class="line">    <span class="built_in">this</span>.pending = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4><p><code>history</code> 模式是基于 HTML5 History API 实现的，不过在生产环境上使用它还需要在服务器上配置路由转发才行，不过这仍是大部分项目的选择，毕竟这样比较好看，不像 hash 模式这么奇葩。</p><h5 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h5><p>我们看看 <code>history</code> 模式在初始化时会做哪些操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">router: Router, base: ? string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(router, base)</span><br><span class="line">    <span class="comment">// getLocation 方法在前面已经讲过，主要用于获取 URL 中的路径部分</span></span><br><span class="line">    <span class="built_in">this</span>._startLocation = getLocation(<span class="built_in">this</span>.base)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是初始化了一个 <code>_startLocation</code> 变量，这个变量的作用后面会讲到。<br>​</p><h5 id="push-和-replace、go"><a href="#push-和-replace、go" class="headerlink" title="push 和 replace、go"></a>push 和 replace、go</h5><p>其实 <code>history</code> 模式的这几个方法与 <code>hash</code> 模式是一模一样的，区别是它们在调用 <code>pushState</code> 时传入的 <code>URL</code> 不一样而已，关于 <code>pushState</code> 方法的定义前面已经讲过了。</p><h5 id="setupListeners-1"><a href="#setupListeners-1" class="headerlink" title="setupListeners"></a>setupListeners</h5><p><code>setupListeners</code> 与 <code>hash</code> 模式也是大同小异，区别在于它在判断 <code>URL</code> 与当前路由是否一致时有点不同：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const handleRoutingEvent = () =&gt; &#123;</span><br><span class="line">  const current = this.current</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  if (!ensureSlash()) &#123;</span></span><br><span class="line"><span class="deletion">-    return</span></span><br><span class="line"><span class="deletion">-  &#125;</span></span><br><span class="line"><span class="addition">+  const location = getLocation(this.base)</span></span><br><span class="line"><span class="addition">+  if (this.current === START &amp;&amp; location === this._startLocation) &#123;</span></span><br><span class="line"><span class="addition">+    return</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"></span><br><span class="line">  this.transitionTo(location, (route) =&gt; &#123;</span><br><span class="line">    if (supportsScroll) &#123;</span><br><span class="line">      handleScroll(router, route, current, true)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="abstract-模式"><a href="#abstract-模式" class="headerlink" title="abstract 模式"></a>abstract 模式</h4><p><code>abstract</code> 我们可能用得比较少，它主要是用在 <code>node</code> 环境下，也就是说在该模式下不会调用一切与浏览器相关的 <code>api</code> ，那它就只能用别的地方去维护当前 <code>URL</code> 与路由历史，由于不是很长，我直接放在一起讲了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHistory</span> <span class="keyword">extends</span> <span class="title">History</span> </span>&#123;</span><br><span class="line">  <span class="attr">index</span>: number</span><br><span class="line">  <span class="attr">stack</span>: <span class="built_in">Array</span>&lt;Route&gt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">router: Router, base: ?string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(router, base)</span><br><span class="line">    <span class="comment">// 堆栈，用于维护路由历史</span></span><br><span class="line">    <span class="built_in">this</span>.stack = []</span><br><span class="line">    <span class="comment">// 当前所在路由在 stack 中的索引</span></span><br><span class="line">    <span class="built_in">this</span>.index = -<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">push</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前跳转的路由存入栈中，index + 1</span></span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="built_in">this</span>.stack.slice(<span class="number">0</span>, <span class="built_in">this</span>.index + <span class="number">1</span>).concat(route)</span><br><span class="line">        <span class="built_in">this</span>.index++</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">replace</span>(<span class="params">location: RawLocation, onComplete?: <span class="built_in">Function</span>, onAbort?: <span class="built_in">Function</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.transitionTo(</span><br><span class="line">      location,</span><br><span class="line">      <span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前跳转的路由替换之前路由所在的位置，index 不变</span></span><br><span class="line">        <span class="built_in">this</span>.stack = <span class="built_in">this</span>.stack.slice(<span class="number">0</span>, <span class="built_in">this</span>.index).concat(route)</span><br><span class="line">        onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      &#125;,</span><br><span class="line">      onAbort</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">go</span>(<span class="params">n: number</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> targetIndex = <span class="built_in">this</span>.index + n</span><br><span class="line">    <span class="keyword">if</span> (targetIndex &lt; <span class="number">0</span> || targetIndex &gt;= <span class="built_in">this</span>.stack.length) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> route = <span class="built_in">this</span>.stack[targetIndex]</span><br><span class="line">    <span class="built_in">this</span>.confirmTransition(</span><br><span class="line">      route,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> prev = <span class="built_in">this</span>.current</span><br><span class="line">        <span class="comment">// 将跳转至的路由索引指向 index</span></span><br><span class="line">        <span class="built_in">this</span>.index = targetIndex</span><br><span class="line">        <span class="built_in">this</span>.updateRoute(route)</span><br><span class="line">        <span class="built_in">this</span>.router.afterHooks.forEach(<span class="function">(<span class="params">hook</span>) =&gt;</span> &#123;</span><br><span class="line">          hook &amp;&amp; hook(route, prev)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isNavigationFailure(err, NavigationFailureType.duplicated)) &#123;</span><br><span class="line">          <span class="built_in">this</span>.index = targetIndex</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getCurrentLocation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> current = <span class="built_in">this</span>.stack[<span class="built_in">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> current ? current.fullPath : <span class="string">&#x27;/&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">ensureURL</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// noop</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文完，感谢阅读。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是针对 vue-router &lt;a href=&quot;https://github.com/vuejs/vue-router/releases</summary>
      
    
    
    
    
    <category term="前端" scheme="https://4ark.me/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="Vue" scheme="https://4ark.me/tags/Vue/"/>
    
    <category term="源码解析" scheme="https://4ark.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
</feed>
